{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Dataview is a live index and query engine over your knowledge base. You can associate data (like tags, dates, snippets, numbers, and so on) with your markdown pages, and then query (like filter, sort, transform) this data. This is a simple but powerful idea: Track sleep schedules and habits by recording them in daily notes, and automatically create weekly tables of your sleep schedule. Automatically collect links to books in your notes, and render them all sorted by rating. Automatically collect pages annotated with a given date, showing them in your daily note or elsewhere. Find pages with no tags for follow-up, or show pretty views of specifically-tagged pages. Create dynamic views which show upcoming birthdays or events, annotated with notes. Dataview is highly generic and high performance, scaling up to hundreds of thousands of annotated notes without issue. If the built in query language is insufficient for your purpose, you can run arbitrary JavaScript against the dataview API . Basic Usage Dataview has two major components: annotation and querying . Each operates largely independently and are described below. Annotation The dataview index is responsible for constantly parsing markdown files and other metadata in your vault, creating an in-memory index which allows for fast queries over your data. Annotation is done at the markdown page , section , and task level, where you can either use: Frontmatter , a common Markdown extension which allows for adding arbitrary YAML at the top of a document): --- alias : \"document\" last-reviewed : 2021-08-17 thoughts : rating : 8 reviewable : false --- Inline Fields , a Dataview-specific way to provide metadata in an intuitive Key:: Value syntax: # Markdown Page Some text, and then [Inline Field:: Value] [Another Inline Field On The Same Line:: With A New Value!] Basic Field:: Value **Bold Field** :: Nice! - [ ] I am a task with [metadata::value]! - [X] I am another task with completed::2020-09-15 You can combine both methods if desired. Dataview also adds a significant number of \"implicit\" fields, like file.name for the file name, file.size for the size, and so on; you can find more details in the data annotation documentation . Querying Once you have some pages that you've annotated, all that's left to do is query them to create dynamic table, list, or JavaScript views. There are four ways to do this: Dataview Query Language (DQL) : A pipeline-based, vaguely SQL-looking expression language which can support basic use cases. See the guide for an overview of how to use DQL, or check out the reference material for details. ```dataview TABLE file.name AS \"File\", rating AS \"Rating\" FROM #book ``` Inline Expressions : DQL expressions which you can embed directly inside markdown and which will be evaluated in preview mode. See the documentation for allowable queries. We are on page `= this.file.name` . DataviewJS : A high-powered JavaScript API which gives full access to the Dataview index and some convienent rendering utilities. Highly recommended if you know JavaScript, since this is far more powerful than the query language. Check the documentation for more details. ```dataviewjs dv.taskList(dv.pages().file.tasks.where(t => !t.completed)); ``` Inline JS Expressions : The JavaScript equivalent to inline expressions, which allow you to execute arbitary JS inline: This page was last modified at `$= dv.current().file.mtime` . Resources and Help See getting started for a list of resources and how to find support.","title":"Overview"},{"location":"#overview","text":"Dataview is a live index and query engine over your knowledge base. You can associate data (like tags, dates, snippets, numbers, and so on) with your markdown pages, and then query (like filter, sort, transform) this data. This is a simple but powerful idea: Track sleep schedules and habits by recording them in daily notes, and automatically create weekly tables of your sleep schedule. Automatically collect links to books in your notes, and render them all sorted by rating. Automatically collect pages annotated with a given date, showing them in your daily note or elsewhere. Find pages with no tags for follow-up, or show pretty views of specifically-tagged pages. Create dynamic views which show upcoming birthdays or events, annotated with notes. Dataview is highly generic and high performance, scaling up to hundreds of thousands of annotated notes without issue. If the built in query language is insufficient for your purpose, you can run arbitrary JavaScript against the dataview API .","title":"Overview"},{"location":"#basic-usage","text":"Dataview has two major components: annotation and querying . Each operates largely independently and are described below.","title":"Basic Usage"},{"location":"#annotation","text":"The dataview index is responsible for constantly parsing markdown files and other metadata in your vault, creating an in-memory index which allows for fast queries over your data. Annotation is done at the markdown page , section , and task level, where you can either use: Frontmatter , a common Markdown extension which allows for adding arbitrary YAML at the top of a document): --- alias : \"document\" last-reviewed : 2021-08-17 thoughts : rating : 8 reviewable : false --- Inline Fields , a Dataview-specific way to provide metadata in an intuitive Key:: Value syntax: # Markdown Page Some text, and then [Inline Field:: Value] [Another Inline Field On The Same Line:: With A New Value!] Basic Field:: Value **Bold Field** :: Nice! - [ ] I am a task with [metadata::value]! - [X] I am another task with completed::2020-09-15 You can combine both methods if desired. Dataview also adds a significant number of \"implicit\" fields, like file.name for the file name, file.size for the size, and so on; you can find more details in the data annotation documentation .","title":"Annotation"},{"location":"#querying","text":"Once you have some pages that you've annotated, all that's left to do is query them to create dynamic table, list, or JavaScript views. There are four ways to do this: Dataview Query Language (DQL) : A pipeline-based, vaguely SQL-looking expression language which can support basic use cases. See the guide for an overview of how to use DQL, or check out the reference material for details. ```dataview TABLE file.name AS \"File\", rating AS \"Rating\" FROM #book ``` Inline Expressions : DQL expressions which you can embed directly inside markdown and which will be evaluated in preview mode. See the documentation for allowable queries. We are on page `= this.file.name` . DataviewJS : A high-powered JavaScript API which gives full access to the Dataview index and some convienent rendering utilities. Highly recommended if you know JavaScript, since this is far more powerful than the query language. Check the documentation for more details. ```dataviewjs dv.taskList(dv.pages().file.tasks.where(t => !t.completed)); ``` Inline JS Expressions : The JavaScript equivalent to inline expressions, which allow you to execute arbitary JS inline: This page was last modified at `$= dv.current().file.mtime` .","title":"Querying"},{"location":"#resources-and-help","text":"See getting started for a list of resources and how to find support.","title":"Resources and Help"},{"location":"changelog/","text":"0.5.47 Improves date + duration behavior when either the date or duration are null. 0.5.46 Fix #1412: Fix bad file.cday and file.ctime comparisons due to wrong timezone being set. Ugh. 0.5.45 1400: Properly use the group by field for the group name. Fix bad table highlighting in some themes. 0.5.44 1404: Fixed dates in non-local timezones parsing incorrectly. Fixed some build non-determinism issues. Swapped to pull requests for adding new functionality, and added some more internal tests. 0.5.43 Fix #1366: Better handling of calendar emoji (used as due dates in tasks). 0.5.42 It's been over a month since the last release! Anyway, this release bundles several nice user-contributed features: @AB1908: Tag queries are now case insensitive. @AB1908: Shift-clicking a link/task to open in a new tab now works properly on Mac. @AB1908: Numerous documentation fixes for clarity and more examples. @AnnaKornfeldSimpson: Additional emoji shorthands for more task fields (finished, due). @ooker777: Documentation improvements for some DataviewJS functions, and the ability to use inline emoji for the completion tracking feature. @mt-krainski: Custom date formats for task completions. @gentlegiantJGC: Better support for nested inline fields (i.e., less crashy). 0.5.41 Fix a bad regex doing escaping in markdown tables. Improve async documentation. 0.5.40 Adds some more documentation about the new markdown functionality. 0.5.39 Fixed an issue where checking a task in a task view would check the wrong box visually. Added experimental plugin APIs for querying dataview directly as markdown, and converting dataview results to properly formatted markdown. 0.5.38 Some minor documentation improvements. Fix an issue with inline fields rendering out of order. That was a wierd bug. 0.5.37 Fixes inline field rendering to once again work for highlighting/links, as well as some other rendering quirks with inline queries in codeblocks. 0.5.36 Fix a bug when checking if an element is an HTMLElement. Properly include the nice improvements to the file count in tables and lists. 0.5.35 Fix #1196, #1176: Re-enable HTML values. This was never a featured I advertised since it was just for some internal hackery, but it appears people just discovered it in DataviewJS queries. Improved initial time to popular queries that use file.starred . 0.5.34 Fix #1174: Fix indexing with a variable. Fix an issue with the experimental calendar view. 0.5.33 Fix a bug with inline views that was introduced in 0.5.32. 0.5.32 The Dataview API has been noticably revamped - there are now approximately twice as many functions available on the plugin API as there were before, and some additional utilities have been added to both the plugin and inline API. I will be finishing up the associated new \"extension\" functionality shortly, which will allow: For custom Dataview + DataviewJS functions to be added via plugins. For custom renderable objects (progress bars, embedded task lists, embedded tables) to be added to any Dataview view via plugins. For plugins to provide alternative behavior for some dataview functionality (such as integrating task plugins with the dataview task query). As part of the API revamp, it is now possible to programmatically execute Dataview and DataviewJS queries - either for using the existing Dataview query language in your own plugin, or for embedding dataview. The Dataview npm library also now exposes many useful internal Dataview types, including the AST structure for all dataview queries. I am hoping that cleaning up the Dataview API and making it much more extensible will allow for Dataview to integrate much better with existing plugins, and to provide the full power of the in-memory index for plugins. I have been very carefully watching index performance in recent weeks to ensure smooth frontend performance for anyone using the API (with a goal of <10ms for most queries). 0.5.31 Tasks now have an outlinks list field which includes all links in the task; this can be used for finding tasks with links in them. 0.5.30 Added the typeof(any) function in Dataview, which obtains the type of any value for comparison: typeof ( \"text\" ) = \"string\" typeof ( 1 ) = \"number\" typeof ([ 1 , 2 , 3 ]) = \"array\" Added the modulo operator ( % ) for doing integer division remainder. I.e., 14 % 2 = 0 and 14 % 3 = 2 . Fixed some minor spacing issues with lists in tables. 0.5.29 Fix another subtle incompatibility between 0.4.26 and 0.5.29 - if you frequently used empty inline fields (like Key:: with no value), the 0.5+ behavior is now the same as 0.4 behavior and will map such fields to null instead of an empty string. This may fix a broad variety of \"subtly wrong\" queries that you may have seen after the upgrade. 0.5.28 Fix a bug with some more string concatenations and null handling. 0.5.27 More performance + correctness bugfixes. The parser has been made a little more robust to prevent major indexing issues (or at least recover from them quickly). Several new strange tag variants are now supported. Markdown links are now properly indexed again. Some DataviewJS performance issues should be resolved now, especially for external plugins using Dataview. This fix does involve a slight API break w.r.t. what types are wrapped into Dataview Arrays (which provide functions like .where() ). Generally, only Dataview-provided implicits are wrapped in data arrays now; frontmatter and inline fields are always now regular JS arrays - use dv.array() to explicitly make a data array if you want the advanced querying. 0.5.26 More small bugfixes: Fix a few small link rendering issues. Tag extraction from tasks now handles punctuation properly. Upgrade luxon (which is embedded in DataviewJS) to 2.4.0. 0.5.25 Fix #1147: Fix there being a #null tag for files with an empty tag or tags frontmatter. 0.5.24 Several bugfixes: Nulls are now sorted first rather than last; it's generally good practice to explicitly check for nulls in your queries to avoid strange behavior. Dataview now properly parses space-delimited tags (like tags: abc def ghi ). Dataview now supports dropping the entire file cache in case of bugs. 0.5.23 Fix #1140: Force API objects to be arrays if they are iterables. 0.5.22 Fix #1135: Use 'x' instead of 'X' for checkboxes. 0.5.21 A long-overdue swap from the beta branch to the stable branch. The beta branch should not include any (intended) breaking changes, and has some nice performance improvements that come along with it! Here are the major changes: Most views now use React and no longer flicker when updating; this is not the case yet for DataviewJS, which will be getting equivalent treament in the future. Dataview now caches metadata, so Dataview loads are very fast after the first time you open your vault. Dataview still needs to visit every file when you update the plugin version, so that should be the only times you experience slower load times. A brand new task view backend and query which allows you to filter per-task, rather than per-page! Check the documentation for details, but this broadly means WHERE statements now use task properties instead of page properties. Some additional metadata is now available for use - file.starred , file.lists , and more metadata in file.tasks . There have been some moderate documentation touch-ups to keep things up to date; I'm still working on a walkthrough for common Dataview usecases. This review also includes about ~30-40 bugfixes; some new bugs may arise due to internal changes, so please flag them if you encounter them. 0.5.20 (Beta) Slight fix to hopefully improve some strange reported cases of bad indexing at startup. 0.5.19 (Beta) Dataview now uses IndexedDB to cache file metadata, reducing startup time to virtually nothing if you've opened the vault before; if you have a small vault (<1000 notes), you may notice a slight improvement, but large vaults and mobile devices will notice a very significant performance improvement to \"first valid paint\". Some other performance parameters have been tuned to hopefully make the default experience better. A few small bugs related to rendering have also been squashed, including an issue with images being scaled wrongly. 0.5.18 (Beta) Tasks in task views now support alternative task status characters like '!' and '/'; thanks @ebullient. A few documentation nit fixes. Added DataArray#sortInPlace for a more efficient mutable sort for niche use cases. 0.5.17 (Beta) Improved behavior when clicking on tasks in the task view; will now properly scroll to the relevant line in long files! Fixed a bug with incorrect counts being displayed in task views. Added tags as a field available on task items, so you can now do things like TASK WHERE contains(tags, \"#tag\") . 0.5.16 (Beta) Dataview now tracks initialization and will report when all files have been indexed in the console; you can programmatically see this via dataview:index-ready , or by checking api.index.initialized . 0.5.15 (Beta) Add hover highlights to tables to make seeing rows a little easier. Tables and task lists now include counts of the number of results in the headers. Further improved task selection in the task view. 0.5.14 (Beta) Fix task highlighting when not grouping. Remove some spurious console logging. Slightly improve task highlighting behavior when clicking on a task. 0.5.13 (Beta) Several smaller bugfixes! Fix #997: Use the group by field name in the table name. Prevent tons of errors if you incorrectly set the inline query prefix. 0.5.12 (Beta) Improve error messages for queries somewhat and get rid of some ugly output. 0.5.11 (Beta) Add detection of tasks inside of block quotes, as well as correctly implement automatic checking and unchecking of these tasks. 0.5.10 (Beta) Adds the Dataview: Force Refresh Views Command (accessible via the Ctrl+P command view) to force current views to refresh immediately. 0.5.9 (Beta) Another fix for due-date related emoji in tasks. I hate emoji. 0.5.8 (Beta) Fix some issues with infinite loops of tasks due to bad Obsidian metadata (potentially due to being out of date?). 0.5.7 (Beta) Fix issues with parsing '\ud83d\uddd3\ufe0f2021-08-29' due-date annotations on tasks, as well as an issue with properly extracting due/completed/completed times for use in queries. 0.5.6 (Beta) Proper release of 0.5.5 plus one additional small improvement: Add duration * number and duration / number operations for manipulation durations numerically. 0.5.5 (Beta) More small features: Fix issues with task sorting not doing anything. Sort away! Table headers can now be arbitrary markdown. So you can put things like links in your headers: `TABLE (1 + 2) AS \"[[File]]\". You can now specify the size of an image embed by providing WxH in it's display property: ![[image.png|50x50]] . 0.5.4 (Beta) Improved image rendering for some link types, and adds the embed(link) and embed(link, false) options to convert links to/from their embedded equivalents. 0.5.3 (Beta) Iterative beta which adds a few nice QoL features and fixes some more bugs: Internally swapped to a React-based renderer; this should not have a noticable perf or usability impact, but makes it easier for me to implement complex table/list behaviors. Naming your fields with AS \"Name\" is now optional; Dataview will infer the name from the expression automatically. For example, TABLE 8 + 4, 3 + 6 FROM ... is now a valid table expression, and the columns will be named 8 + 4 and 3 + 6 respectively. Some issues with array and object rendering were corrected. Error messages on empty dataview results were improved and now show up for all views. Inline images are now rendered correctly in Dataview tables and lists - no more hacky app://local/ schenanigans! 0.5.2 (Beta) Fix #971: Objects now work properly inside DataviewQL evaluation. 0.5.1 (Beta) Temporarily revert the new task metadata behavior: inline fields in sublists of tasks are added to the page, instead of the task. This behavior is not good, but is compatible with legacy usages of task metadata, which should uinbreak some existing queries. This behavior will be removed in the future behind a flag. Added the 'visual' field to tasks - if set, tasks render 'visual' instead of their regular text. Fixed DataArray#mutate() . 0.5.0 (Beta) Re-release of broken release 0.4.23, now hopefully with fixes that make it work on (most) machines. I'll be doing beta releases for a little while until I can confirm the new version is stable; use BRAT (https://github.com/TfTHacker/obsidian42-brat) to easily track Dataview beta versions if you are interested in cutting edge features. 0.4.25 Fix #867: Create a container div per taskList to allow for multiple task views. 0.4.24 Re-release of 0.4.23f since Obsidian does not automatically update between non-semver versions. 0.4.23f Remove some code which attempted to make tag queries case-insensitive; I'll reimplement this more generally later (it conflicts with existing queries which check tags via contains(file.tags, \"#Tag\") and similar). 0.4.23e More task bugfixes / improvements, and a fix that caused task metadata to be duplicated. 0.4.23d More inline field list parsing bug fixes. Hopefully we're back to a nice working order! 0.4.23c Bugfix which adds support for '1)' style lists, as well as a very annoying null issue due to JavaScript being a very sad, very sad language. 0.4.23b Bugfix for bad inlink/outlink computations; links were not being normalized properly so reverse lookups were not working. 0.4.23 The Task Update! This release reworks how dataview handles tasks and list items so that they should be much more intuitive to use and interact with: Subtask Support : Queries now search over all list items, instead of only over root elements. This should make task filtering much more usable, especially if you tend to put tasks under other list items or care specifically about subtasks. Multiline Support : Dataview now understands multi-line tasks and renders/updates them correctly. Immediately Navigate to Task : The new task view, aside from looking a little cleaner than previous views, now immediately navigates to the task in it's original file on click and selects it. Grouping Support : For DataviewJS users, dv.taskList now supports grouping (as produced by groupBy and the new groupIn ) natively. For DataviewJS users, the task and list representation has changed: file.tasks (and the new file.lists ) contain every single task (including subtasks) in the file, instead of only the root elements. You can return to previous behavior by filtering out tasks with a non-null parent - i.e., file.tasks.where(task => !task.parent) . dv.taskList will intelligently deal with properly nesting and de-duplicating tasks, so just filter to the tasks you want to render and the API will do the rest. This release also includes general backend improvements as we prepare for live-editing in Dataview views, as well as several community-contributed API improvements: DataArray#groupIn : For grouping already grouped data, you can now use array.groupIn(v => ...) , which will group the innermost (original) data in the array instead of the top level groups. This allows for more easily grouping recursively, such as dv.pages().groupBy(page => page.file.folder).groupIn(page => page.title) producing a grouping of folders, then page titles. substring(string, start[, end]) : The last major missing string function is now available! Take slices of strings. Improved dv.el() and other HTML functions - thanks @vitaly. null and undefined entries sort at the end instead of the beginning by default; sorry to those whose code sorts wrong because of this, but it is a better default for most people's use cases. All links are now properly normalized to their full paths, fixing many link comparison edge cases in DataviewJS. Documentation additions for the new task functionality will be coming out in the next few days. The next release 0.4.24 is currently targeting expanded FROM query support, basic table view improvements, and general exporting functionality for Dataview. See you then! 0.4.22 The @pjeby update! This includes several performance improvements suggested by @pjeby to dramatically improve background Dataview performance as well as reduce some memory pressure. It also includes some minor bug-fixes and preliminary functionality: Target ES2018 for better Promise support Allow parsing shorthands in dv.date() . Add additional metadata to inline field rendering which can be styled. Cleanup events & workers on plugin uninstall, improving the Dataview uninstall/disable/reload experience. Add preliminary CALENDAR queries - rendering similar to the obsidian-calendar plugin, see the documentation! Dataview should perform much better on startup and when you have lots of tabs open - thanks again to @pjeby. 0.4.21 Bugfix release which primarily fixes issues that Dataview had with the live preview mode in upcoming Obsidian versions; Dataview live preview should now be functional. Also includes a number of smaller bugfixes. Fix #646: Add date(yesterday) to create a date 24 hours ago. Fix #618: Luxon is now available on the dataview API ( dv.luxon ). Fix #510: Add dv.duration() for parsing durations. Fix #647: All HTML functions in the DataviewJS API now return their rendered objects. Fix #652: Fix parsing of invalid dates. Fix #629: Fix block link parsing. Fix #601: Timezones are now rendered properly and parsed properly in Dataview dates. PR #637: Add meta(link) which allows you to access various metadata about a link itself. Various minor null safety fixes. Dataview now reports it's exact version and build time in logs. 0.4.20 Some feature work (mostly by other contributors) while I while away at section metadata. May also fix a few bugs! Fix #448: You can now use the \"Task Completion Tracking\" option to automatically add completion metadata to tasks which are checked/unchecked through Dataview. Thanks to @sheeley. Add a search bar to documentation. Thanks to @tzhou. Add new date expressions for the start of the week ( date(sow) ), and the end of the week ( date(eow) ). Thanks @Jeamee and @v_mujunma. Small minor bugfix / security releases may follow in the near future; otherwise, the next major release will include section and object metadata. 0.4.19 Bugfix release which corrects emoji parsing & localization issues. Add DataArray#into , which lets you index into objects without flattening. Renamed 'header' to 'section' in task metadata; 'header' will remain around for a few major releases to let people naturally migrate. Fix #487: You no longer need spaces around '*' in expressions. Fix #559: Fix unicode issues in variable canonicalization which was causing problems with non-Latin inline field keys. Duration Parsing You can now include multiple units in durations: dur(8 minutes, 4 seconds) or dur(2yr8mo12d) . You can separate durations by commas, or use the abbreviated syntax with/without spaces. 0.4.18 Bugfix release which fixes bad inline field highlighting if '[' and '(' are mixed on the same line in particular orders. 0.4.17 Minor feature release to patch up more implementation holes. Single File Queries You can now query from a specific file (instead of just folders and tags) by specifying the full file path: TASK FROM \"dataview/Test\" ... This is primarily useful for task queries, but will soon be useful for section and object queries in the near future as well. Better Inline Field Highlighting The CSS for inline field highlighting has been fixed and some compatibility issues improved, so it should work on all themes now instead of only a few. dv.el() DataviewJS now has dv.el() , which is like existing functions like dv.paragraph and dv.span but can create any HTML element type; for example: dv . el ( \"b\" , \"Text!\" ); dv . el ( \"i\" , 18 ); 0.4.16 Small performance release which substantially reduces the impact Dataview has on vault loading times (by spreading out file loading). The Dataview Index is now also eagerly initialized, so plugin consumers of the API can immediately start using it instead of waiting for the dataview:api-ready event. 0.4.15 A simple fix for #537 which properly 'awaits' value rendering in dv.view() . Fixes issues with values rendering out of order. 0.4.14 Small bugfix release. Fixes inline field evaluation when using the new fancy highlighting. You can now configure whether task links should show up at the beginning or end of the task (or just disable them) in the \"Task Link Location\" setting. Most setting updates will immediately be applied to existing Dataviews. 0.4.13 Bugfix release which adds fancy rendering to inline-inline fields and includes a few bugfixes. Pretty Inline Fields Inline fields of the form [key:: value] will now be rendered with fancy new HTML! By default, they are rendered with both the key and value. You can only render the value using parenthesis instead: (key:: value) . You can disable this feature in the configuration. Full-line inline fields (that Dataview has supported for a long time) will gain similar rendering support soon; in the meanwhile, give the new syntax a try! Task Linking Tasks now render with a link to the page/section that they are defined in, making GROUP BY and custom task editing easier to do: A Task. \ud83d\udd17 Another Task. \ud83d\udd17 Some Random Subtask. \ud83d\udd17 You can configure the symbol for the link or disable it alltogether. Improving DataviewJS Posture I am currently actively looking into improving DataviewJS sandboxing and general security posture. As a first small step in this, I have made DataviewJS opt-in instead of opt-out, and added a separate control for Inline DataviewJS. You may need to re-enable it in your settings if you use it. More improvements and better JavaScript sandboxing will follow. 0.4.12-hotfix1 Re-release of 0.4.12 that fixes an important indexing issue. Fix #505: Use completion instead of completed when setting task completion time. Fix #509: Add startswith / endswith string functions. Fix #488: Add padleft and padright , and string . Fix #506, #512: Fix date comparisons due to a bizarre date zone issue. 0.4.12 Bugfix release following up 0.4.11 which includes a few minor function additions. Fix #512: Strange zone issue causing dates to not be equal. Fix #506: Same as #512. Fix #488: Add padleft / padright functions. Fix #509: Add startswith and endswith functions. Fix #505: Correctly read completion dates for tasks from completion . This release also includes improved testing thanks to mocking Obsidian plugin APIs! 0.4.11 Fixes task behavior and adds \"truly inline\" fields! Improved Task Behavior Task queries are now much improved from their primitive foundations - you can now filter, sort, and group them! The FROM block is still page-based, sadly, though you can simply use WHERE instead if desired. For example, you can now access task fields like text , line , or completed : TASK WHERE contains(text, \"#tag\") WHERE !completed GROUP BY file.folder The full list of all available task metadata can be found here ; tasks include all the information needed to uniquely identify them, and automatically inherit all of the metadata from their parent file as well (so you can access file.name , for example). You can also annotate tasks with inline fields, as described in the section below. There is some additional UX work to be done - primarily on more easily allowing you to navigate to where the task is defined, as well as render tasks in views other than the TASK view. The semantics of how grouping works (to make it more intuitive/useful than it currently is) will likely also be revisited. Inline Inline Fields Early support for truly inline fields have been added, where you can add metadata in the middle of a sentence. It looks similar to existing inline field syntax, but with brackets or parenthesis: I would rate this a [rating:: 6]. It was (thoughts:: acceptable). Improved rendering for all inline fields is coming in an unpcoming update to improve the visual look of these inline fields. Issues Fix #496: Fix task SORT functionality to do something. Fix #492: Tasks now properly annotated with parent file information. Fix #498: Fix task checking/unchecking logic (which broke due to a change in the task regex...). Initial Start of the automatic changelog.","title":"Changelog"},{"location":"changelog/#0547","text":"Improves date + duration behavior when either the date or duration are null.","title":"0.5.47"},{"location":"changelog/#0546","text":"Fix #1412: Fix bad file.cday and file.ctime comparisons due to wrong timezone being set. Ugh.","title":"0.5.46"},{"location":"changelog/#0545","text":"","title":"0.5.45"},{"location":"changelog/#1400-properly-use-the-group-by-field-for-the-group-name","text":"Fix bad table highlighting in some themes.","title":"1400: Properly use the group by field for the group name."},{"location":"changelog/#0544","text":"","title":"0.5.44"},{"location":"changelog/#1404-fixed-dates-in-non-local-timezones-parsing-incorrectly","text":"Fixed some build non-determinism issues. Swapped to pull requests for adding new functionality, and added some more internal tests.","title":"1404: Fixed dates in non-local timezones parsing incorrectly."},{"location":"changelog/#0543","text":"Fix #1366: Better handling of calendar emoji (used as due dates in tasks).","title":"0.5.43"},{"location":"changelog/#0542","text":"It's been over a month since the last release! Anyway, this release bundles several nice user-contributed features: @AB1908: Tag queries are now case insensitive. @AB1908: Shift-clicking a link/task to open in a new tab now works properly on Mac. @AB1908: Numerous documentation fixes for clarity and more examples. @AnnaKornfeldSimpson: Additional emoji shorthands for more task fields (finished, due). @ooker777: Documentation improvements for some DataviewJS functions, and the ability to use inline emoji for the completion tracking feature. @mt-krainski: Custom date formats for task completions. @gentlegiantJGC: Better support for nested inline fields (i.e., less crashy).","title":"0.5.42"},{"location":"changelog/#0541","text":"Fix a bad regex doing escaping in markdown tables. Improve async documentation.","title":"0.5.41"},{"location":"changelog/#0540","text":"Adds some more documentation about the new markdown functionality.","title":"0.5.40"},{"location":"changelog/#0539","text":"Fixed an issue where checking a task in a task view would check the wrong box visually. Added experimental plugin APIs for querying dataview directly as markdown, and converting dataview results to properly formatted markdown.","title":"0.5.39"},{"location":"changelog/#0538","text":"Some minor documentation improvements. Fix an issue with inline fields rendering out of order. That was a wierd bug.","title":"0.5.38"},{"location":"changelog/#0537","text":"Fixes inline field rendering to once again work for highlighting/links, as well as some other rendering quirks with inline queries in codeblocks.","title":"0.5.37"},{"location":"changelog/#0536","text":"Fix a bug when checking if an element is an HTMLElement. Properly include the nice improvements to the file count in tables and lists.","title":"0.5.36"},{"location":"changelog/#0535","text":"Fix #1196, #1176: Re-enable HTML values. This was never a featured I advertised since it was just for some internal hackery, but it appears people just discovered it in DataviewJS queries. Improved initial time to popular queries that use file.starred .","title":"0.5.35"},{"location":"changelog/#0534","text":"Fix #1174: Fix indexing with a variable. Fix an issue with the experimental calendar view.","title":"0.5.34"},{"location":"changelog/#0533","text":"Fix a bug with inline views that was introduced in 0.5.32.","title":"0.5.33"},{"location":"changelog/#0532","text":"The Dataview API has been noticably revamped - there are now approximately twice as many functions available on the plugin API as there were before, and some additional utilities have been added to both the plugin and inline API. I will be finishing up the associated new \"extension\" functionality shortly, which will allow: For custom Dataview + DataviewJS functions to be added via plugins. For custom renderable objects (progress bars, embedded task lists, embedded tables) to be added to any Dataview view via plugins. For plugins to provide alternative behavior for some dataview functionality (such as integrating task plugins with the dataview task query). As part of the API revamp, it is now possible to programmatically execute Dataview and DataviewJS queries - either for using the existing Dataview query language in your own plugin, or for embedding dataview. The Dataview npm library also now exposes many useful internal Dataview types, including the AST structure for all dataview queries. I am hoping that cleaning up the Dataview API and making it much more extensible will allow for Dataview to integrate much better with existing plugins, and to provide the full power of the in-memory index for plugins. I have been very carefully watching index performance in recent weeks to ensure smooth frontend performance for anyone using the API (with a goal of <10ms for most queries).","title":"0.5.32"},{"location":"changelog/#0531","text":"Tasks now have an outlinks list field which includes all links in the task; this can be used for finding tasks with links in them.","title":"0.5.31"},{"location":"changelog/#0530","text":"Added the typeof(any) function in Dataview, which obtains the type of any value for comparison: typeof ( \"text\" ) = \"string\" typeof ( 1 ) = \"number\" typeof ([ 1 , 2 , 3 ]) = \"array\" Added the modulo operator ( % ) for doing integer division remainder. I.e., 14 % 2 = 0 and 14 % 3 = 2 . Fixed some minor spacing issues with lists in tables.","title":"0.5.30"},{"location":"changelog/#0529","text":"Fix another subtle incompatibility between 0.4.26 and 0.5.29 - if you frequently used empty inline fields (like Key:: with no value), the 0.5+ behavior is now the same as 0.4 behavior and will map such fields to null instead of an empty string. This may fix a broad variety of \"subtly wrong\" queries that you may have seen after the upgrade.","title":"0.5.29"},{"location":"changelog/#0528","text":"Fix a bug with some more string concatenations and null handling.","title":"0.5.28"},{"location":"changelog/#0527","text":"More performance + correctness bugfixes. The parser has been made a little more robust to prevent major indexing issues (or at least recover from them quickly). Several new strange tag variants are now supported. Markdown links are now properly indexed again. Some DataviewJS performance issues should be resolved now, especially for external plugins using Dataview. This fix does involve a slight API break w.r.t. what types are wrapped into Dataview Arrays (which provide functions like .where() ). Generally, only Dataview-provided implicits are wrapped in data arrays now; frontmatter and inline fields are always now regular JS arrays - use dv.array() to explicitly make a data array if you want the advanced querying.","title":"0.5.27"},{"location":"changelog/#0526","text":"More small bugfixes: Fix a few small link rendering issues. Tag extraction from tasks now handles punctuation properly. Upgrade luxon (which is embedded in DataviewJS) to 2.4.0.","title":"0.5.26"},{"location":"changelog/#0525","text":"Fix #1147: Fix there being a #null tag for files with an empty tag or tags frontmatter.","title":"0.5.25"},{"location":"changelog/#0524","text":"Several bugfixes: Nulls are now sorted first rather than last; it's generally good practice to explicitly check for nulls in your queries to avoid strange behavior. Dataview now properly parses space-delimited tags (like tags: abc def ghi ). Dataview now supports dropping the entire file cache in case of bugs.","title":"0.5.24"},{"location":"changelog/#0523","text":"Fix #1140: Force API objects to be arrays if they are iterables.","title":"0.5.23"},{"location":"changelog/#0522","text":"Fix #1135: Use 'x' instead of 'X' for checkboxes.","title":"0.5.22"},{"location":"changelog/#0521","text":"A long-overdue swap from the beta branch to the stable branch. The beta branch should not include any (intended) breaking changes, and has some nice performance improvements that come along with it! Here are the major changes: Most views now use React and no longer flicker when updating; this is not the case yet for DataviewJS, which will be getting equivalent treament in the future. Dataview now caches metadata, so Dataview loads are very fast after the first time you open your vault. Dataview still needs to visit every file when you update the plugin version, so that should be the only times you experience slower load times. A brand new task view backend and query which allows you to filter per-task, rather than per-page! Check the documentation for details, but this broadly means WHERE statements now use task properties instead of page properties. Some additional metadata is now available for use - file.starred , file.lists , and more metadata in file.tasks . There have been some moderate documentation touch-ups to keep things up to date; I'm still working on a walkthrough for common Dataview usecases. This review also includes about ~30-40 bugfixes; some new bugs may arise due to internal changes, so please flag them if you encounter them.","title":"0.5.21"},{"location":"changelog/#0520-beta","text":"Slight fix to hopefully improve some strange reported cases of bad indexing at startup.","title":"0.5.20 (Beta)"},{"location":"changelog/#0519-beta","text":"Dataview now uses IndexedDB to cache file metadata, reducing startup time to virtually nothing if you've opened the vault before; if you have a small vault (<1000 notes), you may notice a slight improvement, but large vaults and mobile devices will notice a very significant performance improvement to \"first valid paint\". Some other performance parameters have been tuned to hopefully make the default experience better. A few small bugs related to rendering have also been squashed, including an issue with images being scaled wrongly.","title":"0.5.19 (Beta)"},{"location":"changelog/#0518-beta","text":"Tasks in task views now support alternative task status characters like '!' and '/'; thanks @ebullient. A few documentation nit fixes. Added DataArray#sortInPlace for a more efficient mutable sort for niche use cases.","title":"0.5.18 (Beta)"},{"location":"changelog/#0517-beta","text":"Improved behavior when clicking on tasks in the task view; will now properly scroll to the relevant line in long files! Fixed a bug with incorrect counts being displayed in task views. Added tags as a field available on task items, so you can now do things like TASK WHERE contains(tags, \"#tag\") .","title":"0.5.17 (Beta)"},{"location":"changelog/#0516-beta","text":"Dataview now tracks initialization and will report when all files have been indexed in the console; you can programmatically see this via dataview:index-ready , or by checking api.index.initialized .","title":"0.5.16 (Beta)"},{"location":"changelog/#0515-beta","text":"Add hover highlights to tables to make seeing rows a little easier. Tables and task lists now include counts of the number of results in the headers. Further improved task selection in the task view.","title":"0.5.15 (Beta)"},{"location":"changelog/#0514-beta","text":"Fix task highlighting when not grouping. Remove some spurious console logging. Slightly improve task highlighting behavior when clicking on a task.","title":"0.5.14 (Beta)"},{"location":"changelog/#0513-beta","text":"Several smaller bugfixes! Fix #997: Use the group by field name in the table name. Prevent tons of errors if you incorrectly set the inline query prefix.","title":"0.5.13 (Beta)"},{"location":"changelog/#0512-beta","text":"Improve error messages for queries somewhat and get rid of some ugly output.","title":"0.5.12 (Beta)"},{"location":"changelog/#0511-beta","text":"Add detection of tasks inside of block quotes, as well as correctly implement automatic checking and unchecking of these tasks.","title":"0.5.11 (Beta)"},{"location":"changelog/#0510-beta","text":"Adds the Dataview: Force Refresh Views Command (accessible via the Ctrl+P command view) to force current views to refresh immediately.","title":"0.5.10 (Beta)"},{"location":"changelog/#059-beta","text":"Another fix for due-date related emoji in tasks. I hate emoji.","title":"0.5.9 (Beta)"},{"location":"changelog/#058-beta","text":"Fix some issues with infinite loops of tasks due to bad Obsidian metadata (potentially due to being out of date?).","title":"0.5.8 (Beta)"},{"location":"changelog/#057-beta","text":"Fix issues with parsing '\ud83d\uddd3\ufe0f2021-08-29' due-date annotations on tasks, as well as an issue with properly extracting due/completed/completed times for use in queries.","title":"0.5.7 (Beta)"},{"location":"changelog/#056-beta","text":"Proper release of 0.5.5 plus one additional small improvement: Add duration * number and duration / number operations for manipulation durations numerically.","title":"0.5.6 (Beta)"},{"location":"changelog/#055-beta","text":"More small features: Fix issues with task sorting not doing anything. Sort away! Table headers can now be arbitrary markdown. So you can put things like links in your headers: `TABLE (1 + 2) AS \"[[File]]\". You can now specify the size of an image embed by providing WxH in it's display property: ![[image.png|50x50]] .","title":"0.5.5 (Beta)"},{"location":"changelog/#054-beta","text":"Improved image rendering for some link types, and adds the embed(link) and embed(link, false) options to convert links to/from their embedded equivalents.","title":"0.5.4 (Beta)"},{"location":"changelog/#053-beta","text":"Iterative beta which adds a few nice QoL features and fixes some more bugs: Internally swapped to a React-based renderer; this should not have a noticable perf or usability impact, but makes it easier for me to implement complex table/list behaviors. Naming your fields with AS \"Name\" is now optional; Dataview will infer the name from the expression automatically. For example, TABLE 8 + 4, 3 + 6 FROM ... is now a valid table expression, and the columns will be named 8 + 4 and 3 + 6 respectively. Some issues with array and object rendering were corrected. Error messages on empty dataview results were improved and now show up for all views. Inline images are now rendered correctly in Dataview tables and lists - no more hacky app://local/ schenanigans!","title":"0.5.3 (Beta)"},{"location":"changelog/#052-beta","text":"Fix #971: Objects now work properly inside DataviewQL evaluation.","title":"0.5.2 (Beta)"},{"location":"changelog/#051-beta","text":"Temporarily revert the new task metadata behavior: inline fields in sublists of tasks are added to the page, instead of the task. This behavior is not good, but is compatible with legacy usages of task metadata, which should uinbreak some existing queries. This behavior will be removed in the future behind a flag. Added the 'visual' field to tasks - if set, tasks render 'visual' instead of their regular text. Fixed DataArray#mutate() .","title":"0.5.1 (Beta)"},{"location":"changelog/#050-beta","text":"Re-release of broken release 0.4.23, now hopefully with fixes that make it work on (most) machines. I'll be doing beta releases for a little while until I can confirm the new version is stable; use BRAT (https://github.com/TfTHacker/obsidian42-brat) to easily track Dataview beta versions if you are interested in cutting edge features.","title":"0.5.0 (Beta)"},{"location":"changelog/#0425","text":"Fix #867: Create a container div per taskList to allow for multiple task views.","title":"0.4.25"},{"location":"changelog/#0424","text":"Re-release of 0.4.23f since Obsidian does not automatically update between non-semver versions.","title":"0.4.24"},{"location":"changelog/#0423f","text":"Remove some code which attempted to make tag queries case-insensitive; I'll reimplement this more generally later (it conflicts with existing queries which check tags via contains(file.tags, \"#Tag\") and similar).","title":"0.4.23f"},{"location":"changelog/#0423e","text":"More task bugfixes / improvements, and a fix that caused task metadata to be duplicated.","title":"0.4.23e"},{"location":"changelog/#0423d","text":"More inline field list parsing bug fixes. Hopefully we're back to a nice working order!","title":"0.4.23d"},{"location":"changelog/#0423c","text":"Bugfix which adds support for '1)' style lists, as well as a very annoying null issue due to JavaScript being a very sad, very sad language.","title":"0.4.23c"},{"location":"changelog/#0423b","text":"Bugfix for bad inlink/outlink computations; links were not being normalized properly so reverse lookups were not working.","title":"0.4.23b"},{"location":"changelog/#0423","text":"The Task Update! This release reworks how dataview handles tasks and list items so that they should be much more intuitive to use and interact with: Subtask Support : Queries now search over all list items, instead of only over root elements. This should make task filtering much more usable, especially if you tend to put tasks under other list items or care specifically about subtasks. Multiline Support : Dataview now understands multi-line tasks and renders/updates them correctly. Immediately Navigate to Task : The new task view, aside from looking a little cleaner than previous views, now immediately navigates to the task in it's original file on click and selects it. Grouping Support : For DataviewJS users, dv.taskList now supports grouping (as produced by groupBy and the new groupIn ) natively. For DataviewJS users, the task and list representation has changed: file.tasks (and the new file.lists ) contain every single task (including subtasks) in the file, instead of only the root elements. You can return to previous behavior by filtering out tasks with a non-null parent - i.e., file.tasks.where(task => !task.parent) . dv.taskList will intelligently deal with properly nesting and de-duplicating tasks, so just filter to the tasks you want to render and the API will do the rest. This release also includes general backend improvements as we prepare for live-editing in Dataview views, as well as several community-contributed API improvements: DataArray#groupIn : For grouping already grouped data, you can now use array.groupIn(v => ...) , which will group the innermost (original) data in the array instead of the top level groups. This allows for more easily grouping recursively, such as dv.pages().groupBy(page => page.file.folder).groupIn(page => page.title) producing a grouping of folders, then page titles. substring(string, start[, end]) : The last major missing string function is now available! Take slices of strings. Improved dv.el() and other HTML functions - thanks @vitaly. null and undefined entries sort at the end instead of the beginning by default; sorry to those whose code sorts wrong because of this, but it is a better default for most people's use cases. All links are now properly normalized to their full paths, fixing many link comparison edge cases in DataviewJS. Documentation additions for the new task functionality will be coming out in the next few days. The next release 0.4.24 is currently targeting expanded FROM query support, basic table view improvements, and general exporting functionality for Dataview. See you then!","title":"0.4.23"},{"location":"changelog/#0422","text":"The @pjeby update! This includes several performance improvements suggested by @pjeby to dramatically improve background Dataview performance as well as reduce some memory pressure. It also includes some minor bug-fixes and preliminary functionality: Target ES2018 for better Promise support Allow parsing shorthands in dv.date() . Add additional metadata to inline field rendering which can be styled. Cleanup events & workers on plugin uninstall, improving the Dataview uninstall/disable/reload experience. Add preliminary CALENDAR queries - rendering similar to the obsidian-calendar plugin, see the documentation! Dataview should perform much better on startup and when you have lots of tabs open - thanks again to @pjeby.","title":"0.4.22"},{"location":"changelog/#0421","text":"Bugfix release which primarily fixes issues that Dataview had with the live preview mode in upcoming Obsidian versions; Dataview live preview should now be functional. Also includes a number of smaller bugfixes. Fix #646: Add date(yesterday) to create a date 24 hours ago. Fix #618: Luxon is now available on the dataview API ( dv.luxon ). Fix #510: Add dv.duration() for parsing durations. Fix #647: All HTML functions in the DataviewJS API now return their rendered objects. Fix #652: Fix parsing of invalid dates. Fix #629: Fix block link parsing. Fix #601: Timezones are now rendered properly and parsed properly in Dataview dates. PR #637: Add meta(link) which allows you to access various metadata about a link itself. Various minor null safety fixes. Dataview now reports it's exact version and build time in logs.","title":"0.4.21"},{"location":"changelog/#0420","text":"Some feature work (mostly by other contributors) while I while away at section metadata. May also fix a few bugs! Fix #448: You can now use the \"Task Completion Tracking\" option to automatically add completion metadata to tasks which are checked/unchecked through Dataview. Thanks to @sheeley. Add a search bar to documentation. Thanks to @tzhou. Add new date expressions for the start of the week ( date(sow) ), and the end of the week ( date(eow) ). Thanks @Jeamee and @v_mujunma. Small minor bugfix / security releases may follow in the near future; otherwise, the next major release will include section and object metadata.","title":"0.4.20"},{"location":"changelog/#0419","text":"Bugfix release which corrects emoji parsing & localization issues. Add DataArray#into , which lets you index into objects without flattening. Renamed 'header' to 'section' in task metadata; 'header' will remain around for a few major releases to let people naturally migrate. Fix #487: You no longer need spaces around '*' in expressions. Fix #559: Fix unicode issues in variable canonicalization which was causing problems with non-Latin inline field keys.","title":"0.4.19"},{"location":"changelog/#duration-parsing","text":"You can now include multiple units in durations: dur(8 minutes, 4 seconds) or dur(2yr8mo12d) . You can separate durations by commas, or use the abbreviated syntax with/without spaces.","title":"Duration Parsing"},{"location":"changelog/#0418","text":"Bugfix release which fixes bad inline field highlighting if '[' and '(' are mixed on the same line in particular orders.","title":"0.4.18"},{"location":"changelog/#0417","text":"Minor feature release to patch up more implementation holes.","title":"0.4.17"},{"location":"changelog/#single-file-queries","text":"You can now query from a specific file (instead of just folders and tags) by specifying the full file path: TASK FROM \"dataview/Test\" ... This is primarily useful for task queries, but will soon be useful for section and object queries in the near future as well.","title":"Single File Queries"},{"location":"changelog/#better-inline-field-highlighting","text":"The CSS for inline field highlighting has been fixed and some compatibility issues improved, so it should work on all themes now instead of only a few.","title":"Better Inline Field Highlighting"},{"location":"changelog/#dvel","text":"DataviewJS now has dv.el() , which is like existing functions like dv.paragraph and dv.span but can create any HTML element type; for example: dv . el ( \"b\" , \"Text!\" ); dv . el ( \"i\" , 18 );","title":"dv.el()"},{"location":"changelog/#0416","text":"Small performance release which substantially reduces the impact Dataview has on vault loading times (by spreading out file loading). The Dataview Index is now also eagerly initialized, so plugin consumers of the API can immediately start using it instead of waiting for the dataview:api-ready event.","title":"0.4.16"},{"location":"changelog/#0415","text":"A simple fix for #537 which properly 'awaits' value rendering in dv.view() . Fixes issues with values rendering out of order.","title":"0.4.15"},{"location":"changelog/#0414","text":"Small bugfix release. Fixes inline field evaluation when using the new fancy highlighting. You can now configure whether task links should show up at the beginning or end of the task (or just disable them) in the \"Task Link Location\" setting. Most setting updates will immediately be applied to existing Dataviews.","title":"0.4.14"},{"location":"changelog/#0413","text":"Bugfix release which adds fancy rendering to inline-inline fields and includes a few bugfixes.","title":"0.4.13"},{"location":"changelog/#pretty-inline-fields","text":"Inline fields of the form [key:: value] will now be rendered with fancy new HTML! By default, they are rendered with both the key and value. You can only render the value using parenthesis instead: (key:: value) . You can disable this feature in the configuration. Full-line inline fields (that Dataview has supported for a long time) will gain similar rendering support soon; in the meanwhile, give the new syntax a try!","title":"Pretty Inline Fields"},{"location":"changelog/#task-linking","text":"Tasks now render with a link to the page/section that they are defined in, making GROUP BY and custom task editing easier to do: A Task. \ud83d\udd17 Another Task. \ud83d\udd17 Some Random Subtask. \ud83d\udd17 You can configure the symbol for the link or disable it alltogether.","title":"Task Linking"},{"location":"changelog/#improving-dataviewjs-posture","text":"I am currently actively looking into improving DataviewJS sandboxing and general security posture. As a first small step in this, I have made DataviewJS opt-in instead of opt-out, and added a separate control for Inline DataviewJS. You may need to re-enable it in your settings if you use it. More improvements and better JavaScript sandboxing will follow.","title":"Improving DataviewJS Posture"},{"location":"changelog/#0412-hotfix1","text":"Re-release of 0.4.12 that fixes an important indexing issue. Fix #505: Use completion instead of completed when setting task completion time. Fix #509: Add startswith / endswith string functions. Fix #488: Add padleft and padright , and string . Fix #506, #512: Fix date comparisons due to a bizarre date zone issue.","title":"0.4.12-hotfix1"},{"location":"changelog/#0412","text":"Bugfix release following up 0.4.11 which includes a few minor function additions. Fix #512: Strange zone issue causing dates to not be equal. Fix #506: Same as #512. Fix #488: Add padleft / padright functions. Fix #509: Add startswith and endswith functions. Fix #505: Correctly read completion dates for tasks from completion . This release also includes improved testing thanks to mocking Obsidian plugin APIs!","title":"0.4.12"},{"location":"changelog/#0411","text":"Fixes task behavior and adds \"truly inline\" fields!","title":"0.4.11"},{"location":"changelog/#improved-task-behavior","text":"Task queries are now much improved from their primitive foundations - you can now filter, sort, and group them! The FROM block is still page-based, sadly, though you can simply use WHERE instead if desired. For example, you can now access task fields like text , line , or completed : TASK WHERE contains(text, \"#tag\") WHERE !completed GROUP BY file.folder The full list of all available task metadata can be found here ; tasks include all the information needed to uniquely identify them, and automatically inherit all of the metadata from their parent file as well (so you can access file.name , for example). You can also annotate tasks with inline fields, as described in the section below. There is some additional UX work to be done - primarily on more easily allowing you to navigate to where the task is defined, as well as render tasks in views other than the TASK view. The semantics of how grouping works (to make it more intuitive/useful than it currently is) will likely also be revisited.","title":"Improved Task Behavior"},{"location":"changelog/#inline-inline-fields","text":"Early support for truly inline fields have been added, where you can add metadata in the middle of a sentence. It looks similar to existing inline field syntax, but with brackets or parenthesis: I would rate this a [rating:: 6]. It was (thoughts:: acceptable). Improved rendering for all inline fields is coming in an unpcoming update to improve the visual look of these inline fields.","title":"Inline Inline Fields"},{"location":"changelog/#issues","text":"Fix #496: Fix task SORT functionality to do something. Fix #492: Tasks now properly annotated with parent file information. Fix #498: Fix task checking/unchecking logic (which broke due to a change in the task regex...).","title":"Issues"},{"location":"changelog/#initial","text":"Start of the automatic changelog.","title":"Initial"},{"location":"friends/","text":"Friends of Dataview A list of plugins which may be helpful for Dataview related workflows: MetaEdit - Add or update yaml properties and Dataview fields easily Another non-exhaustive list of plugins which use Dataview for some of the heavy-lifting required for their features: Kanban - Create markdown-backed Kanban boards in Obsidian Breadcrumbs - Gives you a way to visualise a custom-built hierarchy in your Obsidian vault Supercharged Links - Allows you to style links in your Obsidian vault based on note metadata A full list can be found using GitHub's Dependents feature.","title":"Friends of Dataview"},{"location":"friends/#friends-of-dataview","text":"A list of plugins which may be helpful for Dataview related workflows: MetaEdit - Add or update yaml properties and Dataview fields easily Another non-exhaustive list of plugins which use Dataview for some of the heavy-lifting required for their features: Kanban - Create markdown-backed Kanban boards in Obsidian Breadcrumbs - Gives you a way to visualise a custom-built hierarchy in your Obsidian vault Supercharged Links - Allows you to style links in your Obsidian vault based on note metadata A full list can be found using GitHub's Dependents feature.","title":"Friends of Dataview"},{"location":"resources-and-support/","text":"Other Resources There is a bit of a learning curve to getting started with Dataview. This page is a collection of resources that will help you get started. Dataview gets new features and fixes fairly frequently so please account for these resources being slightly out of date. Feel free to contribute directly to this list, documentation, or even reach out to the authors of the original sources for updates. Resources The Obsidian Hub SkepticMystic's Introduction to Dataview supplemented by a textual guide YouTube videos SkepticMystic's aforementioned community talk Dataview Plugin: How To Use This Powerful Obsidian Plugin (With Examples) by Filipe Donadio Automate Your Vault With Dataview - How To Use Dataview in Obsidian by FromSergio How to use the Obsidian Dataview plugin by Nicole van der Hoeven Intro to Dataview Plugin - Obsidian Community Talk Example Vault @s-blu has very kindly put together a vault of example queries that you can use as a playground of sorts. Blog Posts Obsidian Dataview For Beginners: A checklist to help fix your dataview queries GitHub Discussion The GitHub repository has a fairly active Discussions Page with dozens of answered questions. Obsidian Forums The Obsidian Forums have a wealth of questions and answers and other interesting tidbits as well. Try searching the forums for an answer, especially if it seems like a beginner question. Discord The Obsidian Members Group Discord server has a #dataview channel. Once again, more likely than not, your question has been asked before so try searching the thread though it is known that Discord's search can be spotty. In case you don't find anything satisfactory, This is the closest you'll get to real-time support but there are no guarantees of instant replies. There are many helpful people though so don't be afraid to ask. Support Where do you go when you have questions? Here's what we recommend you try. Search GitHub Discussions and the Obsidian Forums for your question. Search through Discord for possible solutions. Depending on the complexity of the your question: If you need close to synchronous communication, use Discord. Note that we are a community of volunteers and there may be delays in responding. If you expect your problem needs time over multiple days and asynchronous communication, open a GitHub discussion. If you found a bug, please report it in the repo's issues .","title":"Resources and Support"},{"location":"resources-and-support/#other-resources","text":"There is a bit of a learning curve to getting started with Dataview. This page is a collection of resources that will help you get started. Dataview gets new features and fixes fairly frequently so please account for these resources being slightly out of date. Feel free to contribute directly to this list, documentation, or even reach out to the authors of the original sources for updates.","title":"Other Resources"},{"location":"resources-and-support/#resources","text":"","title":"Resources"},{"location":"resources-and-support/#the-obsidian-hub","text":"SkepticMystic's Introduction to Dataview supplemented by a textual guide","title":"The Obsidian Hub"},{"location":"resources-and-support/#youtube-videos","text":"SkepticMystic's aforementioned community talk Dataview Plugin: How To Use This Powerful Obsidian Plugin (With Examples) by Filipe Donadio Automate Your Vault With Dataview - How To Use Dataview in Obsidian by FromSergio How to use the Obsidian Dataview plugin by Nicole van der Hoeven Intro to Dataview Plugin - Obsidian Community Talk","title":"YouTube videos"},{"location":"resources-and-support/#example-vault","text":"@s-blu has very kindly put together a vault of example queries that you can use as a playground of sorts.","title":"Example Vault"},{"location":"resources-and-support/#blog-posts","text":"Obsidian Dataview For Beginners: A checklist to help fix your dataview queries","title":"Blog Posts"},{"location":"resources-and-support/#github-discussion","text":"The GitHub repository has a fairly active Discussions Page with dozens of answered questions.","title":"GitHub Discussion"},{"location":"resources-and-support/#obsidian-forums","text":"The Obsidian Forums have a wealth of questions and answers and other interesting tidbits as well. Try searching the forums for an answer, especially if it seems like a beginner question.","title":"Obsidian Forums"},{"location":"resources-and-support/#discord","text":"The Obsidian Members Group Discord server has a #dataview channel. Once again, more likely than not, your question has been asked before so try searching the thread though it is known that Discord's search can be spotty. In case you don't find anything satisfactory, This is the closest you'll get to real-time support but there are no guarantees of instant replies. There are many helpful people though so don't be afraid to ask.","title":"Discord"},{"location":"resources-and-support/#support","text":"Where do you go when you have questions? Here's what we recommend you try. Search GitHub Discussions and the Obsidian Forums for your question. Search through Discord for possible solutions. Depending on the complexity of the your question: If you need close to synchronous communication, use Discord. Note that we are a community of volunteers and there may be delays in responding. If you expect your problem needs time over multiple days and asynchronous communication, open a GitHub discussion. If you found a bug, please report it in the repo's issues .","title":"Support"},{"location":"annotation/add-metadata/","text":"Adding metadata to your pages To make information available in dataview queries, you need to store this information in fields . All fields you add to a page (a note in your vault) can be later accessed when writing dataview queries. You can add fields to a markdown page in three different ways. Frontmatter Frontmatter is a common Markdown extension which allows for YAML metadata to be added to the top of a page. All YAML fields will be available as Dataview fields: --- alias : \"document\" last-reviewed : 2021-08-17 thoughts : rating : 8 reviewable : false --- Inline Fields For those wanting a more natural-looking annotation, Dataview supports \"inline\" fields, which offer a simple Key:: Value syntax that you can embed directly in your file: # Markdown Page Basic Field:: Value **Bold Field** :: Nice! If you want to embed metadata inside sentences, or multiple fields on the same line, you can use the bracket syntax: I would rate this a [rating:: 9]! It was [mood:: acceptable]. There is also the alternative parenthesis syntax, which is functionally similar to brackets but hides the key when rendered in Reader mode: This will not show the (very long key:: key). Implicit Dataview annotates pages and tasks with a large amount of metadata automatically, like the day the file was created ( file.cday ), any associated dates ( file.day ), links in the file ( file.outlinks ), tags ( file.tags ), and so on.","title":"Adding metadata"},{"location":"annotation/add-metadata/#adding-metadata-to-your-pages","text":"To make information available in dataview queries, you need to store this information in fields . All fields you add to a page (a note in your vault) can be later accessed when writing dataview queries. You can add fields to a markdown page in three different ways.","title":"Adding metadata to your pages"},{"location":"annotation/add-metadata/#frontmatter","text":"Frontmatter is a common Markdown extension which allows for YAML metadata to be added to the top of a page. All YAML fields will be available as Dataview fields: --- alias : \"document\" last-reviewed : 2021-08-17 thoughts : rating : 8 reviewable : false ---","title":"Frontmatter"},{"location":"annotation/add-metadata/#inline-fields","text":"For those wanting a more natural-looking annotation, Dataview supports \"inline\" fields, which offer a simple Key:: Value syntax that you can embed directly in your file: # Markdown Page Basic Field:: Value **Bold Field** :: Nice! If you want to embed metadata inside sentences, or multiple fields on the same line, you can use the bracket syntax: I would rate this a [rating:: 9]! It was [mood:: acceptable]. There is also the alternative parenthesis syntax, which is functionally similar to brackets but hides the key when rendered in Reader mode: This will not show the (very long key:: key).","title":"Inline Fields"},{"location":"annotation/add-metadata/#implicit","text":"Dataview annotates pages and tasks with a large amount of metadata automatically, like the day the file was created ( file.cday ), any associated dates ( file.day ), links in the file ( file.outlinks ), tags ( file.tags ), and so on.","title":"Implicit"},{"location":"annotation/metadata-pages/","text":"Metadata on pages You can add fields (queryable information) to a markdown page (a note) in three different ways - via Frontmatter, Inline fields and Implicit fields. Read more about how to add metadata . A simple Markdown page which includes both user-defined ways to add metadata: --- duration: 4 hours reviewed: false --- # Movie X **Thoughts** :: It was decent. **Rating** :: 6 [mood:: okay] | [length:: 2 hours] Implicit Fields Dataview automatically adds a large amount of metadata to each page: file.name : The file title (a string). file.folder : The path of the folder this file belongs to. file.path : The full file path (a string). file.ext : The extension of the file type; generally '.md' (a string). file.link : A link to the file (a link). file.size : The size (in bytes) of the file (a number). file.ctime : The date that the file was created (a date + time). file.cday : The date that the file was created (just a date). file.mtime : The date that the file was last modified (a date + time). file.mday : The date that the file was last modified (just a date). file.tags : An array of all unique tags in the note. Subtags are broken down by each level, so #Tag/1/A will be stored in the array as [#Tag, #Tag/1, #Tag/1/A] . file.etags : An array of all explicit tags in the note; unlike file.tags , does not include subtags. file.inlinks : An array of all incoming links to this file. file.outlinks : An array of all outgoing links from this file. file.aliases : An array of all aliases for the note. file.tasks : An array of all tasks (I.e., - [ ] blah blah blah ) in this file. file.lists : An array of all list elements in the file (including tasks); these elements are effectively tasks and can be rendered in task views. file.frontmatter : Contains the raw values of all frontmatter; mainly useful for checking raw frontmatter values or for dynamically listing frontmatter keys. If the file has a date inside its title (of form yyyy-mm-dd or yyyymmdd ), or has a Date field/inline field, it also has the following attributes: file.day : An explicit date associated with the file. If you use the Obsidian default \"Starred Files\" plugin, the following metadata is also available: file.starred : If this file has been starred by the \"stars\" Obsidian plugin.","title":"Metadata on pages"},{"location":"annotation/metadata-pages/#metadata-on-pages","text":"You can add fields (queryable information) to a markdown page (a note) in three different ways - via Frontmatter, Inline fields and Implicit fields. Read more about how to add metadata . A simple Markdown page which includes both user-defined ways to add metadata: --- duration: 4 hours reviewed: false --- # Movie X **Thoughts** :: It was decent. **Rating** :: 6 [mood:: okay] | [length:: 2 hours]","title":"Metadata on pages"},{"location":"annotation/metadata-pages/#implicit-fields","text":"Dataview automatically adds a large amount of metadata to each page: file.name : The file title (a string). file.folder : The path of the folder this file belongs to. file.path : The full file path (a string). file.ext : The extension of the file type; generally '.md' (a string). file.link : A link to the file (a link). file.size : The size (in bytes) of the file (a number). file.ctime : The date that the file was created (a date + time). file.cday : The date that the file was created (just a date). file.mtime : The date that the file was last modified (a date + time). file.mday : The date that the file was last modified (just a date). file.tags : An array of all unique tags in the note. Subtags are broken down by each level, so #Tag/1/A will be stored in the array as [#Tag, #Tag/1, #Tag/1/A] . file.etags : An array of all explicit tags in the note; unlike file.tags , does not include subtags. file.inlinks : An array of all incoming links to this file. file.outlinks : An array of all outgoing links from this file. file.aliases : An array of all aliases for the note. file.tasks : An array of all tasks (I.e., - [ ] blah blah blah ) in this file. file.lists : An array of all list elements in the file (including tasks); these elements are effectively tasks and can be rendered in task views. file.frontmatter : Contains the raw values of all frontmatter; mainly useful for checking raw frontmatter values or for dynamically listing frontmatter keys. If the file has a date inside its title (of form yyyy-mm-dd or yyyymmdd ), or has a Date field/inline field, it also has the following attributes: file.day : An explicit date associated with the file. If you use the Obsidian default \"Starred Files\" plugin, the following metadata is also available: file.starred : If this file has been starred by the \"stars\" Obsidian plugin.","title":"Implicit Fields"},{"location":"annotation/metadata-tasks/","text":"Metadata on tasks Just like pages, you can also add fields on task level to bind it to a specific task as context. You can also annotate your tasks (I.e., lines of the form - [ ] blah blah blah ) with metadata using inline field syntax : - [ ] Hello, this is some [metadata:: value]! - [X] I finished this on [completion::2021-08-15]. Field Shorthands For supporting \"common use cases\", Dataview understands a few shorthands for common data you may want to annotate task with: Syntax Due Date: \ud83d\uddd3\ufe0fYYYY-MM-DD Completed Date: \u2705YYYY-MM-DD Created Date: \u2795YYYY-MM-DD Start Date: \ud83d\udeebYYYY-MM-DD Scheduled Date: \u23f3YYYY-MM-DD Example Due this saturday \ud83d\uddd3\ufe0f2021-08-29 Completed last saturday \u27052021-08-22 I made this on \u27951990-06-14 Task I can start this weekend \ud83d\udeeb2021-08-29 Task I finished ahead of schedule \u23f32021-08-29 \u27052021-08-22 Note that, if you do not like emojis, you can still annotate these fields textually ( [due:: ] , [created:: ] , [completion:: ] , [start:: ] , [scheduled:: ] ). Implicit Fields As with pages, Dataview adds a number of implicit fields to each task: Tasks inherit all fields from their parent page - so if you have a rating field in your page, you can also access it on your task. status : The completion status of this task, as determined by the character inside the [ ] brackets. Generally a space \" \" for incomplete tasks and an X \"X\" for complete tasks, but allows for plugins which support alternative task statuses. checked : Whether or not this task has been checked in any way (i.e., it's status is not incomplete/empty). completed : Whether or not this specific task has been completed; this does not consider the completion/non-completion of any child tasks. A task is explicitly considered \"completed\" if it has been marked with an 'X'. fullyCompleted : Whether or not this task and all of its subtasks are completed. text : The text of this task. line : The line this task shows up on. lineCount : The number of Markdown lines that this task takes up. path : The full path of the file this task is in. section : A link to the section this task is contained in. tags : Any tags inside of the text task. outlinks : Any links defined in this task. link : A link to the closest linkable block near this task; useful for making links which go to the task. children : Any subtasks or sublists of this task. task : If true, this is a task; otherwise, it is a regular list element. completion : The date a task was completed; set by [completion:: ...] or shorthand syntax . due : The date a task is due, if it has one. Set by [due:: ...] or shorthand syntax . created : The date a task was created; set by [created:: ...] or shorthand syntax . start : The date a task can be started; set by [start:: ...] or shorthand syntax . scheduled : The date a task is scheduled to work on; set by [scheduled:: ...] or shorthand syntax . annotated : True if the task has any custom annotations, and false otherwise. parent : The line number of the task above this task, if present; will be null if this is a root-level task. blockId : The block ID of this task / list element, if one has been defined with the ^blockId syntax; otherwise null.","title":"Metadata on tasks"},{"location":"annotation/metadata-tasks/#metadata-on-tasks","text":"Just like pages, you can also add fields on task level to bind it to a specific task as context. You can also annotate your tasks (I.e., lines of the form - [ ] blah blah blah ) with metadata using inline field syntax : - [ ] Hello, this is some [metadata:: value]! - [X] I finished this on [completion::2021-08-15].","title":"Metadata on tasks"},{"location":"annotation/metadata-tasks/#field-shorthands","text":"For supporting \"common use cases\", Dataview understands a few shorthands for common data you may want to annotate task with: Syntax Due Date: \ud83d\uddd3\ufe0fYYYY-MM-DD Completed Date: \u2705YYYY-MM-DD Created Date: \u2795YYYY-MM-DD Start Date: \ud83d\udeebYYYY-MM-DD Scheduled Date: \u23f3YYYY-MM-DD Example Due this saturday \ud83d\uddd3\ufe0f2021-08-29 Completed last saturday \u27052021-08-22 I made this on \u27951990-06-14 Task I can start this weekend \ud83d\udeeb2021-08-29 Task I finished ahead of schedule \u23f32021-08-29 \u27052021-08-22 Note that, if you do not like emojis, you can still annotate these fields textually ( [due:: ] , [created:: ] , [completion:: ] , [start:: ] , [scheduled:: ] ).","title":"Field Shorthands"},{"location":"annotation/metadata-tasks/#implicit-fields","text":"As with pages, Dataview adds a number of implicit fields to each task: Tasks inherit all fields from their parent page - so if you have a rating field in your page, you can also access it on your task. status : The completion status of this task, as determined by the character inside the [ ] brackets. Generally a space \" \" for incomplete tasks and an X \"X\" for complete tasks, but allows for plugins which support alternative task statuses. checked : Whether or not this task has been checked in any way (i.e., it's status is not incomplete/empty). completed : Whether or not this specific task has been completed; this does not consider the completion/non-completion of any child tasks. A task is explicitly considered \"completed\" if it has been marked with an 'X'. fullyCompleted : Whether or not this task and all of its subtasks are completed. text : The text of this task. line : The line this task shows up on. lineCount : The number of Markdown lines that this task takes up. path : The full path of the file this task is in. section : A link to the section this task is contained in. tags : Any tags inside of the text task. outlinks : Any links defined in this task. link : A link to the closest linkable block near this task; useful for making links which go to the task. children : Any subtasks or sublists of this task. task : If true, this is a task; otherwise, it is a regular list element. completion : The date a task was completed; set by [completion:: ...] or shorthand syntax . due : The date a task is due, if it has one. Set by [due:: ...] or shorthand syntax . created : The date a task was created; set by [created:: ...] or shorthand syntax . start : The date a task can be started; set by [start:: ...] or shorthand syntax . scheduled : The date a task is scheduled to work on; set by [scheduled:: ...] or shorthand syntax . annotated : True if the task has any custom annotations, and false otherwise. parent : The line number of the task above this task, if present; will be null if this is a root-level task. blockId : The block ID of this task / list element, if one has been defined with the ^blockId syntax; otherwise null.","title":"Implicit Fields"},{"location":"annotation/types-of-metadata/","text":"Data Annotation Dataview is a data index first and foremost, so it supports relatively rich ways of adding metadata to your knowledge base. Dataview tracks information at the markdown page and markdown task levels, where each page/task can have an arbitrary amount of complex (numbers, objects, lists) fields associated with it. Each field is a named value with a certain type (like \"number\" or \"text\"). Read more about how to create fields and meta data on your pages and tasks on metadata on pages and metadata on tasks . Field Types All fields in dataview have a type , which determines how dataview will render, sort, and operate on that field. Dataview understands several distinct field types to cover common use cases: Text : The default catch-all. If a field doesn't match a more specific type, it is just plain text. Example:: This is some normal text. Number : Numbers like '6' and '3.6'. Example:: 6 Example:: 2.4 Example:: -80 Boolean : true/false, as the programming concept. Example:: true Example:: false Date : ISO8601 dates of the general form YYYY-MM[-DDTHH:mm:ss.nnn+ZZ] . Everything after the month is optional. Example:: 2021-04-18 Example:: 2021-04-18T04:19:35.000 Example:: 2021-04-18T04:19:35.000+06:30 Duration : Durations of the form <time> <unit> , like 6 hours or 4 minutes . Common english abbreviations like 6hrs or 2m are accepted. You can specify multiple units using an optional comma separator: 6 hours, 4 minutes or 6hr4min . Example:: 7 hours Example:: 4min Example:: 16 days Example:: 9 years, 8 months, 4 days, 16 hours, 2 minutes Example:: 9 yrs 8 min Link : Plain Obsidian links like [[Page]] or [[Page|Page Display]] . If you reference a link in frontmatter, you need to quote it, as so: key: \"[[Link]]\" . This is default Obsidian-supported behavior. Example:: [[A Page]] Example:: [[Some Other Page|Render Text]] List : Lists of other dataview fields. In YAML, these are defined as normal YAML lists; for inline fields, they are just comma-separated lists. Example:: 1, 2, 3 Example:: \"yes\", \"or\", \"no\" Object : A map of name to dataview field. These can only be defined in YAML frontmatter, using the normal YAML object syntax: field : value1 : 1 value2 : 2 ...","title":"Types of Data"},{"location":"annotation/types-of-metadata/#data-annotation","text":"Dataview is a data index first and foremost, so it supports relatively rich ways of adding metadata to your knowledge base. Dataview tracks information at the markdown page and markdown task levels, where each page/task can have an arbitrary amount of complex (numbers, objects, lists) fields associated with it. Each field is a named value with a certain type (like \"number\" or \"text\"). Read more about how to create fields and meta data on your pages and tasks on metadata on pages and metadata on tasks .","title":"Data Annotation"},{"location":"annotation/types-of-metadata/#field-types","text":"All fields in dataview have a type , which determines how dataview will render, sort, and operate on that field. Dataview understands several distinct field types to cover common use cases: Text : The default catch-all. If a field doesn't match a more specific type, it is just plain text. Example:: This is some normal text. Number : Numbers like '6' and '3.6'. Example:: 6 Example:: 2.4 Example:: -80 Boolean : true/false, as the programming concept. Example:: true Example:: false Date : ISO8601 dates of the general form YYYY-MM[-DDTHH:mm:ss.nnn+ZZ] . Everything after the month is optional. Example:: 2021-04-18 Example:: 2021-04-18T04:19:35.000 Example:: 2021-04-18T04:19:35.000+06:30 Duration : Durations of the form <time> <unit> , like 6 hours or 4 minutes . Common english abbreviations like 6hrs or 2m are accepted. You can specify multiple units using an optional comma separator: 6 hours, 4 minutes or 6hr4min . Example:: 7 hours Example:: 4min Example:: 16 days Example:: 9 years, 8 months, 4 days, 16 hours, 2 minutes Example:: 9 yrs 8 min Link : Plain Obsidian links like [[Page]] or [[Page|Page Display]] . If you reference a link in frontmatter, you need to quote it, as so: key: \"[[Link]]\" . This is default Obsidian-supported behavior. Example:: [[A Page]] Example:: [[Some Other Page|Render Text]] List : Lists of other dataview fields. In YAML, these are defined as normal YAML lists; for inline fields, they are just comma-separated lists. Example:: 1, 2, 3 Example:: \"yes\", \"or\", \"no\" Object : A map of name to dataview field. These can only be defined in YAML frontmatter, using the normal YAML object syntax: field : value1 : 1 value2 : 2 ...","title":"Field Types"},{"location":"api/code-examples/","text":"Codeblock Examples Grouped Books Group your books by genre, then create a table for each sorted by rating via a straightforward usage of the dataview rendering API: for ( let group of dv . pages ( \"#book\" ). groupBy ( p => p . genre )) { dv . header ( 3 , group . key ); dv . table ([ \"Name\" , \"Time Read\" , \"Rating\" ], group . rows . sort ( k => k . rating , 'desc' ) . map ( k => [ k . file . link , k [ \"time-read\" ], k . rating ])) } Find All Direct And Indirectly Linked Pages Use a simple set + stack depth first search to find all notes linked to the current note, or a note of your choosing: let page = dv . current (). file . path ; let pages = new Set (); let stack = [ page ]; while ( stack . length > 0 ) { let elem = stack . pop (); let meta = dv . page ( elem ); if ( ! meta ) continue ; for ( let inlink of meta . file . inlinks . concat ( meta . file . outlinks ). array ()) { console . log ( inlink ); if ( pages . has ( inlink . path )) continue ; pages . add ( inlink . path ); stack . push ( inlink . path ); } } // Data is now the file metadata for every page that directly OR indirectly links to the current page. let data = dv . array ( Array . from ( pages )). map ( p => dv . page ( p ));","title":"Codeblock Examples"},{"location":"api/code-examples/#codeblock-examples","text":"","title":"Codeblock Examples"},{"location":"api/code-examples/#grouped-books","text":"Group your books by genre, then create a table for each sorted by rating via a straightforward usage of the dataview rendering API: for ( let group of dv . pages ( \"#book\" ). groupBy ( p => p . genre )) { dv . header ( 3 , group . key ); dv . table ([ \"Name\" , \"Time Read\" , \"Rating\" ], group . rows . sort ( k => k . rating , 'desc' ) . map ( k => [ k . file . link , k [ \"time-read\" ], k . rating ])) }","title":"Grouped Books"},{"location":"api/code-examples/#find-all-direct-and-indirectly-linked-pages","text":"Use a simple set + stack depth first search to find all notes linked to the current note, or a note of your choosing: let page = dv . current (). file . path ; let pages = new Set (); let stack = [ page ]; while ( stack . length > 0 ) { let elem = stack . pop (); let meta = dv . page ( elem ); if ( ! meta ) continue ; for ( let inlink of meta . file . inlinks . concat ( meta . file . outlinks ). array ()) { console . log ( inlink ); if ( pages . has ( inlink . path )) continue ; pages . add ( inlink . path ); stack . push ( inlink . path ); } } // Data is now the file metadata for every page that directly OR indirectly links to the current page. let data = dv . array ( Array . from ( pages )). map ( p => dv . page ( p ));","title":"Find All Direct And Indirectly Linked Pages"},{"location":"api/code-reference/","text":"Codeblock Reference Dataview JavaScript Codeblocks are created using the dataviewjs language specification for a codeblock: ```dataviewjs dv.table([], ...) ``` The API is available through the implicitly provided dv (or dataview ) variable, through which you can query for information, render HTML, and configure the view. Asynchronous API calls are marked with \u231b . Query Query methods allow you to query the Dataview index for page metadata; to render this data, use the methods in the render section . dv.current() Get page information (via dv.page() ) for the page the script is currently executing on. dv.pages(source) Take a single string argument, source , which is the same form as a query language source . Return a data array of page objects, which are plain objects with all of the page fields as values. dv . pages () => all pages in your vault dv . pages ( \"#books\" ) => all pages with tag 'books' dv . pages ( '\"folder\"' ) => all pages from folder \"folder\" dv . pages ( \"#yes or -#no\" ) => all pages with tag # yes , or which DON 'T have tag #no dv.pages(' \"folder\" or # tag ' ) => all pages with tag # tag , or from folder \"folder\" Note that folders need to be double-quoted inside the string (i.e., dv.pages(\"folder\") does not work, but dv.pages('\"folder\"') does) - this is to exactly match how sources are written in the query language. dv.pagePaths(source) As with dv.pages , but just returns a data array of paths of pages that match the given source. dv . pagePaths ( \"#books\" ) => the paths of pages with tag 'books' dv.page(path) Map a simple path or link to the full page object, which includes all of the pages fields. Automatically does link resolution, and will figure out the extension automatically if not present. dv . page ( \"Index\" ) => The page object for /Index dv . page ( \"books/The Raisin.md\" ) => The page object for /books/The Raisin.md Render dv.el(element, text) Render arbitrary text in the given html element. dv . el ( \"b\" , \"This is some bold text\" ); You can specify custom classes to add to the element via cls , and additional attributes via attr : dv . el ( \"b\" , \"This is some text\" , { cls : \"dataview dataview-class\" , attr : { alt : \"Nice!\" } }); dv.header(level, text) Render a header of level 1 - 6 with the given text. dv . header ( 1 , \"Big!\" ); dv . header ( 6 , \"Tiny\" ); dv.paragraph(text) Render arbitrary text in a paragraph. dv . paragraph ( \"This is some text\" ); dv.span(text) Render arbitrary text in a span (no padding above/below, unlike a paragraph). dv . span ( \"This is some text\" ); dv.execute(source) Execute an arbitrary dataview query and embed the view into the current page. dv . execute ( \"LIST FROM #tag\" ); dv . execute ( \"TABLE field1, field2 FROM #thing\" ); dv.executeJs(source) Execute an arbitrary DataviewJS query and embed the view into the current page. dv . executeJs ( \"dv.list([1, 2, 3])\" ); dv.view(path, input) Complex function which allows for custom views. Will attempt to load a JavaScript file at the given path, passing it dv and input and allowing it to execute. This allows for you to re-use custom view code across multiple pages. Note that this is an asynchronous function since it involves file I/O - make sure to await the result! await dv . view ( \"views/custom\" , { arg1 : ..., arg2 : ... }); If you want to also include custom CSS in your view, you can instead pass a path to a folder containing view.js and view.css ; the CSS will be added to the view automatically: views/custom -> view.js -> view.css View scripts have access to the dv object (the API object), and an input object which is exactly whatever the second argument of dv.view() was. Dataviews dv.list(elements) Render a dataview list of elements; accept both vanilla arrays and data arrays. dv . list ([ 1 , 2 , 3 ]) => list of 1 , 2 , 3 dv . list ( dv . pages (). file . name ) => list of all file names dv . list ( dv . pages (). file . link ) => list of all file links dv . list ( dv . pages ( \"#book\" ). where ( p => p . rating > 7 )) => list of all books with rating greater than 7 dv.taskList(tasks, groupByFile) Render a dataview list of Task objects, as obtained by page.file.tasks . Only the first argument is required; if the second argument groupByFile is provided (and is true), then tasks will be grouped by the file they come from automatically. // List all tasks from pages marked '#project' dv . taskList ( dv . pages ( \"#project\" ). file . tasks ) // List all *uncompleted* tasks from pages marked #project dv . taskList ( dv . pages ( \"#project\" ). file . tasks . where ( t => ! t . completed )) // List all tasks tagged with '#tag' from pages marked #project dv . taskList ( dv . pages ( \"#project\" ). file . tasks . where ( t => t . text . includes ( \"#tag\" ))) dv.table(headers, elements) Render a dataview table with the given list of headers and 2D array of elements. // Render a simple table of book info sorted by rating. dv . table ([ \"File\" , \"Genre\" , \"Time Read\" , \"Rating\" ], dv . pages ( \"#book\" ) . sort ( b => b . rating ) . map ( b => [ b . file . link , b . genre , b [ \"time-read\" ], b . rating ])) Markdown Dataviews Functions which render to plain Markdown strings which you can then render or manipulate as desired. dv.markdownTable(headers, values) Equivalent to dv.table() , which renders a table with the given list of headers and 2D array of elements, but returns plain Markdown. // Render a simple table of book info sorted by rating. const table = dv . markdownTable ([ \"File\" , \"Genre\" , \"Time Read\" , \"Rating\" ], dv . pages ( \"#book\" ) . sort ( b => b . rating ) . map ( b => [ b . file . link , b . genre , b [ \"time-read\" ], b . rating ])) dv . paragraph ( table ); dv.markdownList(values) Equivalent to dv.list() , which renders a list of the given elements, but returns plain Markdown. const markdown = dv . markdownList ([ 1 , 2 , 3 ]); dv . paragraph ( markdown ); dv.markdownTaskList(tasks) Equivalent to dv.taskList() , which renders a task list, but returns plain Markdown. const markdown = dv . markdownTaskList ( dv . pages ( \"#project\" ). file . tasks ); dv . paragraph ( markdown ); Utility dv.array(value) Convert a given value or array into a Dataview data array . If the value is already a data array, returns it unchanged. dv . array ([ 1 , 2 , 3 ]) => dataview data array [ 1 , 2 , 3 ] dv.isArray(value) Returns true if the given value is an array or dataview array. dv . isArray ( dv . array ([ 1 , 2 , 3 ])) => true dv . isArray ([ 1 , 2 , 3 ]) => true dv . isArray ({ x : 1 }) => false dv.fileLink(path, [embed?], [display-name]) Converts a textual path into a Dataview Link object; you can optionally also specify if the link is embedded as well as it's display name. dv . fileLink ( \"2021-08-08\" ) => link to file named \"2021-08-08\" dv . fileLink ( \"book/The Raisin\" , true ) => embed link to \"The Raisin\" dv . fileLink ( \"Test\" , false , \"Test File\" ) => link to file \"Test\" with display name \"Test File\" dv.sectionLink(path, section, [embed?], [display?]) Converts a textual path + section name into a Dataview Link object; you can optionally also specify if the link is embedded and it's display name. dv . sectionLink ( \"Index\" , \"Books\" ) => [[ Index # Books ]] dv . sectionLink ( \"Index\" , \"Books\" , false , \"My Books\" ) => [[ Index # Books | My Books ]] dv.blockLink(path, blockId, [embed?], [display?]) Converts a textual path + block ID into a Dataview Link object; you can optionally also specify if the link is embedded and it's display name. dv . blockLink ( \"Notes\" , \"12gdhjg3\" ) => [[ Index # ^ 12 gdhjg3 ]] dv.date(text) Coerce text and links to luxon DateTime ; if provided with a DateTime , return it unchanged. dv . date ( \"2021-08-08\" ) => DateTime for August 8 th , 2021 dv . date ( dv . fileLink ( \"2021-08-07\" )) => dateTime for August 8 th , 2021 dv.duration(text) Coerce text to a luxon Duration ; uses the same parsing rules as Dataview duration types. dv . duration ( \"8 minutes\" ) => Duration { 8 minutes } dv . duration ( \"9 hours, 2 minutes, 3 seconds\" ) => Duration { 9 hours , 2 minutes , 3 seconds } dv.compare(a, b) Compare two arbitrary JavaScript values according to dataview's default comparison rules; useful if you are writing a custom comparator and want to fall back to the default behavior. Returns a negative value if a < b , 0 if a = b , and a positive value if a > b . dv . compare ( 1 , 2 ) = - 1 dv . compare ( \"yes\" , \"no\" ) = 1 dv . compare ({ what : 0 }, { what : 0 }) = 0 dv.equal(a, b) Compare two arbitrary JavaScript values and return true if they are equal according to Dataview's default comparison rules. dv . equal ( 1 , 2 ) = false dv . equal ( 1 , 1 ) = true dv.clone(value) Deep clone any Dataview value, including dates, arrays, and links. dv . clone ( 1 ) = 1 dv . clone ({ a : 1 }) = { a : 1 } dv.parse(value) Parse an arbitrary string object into a complex Dataview type (mainly supporting links, dates, and durations). dv . parse ( \"[[A]]\" ) = Link { path : A } dv . parse ( \"2020-08-14\" ) = DateTime { 2020 - 08 - 14 } dv . parse ( \"9 seconds\" ) = Duration { 9 seconds } File I/O These utility methods are all contained in the dv.io sub-API, and are all asynchronous (marked by \u231b). \u231b dv.io.csv(path, [origin-file]) Load a CSV from the given path (a link or string). Relative paths will be resolved relative to the optional origin file (defaulting to the current file if not provided). Return a dataview array, each element containing an object of the CSV values; if the file does not exist, return undefined . await dv . io . csv ( \"hello.csv\" ) => [{ column1 : ..., column2 : ...}, ...] \u231b dv.io.load(path, [origin-file]) Load the contents of the given path (a link or string) asynchronously. Relative paths will be resolved relative to the optional origin file (defaulting to the current file if not provided). Returns the string contents of the file, or undefined if the file does not exist. await dv . io . load ( \"File\" ) => \"# File\\nThis is an example file...\" dv.io.normalize(path, [origin-file]) Convert a relative link or path into an absolute path. If origin-file is provided, then the resolution is doing as if you were resolving the link from that file; if not, the path is resolved relative to the current file. dv . io . normalize ( \"Test\" ) => \"dataview/test/Test.md\" , if inside \"dataview/test\" dv . io . normalize ( \"Test\" , \"dataview/test2/Index.md\" ) => \"dataview/test2/Test.md\" , irrespective of the current file Query Evaluation \u231b dv.query(source, [file, settings]) Execute a Dataview query and return the results as a structured return. The return type of this function varies by the query type being executed, though will always be an object with a type denoting the return type. This version of query returns a result type - you may want tryQuery , which instead throws an error on failed query execution. await dv . query ( \"LIST FROM #tag\" ) => Success { type : \"list\" , values : [ value1 , value2 , ...] } await dv . query ( `TABLE WITHOUT ID file.name, value FROM \"path\"` ) => Success { type : \"table\" , headers : [ \"file.name\" , \"value\" ], values : [[ \"A\" , 1 ], [ \"B\" , 2 ]] } await dv . query ( \"TASK WHERE due\" ) => Success { type : \"task\" , values : [ task1 , task2 , ...]} dv.query accepts two additional, optional arguments: 1. file : The file path to resolve the query from (in case of references to this ). Defaults to the current file. 2. settings : Execution settings for running the query. This is largely an advanced use case (where I recommend you directly check the API implementation to see all available options). \u231b dv.tryQuery(source, [file, settings]) Exactly the same as dv.query , but more convienent in short scripts as execution failures will be raised as JavaScript exceptions instead of a result type. \u231b dv.queryMarkdown(source, [file], [settings]) Equivalent to dv.query() , but returns rendered Markdown. await dv . queryMarkdown ( \"LIST FROM #tag\" ) => Success { \"- [[Page 1]]\\n- [[Page 2]]\" } \u231b dv.tryQueryMarkdown(source, [file], [settings]) Exactly the same as dv.queryMarkdown() , but throws an error on parse failure. dv.tryEvaluate(expression, [context]) Evaluate an arbitrary dataview expression (like 2 + 2 or link(\"text\") or x * 9 ); throws an Error on parse or evaluation failure. this is an always-available implicit variable which refers to the current file. dv . tryEvaluate ( \"2 + 2\" ) => 4 dv . tryEvaluate ( \"x + 2\" , { x : 3 }) => 5 dv . tryEvaluate ( \"length(this.file.tasks)\" ) => number of tasks in the current file dv.evaluate(expression, [context]) Evaluate an arbitrary dataview expression (like 2 + 2 or link(\"text\") or x * 9 ), returning a Result object of the result. You can unwrap the result type by checking result.successful (and then fetching either result.value or result.error ). If you want a simpler API that throws an error on a failed evaluation, use dv.tryEvaluate . dv . evaluate ( \"2 + 2\" ) => Successful { value : 4 } dv . evaluate ( \"2 +\" ) => Failure { error : \"Failed to parse ... \" }","title":"Codeblock Reference"},{"location":"api/code-reference/#codeblock-reference","text":"Dataview JavaScript Codeblocks are created using the dataviewjs language specification for a codeblock: ```dataviewjs dv.table([], ...) ``` The API is available through the implicitly provided dv (or dataview ) variable, through which you can query for information, render HTML, and configure the view. Asynchronous API calls are marked with \u231b .","title":"Codeblock Reference"},{"location":"api/code-reference/#query","text":"Query methods allow you to query the Dataview index for page metadata; to render this data, use the methods in the render section .","title":"Query"},{"location":"api/code-reference/#dvcurrent","text":"Get page information (via dv.page() ) for the page the script is currently executing on.","title":"dv.current()"},{"location":"api/code-reference/#dvpagessource","text":"Take a single string argument, source , which is the same form as a query language source . Return a data array of page objects, which are plain objects with all of the page fields as values. dv . pages () => all pages in your vault dv . pages ( \"#books\" ) => all pages with tag 'books' dv . pages ( '\"folder\"' ) => all pages from folder \"folder\" dv . pages ( \"#yes or -#no\" ) => all pages with tag # yes , or which DON 'T have tag #no dv.pages(' \"folder\" or # tag ' ) => all pages with tag # tag , or from folder \"folder\" Note that folders need to be double-quoted inside the string (i.e., dv.pages(\"folder\") does not work, but dv.pages('\"folder\"') does) - this is to exactly match how sources are written in the query language.","title":"dv.pages(source)"},{"location":"api/code-reference/#dvpagepathssource","text":"As with dv.pages , but just returns a data array of paths of pages that match the given source. dv . pagePaths ( \"#books\" ) => the paths of pages with tag 'books'","title":"dv.pagePaths(source)"},{"location":"api/code-reference/#dvpagepath","text":"Map a simple path or link to the full page object, which includes all of the pages fields. Automatically does link resolution, and will figure out the extension automatically if not present. dv . page ( \"Index\" ) => The page object for /Index dv . page ( \"books/The Raisin.md\" ) => The page object for /books/The Raisin.md","title":"dv.page(path)"},{"location":"api/code-reference/#render","text":"","title":"Render"},{"location":"api/code-reference/#dvelelement-text","text":"Render arbitrary text in the given html element. dv . el ( \"b\" , \"This is some bold text\" ); You can specify custom classes to add to the element via cls , and additional attributes via attr : dv . el ( \"b\" , \"This is some text\" , { cls : \"dataview dataview-class\" , attr : { alt : \"Nice!\" } });","title":"dv.el(element, text)"},{"location":"api/code-reference/#dvheaderlevel-text","text":"Render a header of level 1 - 6 with the given text. dv . header ( 1 , \"Big!\" ); dv . header ( 6 , \"Tiny\" );","title":"dv.header(level, text)"},{"location":"api/code-reference/#dvparagraphtext","text":"Render arbitrary text in a paragraph. dv . paragraph ( \"This is some text\" );","title":"dv.paragraph(text)"},{"location":"api/code-reference/#dvspantext","text":"Render arbitrary text in a span (no padding above/below, unlike a paragraph). dv . span ( \"This is some text\" );","title":"dv.span(text)"},{"location":"api/code-reference/#dvexecutesource","text":"Execute an arbitrary dataview query and embed the view into the current page. dv . execute ( \"LIST FROM #tag\" ); dv . execute ( \"TABLE field1, field2 FROM #thing\" );","title":"dv.execute(source)"},{"location":"api/code-reference/#dvexecutejssource","text":"Execute an arbitrary DataviewJS query and embed the view into the current page. dv . executeJs ( \"dv.list([1, 2, 3])\" );","title":"dv.executeJs(source)"},{"location":"api/code-reference/#dvviewpath-input","text":"Complex function which allows for custom views. Will attempt to load a JavaScript file at the given path, passing it dv and input and allowing it to execute. This allows for you to re-use custom view code across multiple pages. Note that this is an asynchronous function since it involves file I/O - make sure to await the result! await dv . view ( \"views/custom\" , { arg1 : ..., arg2 : ... }); If you want to also include custom CSS in your view, you can instead pass a path to a folder containing view.js and view.css ; the CSS will be added to the view automatically: views/custom -> view.js -> view.css View scripts have access to the dv object (the API object), and an input object which is exactly whatever the second argument of dv.view() was.","title":"dv.view(path, input)"},{"location":"api/code-reference/#dataviews","text":"","title":"Dataviews"},{"location":"api/code-reference/#dvlistelements","text":"Render a dataview list of elements; accept both vanilla arrays and data arrays. dv . list ([ 1 , 2 , 3 ]) => list of 1 , 2 , 3 dv . list ( dv . pages (). file . name ) => list of all file names dv . list ( dv . pages (). file . link ) => list of all file links dv . list ( dv . pages ( \"#book\" ). where ( p => p . rating > 7 )) => list of all books with rating greater than 7","title":"dv.list(elements)"},{"location":"api/code-reference/#dvtasklisttasks-groupbyfile","text":"Render a dataview list of Task objects, as obtained by page.file.tasks . Only the first argument is required; if the second argument groupByFile is provided (and is true), then tasks will be grouped by the file they come from automatically. // List all tasks from pages marked '#project' dv . taskList ( dv . pages ( \"#project\" ). file . tasks ) // List all *uncompleted* tasks from pages marked #project dv . taskList ( dv . pages ( \"#project\" ). file . tasks . where ( t => ! t . completed )) // List all tasks tagged with '#tag' from pages marked #project dv . taskList ( dv . pages ( \"#project\" ). file . tasks . where ( t => t . text . includes ( \"#tag\" )))","title":"dv.taskList(tasks, groupByFile)"},{"location":"api/code-reference/#dvtableheaders-elements","text":"Render a dataview table with the given list of headers and 2D array of elements. // Render a simple table of book info sorted by rating. dv . table ([ \"File\" , \"Genre\" , \"Time Read\" , \"Rating\" ], dv . pages ( \"#book\" ) . sort ( b => b . rating ) . map ( b => [ b . file . link , b . genre , b [ \"time-read\" ], b . rating ]))","title":"dv.table(headers, elements)"},{"location":"api/code-reference/#markdown-dataviews","text":"Functions which render to plain Markdown strings which you can then render or manipulate as desired.","title":"Markdown Dataviews"},{"location":"api/code-reference/#dvmarkdowntableheaders-values","text":"Equivalent to dv.table() , which renders a table with the given list of headers and 2D array of elements, but returns plain Markdown. // Render a simple table of book info sorted by rating. const table = dv . markdownTable ([ \"File\" , \"Genre\" , \"Time Read\" , \"Rating\" ], dv . pages ( \"#book\" ) . sort ( b => b . rating ) . map ( b => [ b . file . link , b . genre , b [ \"time-read\" ], b . rating ])) dv . paragraph ( table );","title":"dv.markdownTable(headers, values)"},{"location":"api/code-reference/#dvmarkdownlistvalues","text":"Equivalent to dv.list() , which renders a list of the given elements, but returns plain Markdown. const markdown = dv . markdownList ([ 1 , 2 , 3 ]); dv . paragraph ( markdown );","title":"dv.markdownList(values)"},{"location":"api/code-reference/#dvmarkdowntasklisttasks","text":"Equivalent to dv.taskList() , which renders a task list, but returns plain Markdown. const markdown = dv . markdownTaskList ( dv . pages ( \"#project\" ). file . tasks ); dv . paragraph ( markdown );","title":"dv.markdownTaskList(tasks)"},{"location":"api/code-reference/#utility","text":"","title":"Utility"},{"location":"api/code-reference/#dvarrayvalue","text":"Convert a given value or array into a Dataview data array . If the value is already a data array, returns it unchanged. dv . array ([ 1 , 2 , 3 ]) => dataview data array [ 1 , 2 , 3 ]","title":"dv.array(value)"},{"location":"api/code-reference/#dvisarrayvalue","text":"Returns true if the given value is an array or dataview array. dv . isArray ( dv . array ([ 1 , 2 , 3 ])) => true dv . isArray ([ 1 , 2 , 3 ]) => true dv . isArray ({ x : 1 }) => false","title":"dv.isArray(value)"},{"location":"api/code-reference/#dvfilelinkpath-embed-display-name","text":"Converts a textual path into a Dataview Link object; you can optionally also specify if the link is embedded as well as it's display name. dv . fileLink ( \"2021-08-08\" ) => link to file named \"2021-08-08\" dv . fileLink ( \"book/The Raisin\" , true ) => embed link to \"The Raisin\" dv . fileLink ( \"Test\" , false , \"Test File\" ) => link to file \"Test\" with display name \"Test File\"","title":"dv.fileLink(path, [embed?], [display-name])"},{"location":"api/code-reference/#dvsectionlinkpath-section-embed-display","text":"Converts a textual path + section name into a Dataview Link object; you can optionally also specify if the link is embedded and it's display name. dv . sectionLink ( \"Index\" , \"Books\" ) => [[ Index # Books ]] dv . sectionLink ( \"Index\" , \"Books\" , false , \"My Books\" ) => [[ Index # Books | My Books ]]","title":"dv.sectionLink(path, section, [embed?], [display?])"},{"location":"api/code-reference/#dvblocklinkpath-blockid-embed-display","text":"Converts a textual path + block ID into a Dataview Link object; you can optionally also specify if the link is embedded and it's display name. dv . blockLink ( \"Notes\" , \"12gdhjg3\" ) => [[ Index # ^ 12 gdhjg3 ]]","title":"dv.blockLink(path, blockId, [embed?], [display?])"},{"location":"api/code-reference/#dvdatetext","text":"Coerce text and links to luxon DateTime ; if provided with a DateTime , return it unchanged. dv . date ( \"2021-08-08\" ) => DateTime for August 8 th , 2021 dv . date ( dv . fileLink ( \"2021-08-07\" )) => dateTime for August 8 th , 2021","title":"dv.date(text)"},{"location":"api/code-reference/#dvdurationtext","text":"Coerce text to a luxon Duration ; uses the same parsing rules as Dataview duration types. dv . duration ( \"8 minutes\" ) => Duration { 8 minutes } dv . duration ( \"9 hours, 2 minutes, 3 seconds\" ) => Duration { 9 hours , 2 minutes , 3 seconds }","title":"dv.duration(text)"},{"location":"api/code-reference/#dvcomparea-b","text":"Compare two arbitrary JavaScript values according to dataview's default comparison rules; useful if you are writing a custom comparator and want to fall back to the default behavior. Returns a negative value if a < b , 0 if a = b , and a positive value if a > b . dv . compare ( 1 , 2 ) = - 1 dv . compare ( \"yes\" , \"no\" ) = 1 dv . compare ({ what : 0 }, { what : 0 }) = 0","title":"dv.compare(a, b)"},{"location":"api/code-reference/#dvequala-b","text":"Compare two arbitrary JavaScript values and return true if they are equal according to Dataview's default comparison rules. dv . equal ( 1 , 2 ) = false dv . equal ( 1 , 1 ) = true","title":"dv.equal(a, b)"},{"location":"api/code-reference/#dvclonevalue","text":"Deep clone any Dataview value, including dates, arrays, and links. dv . clone ( 1 ) = 1 dv . clone ({ a : 1 }) = { a : 1 }","title":"dv.clone(value)"},{"location":"api/code-reference/#dvparsevalue","text":"Parse an arbitrary string object into a complex Dataview type (mainly supporting links, dates, and durations). dv . parse ( \"[[A]]\" ) = Link { path : A } dv . parse ( \"2020-08-14\" ) = DateTime { 2020 - 08 - 14 } dv . parse ( \"9 seconds\" ) = Duration { 9 seconds }","title":"dv.parse(value)"},{"location":"api/code-reference/#file-io","text":"These utility methods are all contained in the dv.io sub-API, and are all asynchronous (marked by \u231b).","title":"File I/O"},{"location":"api/code-reference/#dviocsvpath-origin-file","text":"Load a CSV from the given path (a link or string). Relative paths will be resolved relative to the optional origin file (defaulting to the current file if not provided). Return a dataview array, each element containing an object of the CSV values; if the file does not exist, return undefined . await dv . io . csv ( \"hello.csv\" ) => [{ column1 : ..., column2 : ...}, ...]","title":"\u231b dv.io.csv(path, [origin-file])"},{"location":"api/code-reference/#dvioloadpath-origin-file","text":"Load the contents of the given path (a link or string) asynchronously. Relative paths will be resolved relative to the optional origin file (defaulting to the current file if not provided). Returns the string contents of the file, or undefined if the file does not exist. await dv . io . load ( \"File\" ) => \"# File\\nThis is an example file...\"","title":"\u231b dv.io.load(path, [origin-file])"},{"location":"api/code-reference/#dvionormalizepath-origin-file","text":"Convert a relative link or path into an absolute path. If origin-file is provided, then the resolution is doing as if you were resolving the link from that file; if not, the path is resolved relative to the current file. dv . io . normalize ( \"Test\" ) => \"dataview/test/Test.md\" , if inside \"dataview/test\" dv . io . normalize ( \"Test\" , \"dataview/test2/Index.md\" ) => \"dataview/test2/Test.md\" , irrespective of the current file","title":"dv.io.normalize(path, [origin-file])"},{"location":"api/code-reference/#query-evaluation","text":"","title":"Query Evaluation"},{"location":"api/code-reference/#dvquerysource-file-settings","text":"Execute a Dataview query and return the results as a structured return. The return type of this function varies by the query type being executed, though will always be an object with a type denoting the return type. This version of query returns a result type - you may want tryQuery , which instead throws an error on failed query execution. await dv . query ( \"LIST FROM #tag\" ) => Success { type : \"list\" , values : [ value1 , value2 , ...] } await dv . query ( `TABLE WITHOUT ID file.name, value FROM \"path\"` ) => Success { type : \"table\" , headers : [ \"file.name\" , \"value\" ], values : [[ \"A\" , 1 ], [ \"B\" , 2 ]] } await dv . query ( \"TASK WHERE due\" ) => Success { type : \"task\" , values : [ task1 , task2 , ...]} dv.query accepts two additional, optional arguments: 1. file : The file path to resolve the query from (in case of references to this ). Defaults to the current file. 2. settings : Execution settings for running the query. This is largely an advanced use case (where I recommend you directly check the API implementation to see all available options).","title":"\u231b dv.query(source, [file, settings])"},{"location":"api/code-reference/#dvtryquerysource-file-settings","text":"Exactly the same as dv.query , but more convienent in short scripts as execution failures will be raised as JavaScript exceptions instead of a result type.","title":"\u231b dv.tryQuery(source, [file, settings])"},{"location":"api/code-reference/#dvquerymarkdownsource-file-settings","text":"Equivalent to dv.query() , but returns rendered Markdown. await dv . queryMarkdown ( \"LIST FROM #tag\" ) => Success { \"- [[Page 1]]\\n- [[Page 2]]\" }","title":"\u231b dv.queryMarkdown(source, [file], [settings])"},{"location":"api/code-reference/#dvtryquerymarkdownsource-file-settings","text":"Exactly the same as dv.queryMarkdown() , but throws an error on parse failure.","title":"\u231b dv.tryQueryMarkdown(source, [file], [settings])"},{"location":"api/code-reference/#dvtryevaluateexpression-context","text":"Evaluate an arbitrary dataview expression (like 2 + 2 or link(\"text\") or x * 9 ); throws an Error on parse or evaluation failure. this is an always-available implicit variable which refers to the current file. dv . tryEvaluate ( \"2 + 2\" ) => 4 dv . tryEvaluate ( \"x + 2\" , { x : 3 }) => 5 dv . tryEvaluate ( \"length(this.file.tasks)\" ) => number of tasks in the current file","title":"dv.tryEvaluate(expression, [context])"},{"location":"api/code-reference/#dvevaluateexpression-context","text":"Evaluate an arbitrary dataview expression (like 2 + 2 or link(\"text\") or x * 9 ), returning a Result object of the result. You can unwrap the result type by checking result.successful (and then fetching either result.value or result.error ). If you want a simpler API that throws an error on a failed evaluation, use dv.tryEvaluate . dv . evaluate ( \"2 + 2\" ) => Successful { value : 4 } dv . evaluate ( \"2 +\" ) => Failure { error : \"Failed to parse ... \" }","title":"dv.evaluate(expression, [context])"},{"location":"api/data-array/","text":"Data Arrays The general abstraction for lists of results in Dataview is the DataArray , which is a proxied array with additional functionality. Data arrays support indexing and iteration (via for and for ... of loops) as per normal arrays, but also include many data manipulation operators like sort , groupBy , distinct , where , and so on to make mainpulating tabular data easy. Creation Data arrays are returned by most Dataview APIs that can return multiple results, such as dv.pages() . You can also explicitly convert a normal JavaScript array into a Dataview array using dv.array(<array>) . If you want to convert a Data array back to a normal array, use DataArray#array() . Indexing and Swizzling Data arrays support regular indexing just like normal arrays (like array[0] ), but importantly, they also support query-language-style \"swizzling\": if you index into a data array with a field name (like array.field ), it automatically maps every element in the array to field , flattening field if it itself is also an array. For example, dv.pages().file.name will return a data array of all file names in your vault; dv.pages(\"#books\").genres will return a flattened list of all genres in your books. Raw Interface The full interface for the data array implementation is provided below for reference: /** A function which maps an array element to some value. */ export type ArrayFunc < T , O > = ( elem : T , index : number , arr : T []) => O ; /** A function which compares two types. */ export type ArrayComparator < T > = ( a : T , b : T ) => number ; /** * Proxied interface which allows manipulating array-based data. All functions on a data array produce a NEW array * (i.e., the arrays are immutable). */ export interface DataArray < T > { /** The total number of elements in the array. */ length : number ; /** Filter the data array down to just elements which match the given predicate. */ where ( predicate : ArrayFunc < T , boolean > ) : DataArray < T > ; /** Alias for 'where' for people who want array semantics. */ filter ( predicate : ArrayFunc < T , boolean > ) : DataArray < T > ; /** Map elements in the data array by applying a function to each. */ map < U > ( f : ArrayFunc < T , U > ) : DataArray < U > ; /** Map elements in the data array by applying a function to each, then flatten the results to produce a new array. */ flatMap < U > ( f : ArrayFunc < T , U [] > ) : DataArray < U > ; /** Mutably change each value in the array, returning the same array which you can further chain off of. */ mutate ( f : ArrayFunc < T , any > ) : DataArray < any > ; /** Limit the total number of entries in the array to the given value. */ limit ( count : number ) : DataArray < T > ; /** * Take a slice of the array. If `start` is undefined, it is assumed to be 0; if `end` is undefined, it is assumbed * to be the end of the array. */ slice ( start? : number , end? : number ) : DataArray < T > ; /** Concatenate the values in this data array with those of another iterable / data array / array. */ concat ( other : Iterable < T > ) : DataArray < T > ; /** Return the first index of the given (optionally starting the search) */ indexOf ( element : T , fromIndex? : number ) : number ; /** Return the first element that satisfies the given predicate. */ find ( pred : ArrayFunc < T , boolean > ) : T | undefined ; /** Find the index of the first element that satisfies the given predicate. Returns -1 if nothing was found. */ findIndex ( pred : ArrayFunc < T , boolean > , fromIndex? : number ) : number ; /** Returns true if the array contains the given element, and false otherwise. */ includes ( element : T ) : boolean ; /** * Return a string obtained by converting each element in the array to a string, and joining it with the * given separator (which defaults to ', '). */ join ( sep? : string ) : string ; /** * Return a sorted array sorted by the given key; an optional comparator can be provided, which will * be used to compare the keys in leiu of the default dataview comparator. */ sort < U > ( key : ArrayFunc < T , U > , direction ?: \"asc\" | \"desc\" , comparator? : ArrayComparator < U > ) : DataArray < T > ; /** * Return an array where elements are grouped by the given key; the resulting array will have objects of the form * { key: <key value>, rows: DataArray }. */ groupBy < U > ( key : ArrayFunc < T , U > , comparator? : ArrayComparator < U > ) : DataArray < { key : U ; rows : DataArray < T > } > ; /** * Return distinct entries. If a key is provided, then rows with distinct keys are returned. */ distinct < U > ( key? : ArrayFunc < T , U > , comparator? : ArrayComparator < U > ) : DataArray < T > ; /** Return true if the predicate is true for all values. */ every ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return true if the predicate is true for at least one value. */ some ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return true if the predicate is FALSE for all values. */ none ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return the first element in the data array. Returns undefined if the array is empty. */ first () : T ; /** Return the last element in the data array. Returns undefined if the array is empty. */ last () : T ; /** Map every element in this data array to the given key, and then flatten it.*/ to ( key : string ) : DataArray < any > ; /** * Recursively expand the given key, flattening a tree structure based on the key into a flat array. Useful for handling * heirarchical data like tasks with 'subtasks'. */ expand ( key : string ) : DataArray < any > ; /** Run a lambda on each element in the array. */ forEach ( f : ArrayFunc < T , void > ) : void ; /** Convert this to a plain javascript array. */ array () : T []; /** Allow iterating directly over the array. */ [ Symbol . iterator ]() : Iterator < T > ; /** Map indexes to values. */ [ index : number ] : any ; /** Automatic flattening of fields. Equivalent to implicitly calling `array.to(\"field\")` */ [ field : string ] : any ; }","title":"Data Arrays"},{"location":"api/data-array/#data-arrays","text":"The general abstraction for lists of results in Dataview is the DataArray , which is a proxied array with additional functionality. Data arrays support indexing and iteration (via for and for ... of loops) as per normal arrays, but also include many data manipulation operators like sort , groupBy , distinct , where , and so on to make mainpulating tabular data easy.","title":"Data Arrays"},{"location":"api/data-array/#creation","text":"Data arrays are returned by most Dataview APIs that can return multiple results, such as dv.pages() . You can also explicitly convert a normal JavaScript array into a Dataview array using dv.array(<array>) . If you want to convert a Data array back to a normal array, use DataArray#array() .","title":"Creation"},{"location":"api/data-array/#indexing-and-swizzling","text":"Data arrays support regular indexing just like normal arrays (like array[0] ), but importantly, they also support query-language-style \"swizzling\": if you index into a data array with a field name (like array.field ), it automatically maps every element in the array to field , flattening field if it itself is also an array. For example, dv.pages().file.name will return a data array of all file names in your vault; dv.pages(\"#books\").genres will return a flattened list of all genres in your books.","title":"Indexing and Swizzling"},{"location":"api/data-array/#raw-interface","text":"The full interface for the data array implementation is provided below for reference: /** A function which maps an array element to some value. */ export type ArrayFunc < T , O > = ( elem : T , index : number , arr : T []) => O ; /** A function which compares two types. */ export type ArrayComparator < T > = ( a : T , b : T ) => number ; /** * Proxied interface which allows manipulating array-based data. All functions on a data array produce a NEW array * (i.e., the arrays are immutable). */ export interface DataArray < T > { /** The total number of elements in the array. */ length : number ; /** Filter the data array down to just elements which match the given predicate. */ where ( predicate : ArrayFunc < T , boolean > ) : DataArray < T > ; /** Alias for 'where' for people who want array semantics. */ filter ( predicate : ArrayFunc < T , boolean > ) : DataArray < T > ; /** Map elements in the data array by applying a function to each. */ map < U > ( f : ArrayFunc < T , U > ) : DataArray < U > ; /** Map elements in the data array by applying a function to each, then flatten the results to produce a new array. */ flatMap < U > ( f : ArrayFunc < T , U [] > ) : DataArray < U > ; /** Mutably change each value in the array, returning the same array which you can further chain off of. */ mutate ( f : ArrayFunc < T , any > ) : DataArray < any > ; /** Limit the total number of entries in the array to the given value. */ limit ( count : number ) : DataArray < T > ; /** * Take a slice of the array. If `start` is undefined, it is assumed to be 0; if `end` is undefined, it is assumbed * to be the end of the array. */ slice ( start? : number , end? : number ) : DataArray < T > ; /** Concatenate the values in this data array with those of another iterable / data array / array. */ concat ( other : Iterable < T > ) : DataArray < T > ; /** Return the first index of the given (optionally starting the search) */ indexOf ( element : T , fromIndex? : number ) : number ; /** Return the first element that satisfies the given predicate. */ find ( pred : ArrayFunc < T , boolean > ) : T | undefined ; /** Find the index of the first element that satisfies the given predicate. Returns -1 if nothing was found. */ findIndex ( pred : ArrayFunc < T , boolean > , fromIndex? : number ) : number ; /** Returns true if the array contains the given element, and false otherwise. */ includes ( element : T ) : boolean ; /** * Return a string obtained by converting each element in the array to a string, and joining it with the * given separator (which defaults to ', '). */ join ( sep? : string ) : string ; /** * Return a sorted array sorted by the given key; an optional comparator can be provided, which will * be used to compare the keys in leiu of the default dataview comparator. */ sort < U > ( key : ArrayFunc < T , U > , direction ?: \"asc\" | \"desc\" , comparator? : ArrayComparator < U > ) : DataArray < T > ; /** * Return an array where elements are grouped by the given key; the resulting array will have objects of the form * { key: <key value>, rows: DataArray }. */ groupBy < U > ( key : ArrayFunc < T , U > , comparator? : ArrayComparator < U > ) : DataArray < { key : U ; rows : DataArray < T > } > ; /** * Return distinct entries. If a key is provided, then rows with distinct keys are returned. */ distinct < U > ( key? : ArrayFunc < T , U > , comparator? : ArrayComparator < U > ) : DataArray < T > ; /** Return true if the predicate is true for all values. */ every ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return true if the predicate is true for at least one value. */ some ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return true if the predicate is FALSE for all values. */ none ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return the first element in the data array. Returns undefined if the array is empty. */ first () : T ; /** Return the last element in the data array. Returns undefined if the array is empty. */ last () : T ; /** Map every element in this data array to the given key, and then flatten it.*/ to ( key : string ) : DataArray < any > ; /** * Recursively expand the given key, flattening a tree structure based on the key into a flat array. Useful for handling * heirarchical data like tasks with 'subtasks'. */ expand ( key : string ) : DataArray < any > ; /** Run a lambda on each element in the array. */ forEach ( f : ArrayFunc < T , void > ) : void ; /** Convert this to a plain javascript array. */ array () : T []; /** Allow iterating directly over the array. */ [ Symbol . iterator ]() : Iterator < T > ; /** Map indexes to values. */ [ index : number ] : any ; /** Automatic flattening of fields. Equivalent to implicitly calling `array.to(\"field\")` */ [ field : string ] : any ; }","title":"Raw Interface"},{"location":"api/intro/","text":"Overview The Dataview JavaScript API allows for executing arbitrary JavaScript with access to the dataview indices and query engine, which is good for complex views or interop with other plugins. The API comes in two flavors: plugin facing, and user facing (or 'inline API usage'). Inline Access You can create a \"DataviewJS\" block via: ```dataviewjs dv.pages(\"#thing\")... ``` Code executed in such codeblocks have access to the dv variable, which provides the entirety of the codeblock-relevant dataview API (like dv.table() , dv.pages() , and so on). For more information, check out the codeblock API reference . Plugin Access You can access the Dataview Plugin API (from other plugins or the console) through app.plugins.plugins.dataview.api ; this API is similar to the codeblock reference, with slightly different arguments due to the lack of an implicit file to execute the queries in. For more information, check out the Plugin API reference .","title":"Overview"},{"location":"api/intro/#overview","text":"The Dataview JavaScript API allows for executing arbitrary JavaScript with access to the dataview indices and query engine, which is good for complex views or interop with other plugins. The API comes in two flavors: plugin facing, and user facing (or 'inline API usage').","title":"Overview"},{"location":"api/intro/#inline-access","text":"You can create a \"DataviewJS\" block via: ```dataviewjs dv.pages(\"#thing\")... ``` Code executed in such codeblocks have access to the dv variable, which provides the entirety of the codeblock-relevant dataview API (like dv.table() , dv.pages() , and so on). For more information, check out the codeblock API reference .","title":"Inline Access"},{"location":"api/intro/#plugin-access","text":"You can access the Dataview Plugin API (from other plugins or the console) through app.plugins.plugins.dataview.api ; this API is similar to the codeblock reference, with slightly different arguments due to the lack of an implicit file to execute the queries in. For more information, check out the Plugin API reference .","title":"Plugin Access"},{"location":"plugin/develop-against-dataview/","text":"Developing Against Dataview Dataview includes a high-level plugin-facing API as well as TypeScript definitions and a utility library; to install it, simply use: npm install -D obsidian-dataview Accessing the Dataview API You can use the getAPI() function to obtain the Dataview Plugin API; this returns a DataviewApi object which provides various utilities, including rendering dataviews, checking dataview's version, hooking into the dataview event life cycle, and querying dataview metadata. import { getAPI } from \"obsidian-dataview\" ; const api = getAPI (); For full API definitions available, check index.ts or the plugin API definition plugin-api.ts . Binding to Dataview Events You can bind to dataview metadata events, which fire on all file updates and changes, via: plugin . registerEvent ( plugin . app . metadataCache . on ( \"dataview:index-ready\" , () => { ... }); plugin . registerEvent ( plugin . app . metadataCache . on ( \"dataview:metadata-change\" , ( type , file , oldPath ? ) => { ... })); For all events hooked on MetadataCache, check index.ts . Value Utilities You can access various type utilities which let you check the types of objects and compare them via Values : import { getAPI , Values } from \"obsidian-dataview\" ; const field = getAPI ( plugin . app ) ? . page ( 'sample.md' ). field ; if ( ! field ) return ; if ( Values . isHtml ( field )) // do something else if ( Values . isLink ( field )) // do something // ...","title":"Developing Against Dataview"},{"location":"plugin/develop-against-dataview/#developing-against-dataview","text":"Dataview includes a high-level plugin-facing API as well as TypeScript definitions and a utility library; to install it, simply use: npm install -D obsidian-dataview","title":"Developing Against Dataview"},{"location":"plugin/develop-against-dataview/#accessing-the-dataview-api","text":"You can use the getAPI() function to obtain the Dataview Plugin API; this returns a DataviewApi object which provides various utilities, including rendering dataviews, checking dataview's version, hooking into the dataview event life cycle, and querying dataview metadata. import { getAPI } from \"obsidian-dataview\" ; const api = getAPI (); For full API definitions available, check index.ts or the plugin API definition plugin-api.ts .","title":"Accessing the Dataview API"},{"location":"plugin/develop-against-dataview/#binding-to-dataview-events","text":"You can bind to dataview metadata events, which fire on all file updates and changes, via: plugin . registerEvent ( plugin . app . metadataCache . on ( \"dataview:index-ready\" , () => { ... }); plugin . registerEvent ( plugin . app . metadataCache . on ( \"dataview:metadata-change\" , ( type , file , oldPath ? ) => { ... })); For all events hooked on MetadataCache, check index.ts .","title":"Binding to Dataview Events"},{"location":"plugin/develop-against-dataview/#value-utilities","text":"You can access various type utilities which let you check the types of objects and compare them via Values : import { getAPI , Values } from \"obsidian-dataview\" ; const field = getAPI ( plugin . app ) ? . page ( 'sample.md' ). field ; if ( ! field ) return ; if ( Values . isHtml ( field )) // do something else if ( Values . isLink ( field )) // do something // ...","title":"Value Utilities"},{"location":"queries/data-commands/","text":"Data Commands The different commands that dataview queries can be made up of. Commands are executed in order, and you can have duplicate commands (so multiple WHERE blocks or multiple GROUP BY blocks, for example). FROM The FROM statement determines what pages will initially be collected and passed onto the other commands for further filtering. You can select from any source , which currently means by folder, by tag, or by incoming/outgoing links. Tags : To select from a tag (and all its subtags), use FROM #tag . Folders : To select from a folder (and all its subfolders), use FROM \"folder\" . Single Files : To select from a single file, use FROM \"path/to/file\" . Links : You can either select links TO a file, or all links FROM a file. To obtain all pages which link TO [[note]] , use FROM [[note]] . To obtain all pages which link FROM [[note]] (i.e., all the links in that file), use FROM outgoing([[note]]) . You can compose these filters in order to get more advanced sources using and and or . For example, #tag and \"folder\" will return all pages in folder and with #tag . [[Food]] or [[Exercise]] will give any pages which link to [[Food]] OR [[Exercise]] . You can also \"negate\" sources to obtain anything that does NOT match a source using - : -#tag will exclude files which have the given tag. #tag and -\"folder\" will only include files tagged #tag which are NOT in \"folder\" . WHERE Filter pages on fields. Only pages where the clause evaluates to true will be yielded. WHERE <clause> Obtain all files which were modified in the last 24 hours: LIST WHERE file . mtime >= date ( today ) - dur ( 1 day ) Find all projects which are not marked complete and are more than a month old: LIST FROM # projects WHERE ! completed AND file . ctime <= date ( today ) - dur ( 1 month ) SORT Sorts all results by one or more fields. SORT date [ASCENDING/DESCENDING/ASC/DESC] You can also give multiple fields to sort by. Sorting will be done based on the first field. Then, if a tie occurs, the second field will be used to sort the tied fields. If there is still a tie, the third sort will resolve it, and so on. SORT field1 [ASCENDING/DESCENDING/ASC/DESC], ..., fieldN [ASC/DESC] GROUP BY Group all results on a field. Yields one row per unique field value, which has 2 properties: one corresponding to the field being grouped on, and a rows array field which contains all of the pages that matched. GROUP BY field GROUP BY (computed_field) AS name In order to make working with the rows array easier, Dataview supports field \"swizzling\". If you want the field test from every object in the rows array, then rows.test will automatically fetch the test field from every object in rows , yielding a new array. You can then apply aggregation operators like sum() over the resulting array. FLATTEN Flatten an array in every row, yielding one result row per entry in the array. FLATTEN field FLATTEN (computed_field) AS name For example, flatten the authors field in each literature note to give one row per author: Query TABLE authors FROM # LiteratureNote FLATTEN authors Output File authors stegEnvironmentalPsychologyIntroduction2018 SN Steg, L. stegEnvironmentalPsychologyIntroduction2018 SN Van den Berg, A. E. stegEnvironmentalPsychologyIntroduction2018 SN De Groot, J. I. M. Soap Dragons SN Robert Lamb Soap Dragons SN Joe McCormick smithPainAssaultSelf2007 SN Jonathan A. Smith smithPainAssaultSelf2007 SN Mike Osborn A good use of this would be when there is a deeply nested list that you want to use more easily. For example, file.lists or file.tasks . Note the simpler query though the end results are slightly different (grouped vs non-grouped). You can use a GROUP BY file.link to achieve identical results but would need to use rows.T.text as described earlier. table T.text as \"Task Text\" from \"Scratchpad\" flatten file.tasks as T where T.text table filter(file.tasks.text, (t) => t) as \"Task Text\" from \"Scratchpad\" where file.tasks.text FLATTEN makes it easier to operate on nested lists since you can then use simpler where conditions on them as opposed to using functions like map() or filter() . LIMIT Restrict the results to at most N values. LIMIT 5 Commands are processed in the order they are written, so the following sorts the results after they have already been limited: LIMIT 5 SORT date ASCENDING","title":"Data Commands"},{"location":"queries/data-commands/#data-commands","text":"The different commands that dataview queries can be made up of. Commands are executed in order, and you can have duplicate commands (so multiple WHERE blocks or multiple GROUP BY blocks, for example).","title":"Data Commands"},{"location":"queries/data-commands/#from","text":"The FROM statement determines what pages will initially be collected and passed onto the other commands for further filtering. You can select from any source , which currently means by folder, by tag, or by incoming/outgoing links. Tags : To select from a tag (and all its subtags), use FROM #tag . Folders : To select from a folder (and all its subfolders), use FROM \"folder\" . Single Files : To select from a single file, use FROM \"path/to/file\" . Links : You can either select links TO a file, or all links FROM a file. To obtain all pages which link TO [[note]] , use FROM [[note]] . To obtain all pages which link FROM [[note]] (i.e., all the links in that file), use FROM outgoing([[note]]) . You can compose these filters in order to get more advanced sources using and and or . For example, #tag and \"folder\" will return all pages in folder and with #tag . [[Food]] or [[Exercise]] will give any pages which link to [[Food]] OR [[Exercise]] . You can also \"negate\" sources to obtain anything that does NOT match a source using - : -#tag will exclude files which have the given tag. #tag and -\"folder\" will only include files tagged #tag which are NOT in \"folder\" .","title":"FROM"},{"location":"queries/data-commands/#where","text":"Filter pages on fields. Only pages where the clause evaluates to true will be yielded. WHERE <clause> Obtain all files which were modified in the last 24 hours: LIST WHERE file . mtime >= date ( today ) - dur ( 1 day ) Find all projects which are not marked complete and are more than a month old: LIST FROM # projects WHERE ! completed AND file . ctime <= date ( today ) - dur ( 1 month )","title":"WHERE"},{"location":"queries/data-commands/#sort","text":"Sorts all results by one or more fields. SORT date [ASCENDING/DESCENDING/ASC/DESC] You can also give multiple fields to sort by. Sorting will be done based on the first field. Then, if a tie occurs, the second field will be used to sort the tied fields. If there is still a tie, the third sort will resolve it, and so on. SORT field1 [ASCENDING/DESCENDING/ASC/DESC], ..., fieldN [ASC/DESC]","title":"SORT"},{"location":"queries/data-commands/#group-by","text":"Group all results on a field. Yields one row per unique field value, which has 2 properties: one corresponding to the field being grouped on, and a rows array field which contains all of the pages that matched. GROUP BY field GROUP BY (computed_field) AS name In order to make working with the rows array easier, Dataview supports field \"swizzling\". If you want the field test from every object in the rows array, then rows.test will automatically fetch the test field from every object in rows , yielding a new array. You can then apply aggregation operators like sum() over the resulting array.","title":"GROUP BY"},{"location":"queries/data-commands/#flatten","text":"Flatten an array in every row, yielding one result row per entry in the array. FLATTEN field FLATTEN (computed_field) AS name For example, flatten the authors field in each literature note to give one row per author: Query TABLE authors FROM # LiteratureNote FLATTEN authors Output File authors stegEnvironmentalPsychologyIntroduction2018 SN Steg, L. stegEnvironmentalPsychologyIntroduction2018 SN Van den Berg, A. E. stegEnvironmentalPsychologyIntroduction2018 SN De Groot, J. I. M. Soap Dragons SN Robert Lamb Soap Dragons SN Joe McCormick smithPainAssaultSelf2007 SN Jonathan A. Smith smithPainAssaultSelf2007 SN Mike Osborn A good use of this would be when there is a deeply nested list that you want to use more easily. For example, file.lists or file.tasks . Note the simpler query though the end results are slightly different (grouped vs non-grouped). You can use a GROUP BY file.link to achieve identical results but would need to use rows.T.text as described earlier. table T.text as \"Task Text\" from \"Scratchpad\" flatten file.tasks as T where T.text table filter(file.tasks.text, (t) => t) as \"Task Text\" from \"Scratchpad\" where file.tasks.text FLATTEN makes it easier to operate on nested lists since you can then use simpler where conditions on them as opposed to using functions like map() or filter() .","title":"FLATTEN"},{"location":"queries/data-commands/#limit","text":"Restrict the results to at most N values. LIMIT 5 Commands are processed in the order they are written, so the following sorts the results after they have already been limited: LIMIT 5 SORT date ASCENDING","title":"LIMIT"},{"location":"queries/dql-js-inline/","text":"Creating Queries Once you've added useful data to relevant pages , you'll want to actually display it somewhere or operate on it. Dataview allows this in four different ways, all of which are written in codeblocks directly in your Markdown and live-reloaded when your vault changes. Dataview Query Language (DQL) The dataview query language is a simplistic, SQL-like language for quickly creating views. It supports basic arithmetic and comparison operations, and is good for basic applications. You create dataview queries using dataview -annotated codeblocks: ```dataview TABLE rating AS \"Rating\", summary AS \"Summary\" FROM #games SORT rating DESC ``` The details of how to write a query are explained in the query language reference ; if you learn better by example, take a look at the query examples . Inline DQL The query language also provides inline queries, which allow you to embed single values directly inside a page - for example, todays date via = date(today) , or a field from another page via = [[Page]].value . You create inline queries using inline codeblocks: `= this.file.name` Inline DQL expressions are written using the query language expression language . You can configure inline queries to use a different prefix (like dv: or ~ ) in the Dataview settings. Dataview JS The dataview JavaScript API gives you the full power of JavaScript and provides a DSL for pulling Dataview data and executing queries, allowing you to create arbitrarily complex queries and views. Similar to the query language, you create Dataview JS blocks via a dataviewjs -annotated codeblock: ``` dataviewjs let pages = dv . pages ( \"#books and -#books/finished\" ). where ( b => b . rating >= 7 ); for ( let group of pages . groupBy ( b => b . genre )) { dv . header ( 3 , group . key ); dv . list ( group . rows . file . name ); } ``` Inside of a JS dataview block, you have access to the full dataview API via the dv variable. For an explanation of what you can do with it, see the API documentation , or the API examples . Inline Dataview JS Similar to the query language, you can write JS inline queries, which let you embed a computed JS value directly. You create JS inline queries via inline code blocks: `$= dv.current().file.mtime` In inline DataviewJS, you have access to the dv variable, as in dataviewjs codeblocks, and can make all of the same calls. The result should be something which evaluates to a JavaScript value, which Dataview will automatically render appropriately.","title":"DQL, JS and Inlines"},{"location":"queries/dql-js-inline/#creating-queries","text":"Once you've added useful data to relevant pages , you'll want to actually display it somewhere or operate on it. Dataview allows this in four different ways, all of which are written in codeblocks directly in your Markdown and live-reloaded when your vault changes.","title":"Creating Queries"},{"location":"queries/dql-js-inline/#dataview-query-language-dql","text":"The dataview query language is a simplistic, SQL-like language for quickly creating views. It supports basic arithmetic and comparison operations, and is good for basic applications. You create dataview queries using dataview -annotated codeblocks: ```dataview TABLE rating AS \"Rating\", summary AS \"Summary\" FROM #games SORT rating DESC ``` The details of how to write a query are explained in the query language reference ; if you learn better by example, take a look at the query examples .","title":"Dataview Query Language (DQL)"},{"location":"queries/dql-js-inline/#inline-dql","text":"The query language also provides inline queries, which allow you to embed single values directly inside a page - for example, todays date via = date(today) , or a field from another page via = [[Page]].value . You create inline queries using inline codeblocks: `= this.file.name` Inline DQL expressions are written using the query language expression language . You can configure inline queries to use a different prefix (like dv: or ~ ) in the Dataview settings.","title":"Inline DQL"},{"location":"queries/dql-js-inline/#dataview-js","text":"The dataview JavaScript API gives you the full power of JavaScript and provides a DSL for pulling Dataview data and executing queries, allowing you to create arbitrarily complex queries and views. Similar to the query language, you create Dataview JS blocks via a dataviewjs -annotated codeblock: ``` dataviewjs let pages = dv . pages ( \"#books and -#books/finished\" ). where ( b => b . rating >= 7 ); for ( let group of pages . groupBy ( b => b . genre )) { dv . header ( 3 , group . key ); dv . list ( group . rows . file . name ); } ``` Inside of a JS dataview block, you have access to the full dataview API via the dv variable. For an explanation of what you can do with it, see the API documentation , or the API examples .","title":"Dataview JS"},{"location":"queries/dql-js-inline/#inline-dataview-js","text":"Similar to the query language, you can write JS inline queries, which let you embed a computed JS value directly. You create JS inline queries via inline code blocks: `$= dv.current().file.mtime` In inline DataviewJS, you have access to the dv variable, as in dataviewjs codeblocks, and can make all of the same calls. The result should be something which evaluates to a JavaScript value, which Dataview will automatically render appropriately.","title":"Inline Dataview JS"},{"location":"queries/query-types/","text":"Query Types Your Query Type determines how the output of your dataview query looks like. LIST, TABLE and CALENDAR always operates on page level, whereas TASK queries operate on file.tasks level. List Queries Lists are the simplest view, and simply render a list of pages (or custom fields) which match the query. To obtain a list of pages matching the query, simply use: Syntax LIST FROM <source> Query LIST FROM # games / mobas OR # games / crpg Output League of Legends Pillars of Eternity 2 You can render a single computed value in addition to each matching file, by adding an expression after LIST : Syntax LIST <expression> FROM <source> Query LIST \"File Path: \" + file . path FROM \"4. Archive\" Output 2020-12-18 DN : File path: 4. Archive/Daily Notes/2020-12-18 DN.md 2020-12-16 DN : File path: 4. Archive/Daily Notes/2020-12-16 DN.md 2020-12-17 DN : File path: 4. Archive/Daily Notes/2020-12-17 DN.md 2020-12-15 DN : File path: 4. Archive/Daily Notes/2020-12-15 DN.md LIST WITHOUT ID If you don't want the file name / group key included in the list view, you can use LIST WITHOUT ID : Syntax LIST WITHOUT ID <expression> FROM <source> Query LIST WITHOUT ID file . path FROM \"4. Archive\" Output Archive/Daily Notes/2020-12-18 DN.md Archive/Daily Notes/2020-12-16 DN.md Archive/Daily Notes/2020-12-17 DN.md Archive/Daily Notes/2020-12-15 DN.md Table Queries Tables support tabular views of page data. You construct a table by giving a comma separated list of the YAML frontmatter fields you want to render, as so: TABLE file.day, file.mtime FROM <source> You can choose a heading name to render computed fields by using the AS syntax: TABLE (file.mtime + dur(1 day)) AS next_mtime, ... FROM <source> An example table query: Query TABLE time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM # game SORT rating DESC Output File Time Played Length Rating Outer Wilds November 19th - 21st, 2020 15h 9.5 Minecraft All the time. 2000h 9.5 Pillars of Eternity 2 August - October 2019 100h 9 TABLE WITHOUT ID If you don't want the default \"File\" or \"Group\" field in your output (either to replace it or because it is unneeded), you can use TABLE WITHOUT ID : Query TABLE WITHOUT ID time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM # game SORT rating DESC Output Time Played Length Rating November 19th - 21st, 2020 15h 9.5 All the time. 2000h 9.5 August - October 2019 100h 9 Task Queries Task views render all tasks whose pages match the given predicate. Syntax TASK FROM <source> Query TASK FROM \"dataview\" Output I am a task. I am another task. I could be a task, though who knows. Determine if this is a task. I'm a finished task. You can filter ( WHERE ), group ( GROUP BY ), sort ( SORT ) tasks in these queries as desired using typical dataview statements: Syntax TASK FROM <source> WHERE <predicate> ... Query TASK FROM \"dataview\" WHERE !completed GROUP BY file.folder Output Folder 1 I am a task. I am another task. I am yet another task in another file in the same folder. Folder 2 I could be a task, though who knows. Folder 3 What even is a task, anyway? A common use case for tasks is to group them by their originating file: Syntax TASK FROM <source> GROUP BY file.link Query TASK FROM \"dataview\" GROUP BY file . link Output dataview/Project A I am a task. I am another task. dataview/Project A I could be a task, though who knows. Determine if this is a task. I'm a finished task. Calendar Queries Calendar views render all pages which match the query in a calendar view, using the given date expression to chose which date to render a page on. Syntax CALENDAR <date> FROM <source> Query CALENDAR file . mtime FROM \"dataview\" Output The output will be a calendar that displays a dot per file in the dataview directory. The dot will be placed on the date that the file was modified on.","title":"Query Types"},{"location":"queries/query-types/#query-types","text":"Your Query Type determines how the output of your dataview query looks like. LIST, TABLE and CALENDAR always operates on page level, whereas TASK queries operate on file.tasks level.","title":"Query Types"},{"location":"queries/query-types/#list-queries","text":"Lists are the simplest view, and simply render a list of pages (or custom fields) which match the query. To obtain a list of pages matching the query, simply use: Syntax LIST FROM <source> Query LIST FROM # games / mobas OR # games / crpg Output League of Legends Pillars of Eternity 2 You can render a single computed value in addition to each matching file, by adding an expression after LIST : Syntax LIST <expression> FROM <source> Query LIST \"File Path: \" + file . path FROM \"4. Archive\" Output 2020-12-18 DN : File path: 4. Archive/Daily Notes/2020-12-18 DN.md 2020-12-16 DN : File path: 4. Archive/Daily Notes/2020-12-16 DN.md 2020-12-17 DN : File path: 4. Archive/Daily Notes/2020-12-17 DN.md 2020-12-15 DN : File path: 4. Archive/Daily Notes/2020-12-15 DN.md","title":"List Queries"},{"location":"queries/query-types/#list-without-id","text":"If you don't want the file name / group key included in the list view, you can use LIST WITHOUT ID : Syntax LIST WITHOUT ID <expression> FROM <source> Query LIST WITHOUT ID file . path FROM \"4. Archive\" Output Archive/Daily Notes/2020-12-18 DN.md Archive/Daily Notes/2020-12-16 DN.md Archive/Daily Notes/2020-12-17 DN.md Archive/Daily Notes/2020-12-15 DN.md","title":"LIST WITHOUT ID"},{"location":"queries/query-types/#table-queries","text":"Tables support tabular views of page data. You construct a table by giving a comma separated list of the YAML frontmatter fields you want to render, as so: TABLE file.day, file.mtime FROM <source> You can choose a heading name to render computed fields by using the AS syntax: TABLE (file.mtime + dur(1 day)) AS next_mtime, ... FROM <source> An example table query: Query TABLE time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM # game SORT rating DESC Output File Time Played Length Rating Outer Wilds November 19th - 21st, 2020 15h 9.5 Minecraft All the time. 2000h 9.5 Pillars of Eternity 2 August - October 2019 100h 9","title":"Table Queries"},{"location":"queries/query-types/#table-without-id","text":"If you don't want the default \"File\" or \"Group\" field in your output (either to replace it or because it is unneeded), you can use TABLE WITHOUT ID : Query TABLE WITHOUT ID time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM # game SORT rating DESC Output Time Played Length Rating November 19th - 21st, 2020 15h 9.5 All the time. 2000h 9.5 August - October 2019 100h 9","title":"TABLE WITHOUT ID"},{"location":"queries/query-types/#task-queries","text":"Task views render all tasks whose pages match the given predicate. Syntax TASK FROM <source> Query TASK FROM \"dataview\" Output I am a task. I am another task. I could be a task, though who knows. Determine if this is a task. I'm a finished task. You can filter ( WHERE ), group ( GROUP BY ), sort ( SORT ) tasks in these queries as desired using typical dataview statements: Syntax TASK FROM <source> WHERE <predicate> ... Query TASK FROM \"dataview\" WHERE !completed GROUP BY file.folder Output Folder 1 I am a task. I am another task. I am yet another task in another file in the same folder. Folder 2 I could be a task, though who knows. Folder 3 What even is a task, anyway? A common use case for tasks is to group them by their originating file: Syntax TASK FROM <source> GROUP BY file.link Query TASK FROM \"dataview\" GROUP BY file . link Output dataview/Project A I am a task. I am another task. dataview/Project A I could be a task, though who knows. Determine if this is a task. I'm a finished task.","title":"Task Queries"},{"location":"queries/query-types/#calendar-queries","text":"Calendar views render all pages which match the query in a calendar view, using the given date expression to chose which date to render a page on. Syntax CALENDAR <date> FROM <source> Query CALENDAR file . mtime FROM \"dataview\" Output The output will be a calendar that displays a dot per file in the dataview directory. The dot will be placed on the date that the file was modified on.","title":"Calendar Queries"},{"location":"queries/structure/","text":"Structure of a Query The dataview query language is a simple, structured, custom query language for quickly creating views on your data. It supports: Fetching pages associated with tags, folders, links, and so on. Filtering pages / data by simple operations on fields, like comparison, existence checks, and so on. Sorting results based on fields. The query language supports the following view types, described below: TABLE : The traditional view type; one row per data point, with several columns of field data. LIST : A list of pages which match the query. You can output a single associated value for each page. TASK : A list of tasks whose pages match the given query. CALENDAR : A calendar view displaying each hit via a dot on its reffered date Read more about the available types here General Format The general format for queries is: ```dataview TABLE|LIST|TASK <field> [AS \"Column Name\"], <field>, ..., <field> FROM <source> WHERE <expression> SORT <expression> [ASC/DESC] ... other data commands ``` Only the Query Type (table/list/task/calendar) statement is required - if the \"from\" statement is omitted, the query runs for all files in your vault. You can specify data commands like WHERE multiple times; they will run in the order they are written. The most basic example of a dataview query is: ```dataview LIST ``` which will list all files in your vault . Find more examples here .","title":"Structure of a Query"},{"location":"queries/structure/#structure-of-a-query","text":"The dataview query language is a simple, structured, custom query language for quickly creating views on your data. It supports: Fetching pages associated with tags, folders, links, and so on. Filtering pages / data by simple operations on fields, like comparison, existence checks, and so on. Sorting results based on fields. The query language supports the following view types, described below: TABLE : The traditional view type; one row per data point, with several columns of field data. LIST : A list of pages which match the query. You can output a single associated value for each page. TASK : A list of tasks whose pages match the given query. CALENDAR : A calendar view displaying each hit via a dot on its reffered date Read more about the available types here","title":"Structure of a Query"},{"location":"queries/structure/#general-format","text":"The general format for queries is: ```dataview TABLE|LIST|TASK <field> [AS \"Column Name\"], <field>, ..., <field> FROM <source> WHERE <expression> SORT <expression> [ASC/DESC] ... other data commands ``` Only the Query Type (table/list/task/calendar) statement is required - if the \"from\" statement is omitted, the query runs for all files in your vault. You can specify data commands like WHERE multiple times; they will run in the order they are written. The most basic example of a dataview query is: ```dataview LIST ``` which will list all files in your vault . Find more examples here .","title":"General Format"},{"location":"reference/examples/","text":"Examples A small collection of simple usages of the dataview query language. Show all games in the games folder, sorted by rating, with some metadata: Query TABLE time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM \"games\" SORT rating DESC Output File Time Played Length Rating Outer Wilds November 19th - 21st, 2020 15h 9.5 Minecraft All the time. 2000h 9.5 Pillars of Eternity 2 August - October 2019 100h 9 List games which are MOBAs or CRPGs. Query LIST FROM # games / mobas OR # games / crpg Output League of Legends Pillars of Eternity 2 List all tasks in un-completed projects: Query TASK FROM \"dataview\" Output dataview/Project A I am a task. I am another task. dataview/Project A I could be a task, though who knows. Determine if this is a task. I'm a finished task. List all of the files in the books folder, sorted by the last time you modifed the file: Query TABLE file . mtime AS \"Last Modified\" FROM \"books\" SORT file . mtime DESC Output File Last Modified Atomic Habits 11:06 PM - August 07, 2021 Can't Hurt Me 10:58 PM - August 07, 2021 Deep Work 10:52 PM - August 07, 2021 List all files which have a date in their title (of the form yyyy-mm-dd ), and list them by date order. Query LIST file . day WHERE file . day SORT file . day DESC Output 2021-08-07 : August 07, 2021 2020-08-10 : August 10, 2020","title":"Examples"},{"location":"reference/examples/#examples","text":"A small collection of simple usages of the dataview query language. Show all games in the games folder, sorted by rating, with some metadata: Query TABLE time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM \"games\" SORT rating DESC Output File Time Played Length Rating Outer Wilds November 19th - 21st, 2020 15h 9.5 Minecraft All the time. 2000h 9.5 Pillars of Eternity 2 August - October 2019 100h 9 List games which are MOBAs or CRPGs. Query LIST FROM # games / mobas OR # games / crpg Output League of Legends Pillars of Eternity 2 List all tasks in un-completed projects: Query TASK FROM \"dataview\" Output dataview/Project A I am a task. I am another task. dataview/Project A I could be a task, though who knows. Determine if this is a task. I'm a finished task. List all of the files in the books folder, sorted by the last time you modifed the file: Query TABLE file . mtime AS \"Last Modified\" FROM \"books\" SORT file . mtime DESC Output File Last Modified Atomic Habits 11:06 PM - August 07, 2021 Can't Hurt Me 10:58 PM - August 07, 2021 Deep Work 10:52 PM - August 07, 2021 List all files which have a date in their title (of the form yyyy-mm-dd ), and list them by date order. Query LIST file . day WHERE file . day SORT file . day DESC Output 2021-08-07 : August 07, 2021 2020-08-10 : August 10, 2020","title":"Examples"},{"location":"reference/expressions/","text":"Expressions Dataview query language expressions are anything that yields a value - all fields are expressions, as are literal values (like 6 ), as are computed values (like field - 9 ). For a very high level summary: # Literals 1 (number) true/false (boolean) \"text\" (text) date(2021-04-18) (date) dur(1 day) (duration) [[Link]] (link) [1, 2, 3] (list) { a: 1, b: 2 } (object) # Lambdas (x1, x2) => ... (lambda) # References field (directly refer to a field) simple-field (refer to fields with spaces/punctuation in them like \"Simple Field!\") a.b (if a is an object, retrieve field named 'b') a[expr] (if a is an object or array, retrieve field with name specified by expression 'expr') f(a, b, ...) (call a function called `f` on arguments a, b, ...) # Arithmetic a + b (addition) a - b (subtraction) a * b (multiplication) a / b (division) a % b (modulo / remainder of division) # Comparison a > b (check if a is greater than b) a < b (check if a is less than b) a = b (check if a equals b) a != b (check if a does not equal b) a <= b (check if a is less than or equal to b) a >= b (check if a is greater than or equal to b) # Special Operations [[Link]].value (fetch `value` from page `Link`) More detailed explanations of each follow. Expression Types Fields as Expressions The simplest expression is one that just directly refers to a field. If you have a field called \"field\", then you can refer to it directly by name - field . If the field name has spaces, punctuation, or other non-letter/number characters, then you can refer to it using Dataview's simplified name, which is all lower case with spaces replaced with \"-\". For example, this is a field becomes this-is-a-field ; Hello! becomes hello , and so on. Literals Constant values - things like 1 or \"hello\" or date(som) (\"start of month\"). There are literals for each data type that dataview supports; you can see the reference above for examples of what each literal type looks like. Arithmetic You can use standard arithmetic operators to combine fields: addition ( + ), subtraction ( - ), multiplication ( * ), and division ( / ). For example field1 + field2 is an expression which computes the sum of the two fields. Comparisons You can compare most values using the various comparison operators: < , > , <= , >= , = , != . This yields a boolean true or false value which can be used in WHERE blocks in queries. Array/Object Indexing You can retrieve data from arrays via the index operator array[<index>] , where <index> is any computed expression. Arrays are 0-indexed, so the first element is index 0, the second element is index 1, and so on. For example list(1, 2, 3)[0] = 1 . A similar notation style works for objects. You can use field[\"nestedfield\"] to reference fields inside an object or otherwise similarly nested. For example, in the YAML defined below, we can reference previous via episode_metadata[\"previous\"] . --- current_episode : \"S01E03\" episode_metadata : previous : \"S01E02\" next : \"S01E04\" --- You can also retrieve data from objects (which map text to data values) also using the index operator, where indexes are now strings/text instead of numbers. You can also use the shorthand object.<name> , where <name> is the name of the value to retrieve. For the previous frontmatter example, we could also use episode_metadata.previous to obtain the same value. Index expressions also work on objects which have fields that are not directly supported by the query language. A good example is where , since it is a keyword. If your frontmatter/metadata contains a field where , you can reference it via the row syntax: row[\"where\"] . See the note in the FAQ and the corresponding issue for further information. Function Calls Dataview supports various functions for manipulating data, which are described in full in the functions documentation . They have the general syntax function(arg1, arg2, ...) - i.e., lower(\"yes\") or regexmatch(\"text\", \".+\") . Lambdas Lambdas are advanced literals which let you define a function that takes some number of inputs, and produces an output. They have the general form: (arg1, arg2, arg3, ...) => <expression using args> Lambdas are used in several advanced operators like reduce and map to allow for complex transformations of data. A few examples: (x, y) => x + y (sum x and y) (x) => 2 * x (double x) (value) => length(value) = 4 (return true if value is length 4) Type-specific Interactions & Values Most dataview types have special interactions with operators, or have additional fields that can be retrieved using the index operator. Dates You can retrieve various components of a date via indexing: date.year , date.month , date.day , date.hour , date.minute , date.second , date.week , date.weekyear . You can also add durations to dates to get new dates. Durations Durations can be added to each other or to dates. You can retrieve various components of a duration via indexing: duration.years , duration.months , duration.days , duration.hours , duration.minutes , duration.seconds . Links You can \"index through\" a link to get values on the corresponding page. For example [[Link]].value would get the value value from page Link . Link Indexing in Expressions If your link is a field that you defined in an inline field or in front-matter, like Key:: [[Link]] , then you should index into it by just writing Key.value ; Using [[Key]].value would look up the page literally called Key , which is probably not what you want!","title":"Expressions"},{"location":"reference/expressions/#expressions","text":"Dataview query language expressions are anything that yields a value - all fields are expressions, as are literal values (like 6 ), as are computed values (like field - 9 ). For a very high level summary: # Literals 1 (number) true/false (boolean) \"text\" (text) date(2021-04-18) (date) dur(1 day) (duration) [[Link]] (link) [1, 2, 3] (list) { a: 1, b: 2 } (object) # Lambdas (x1, x2) => ... (lambda) # References field (directly refer to a field) simple-field (refer to fields with spaces/punctuation in them like \"Simple Field!\") a.b (if a is an object, retrieve field named 'b') a[expr] (if a is an object or array, retrieve field with name specified by expression 'expr') f(a, b, ...) (call a function called `f` on arguments a, b, ...) # Arithmetic a + b (addition) a - b (subtraction) a * b (multiplication) a / b (division) a % b (modulo / remainder of division) # Comparison a > b (check if a is greater than b) a < b (check if a is less than b) a = b (check if a equals b) a != b (check if a does not equal b) a <= b (check if a is less than or equal to b) a >= b (check if a is greater than or equal to b) # Special Operations [[Link]].value (fetch `value` from page `Link`) More detailed explanations of each follow.","title":"Expressions"},{"location":"reference/expressions/#expression-types","text":"","title":"Expression Types"},{"location":"reference/expressions/#fields-as-expressions","text":"The simplest expression is one that just directly refers to a field. If you have a field called \"field\", then you can refer to it directly by name - field . If the field name has spaces, punctuation, or other non-letter/number characters, then you can refer to it using Dataview's simplified name, which is all lower case with spaces replaced with \"-\". For example, this is a field becomes this-is-a-field ; Hello! becomes hello , and so on.","title":"Fields as Expressions"},{"location":"reference/expressions/#literals","text":"Constant values - things like 1 or \"hello\" or date(som) (\"start of month\"). There are literals for each data type that dataview supports; you can see the reference above for examples of what each literal type looks like.","title":"Literals"},{"location":"reference/expressions/#arithmetic","text":"You can use standard arithmetic operators to combine fields: addition ( + ), subtraction ( - ), multiplication ( * ), and division ( / ). For example field1 + field2 is an expression which computes the sum of the two fields.","title":"Arithmetic"},{"location":"reference/expressions/#comparisons","text":"You can compare most values using the various comparison operators: < , > , <= , >= , = , != . This yields a boolean true or false value which can be used in WHERE blocks in queries.","title":"Comparisons"},{"location":"reference/expressions/#arrayobject-indexing","text":"You can retrieve data from arrays via the index operator array[<index>] , where <index> is any computed expression. Arrays are 0-indexed, so the first element is index 0, the second element is index 1, and so on. For example list(1, 2, 3)[0] = 1 . A similar notation style works for objects. You can use field[\"nestedfield\"] to reference fields inside an object or otherwise similarly nested. For example, in the YAML defined below, we can reference previous via episode_metadata[\"previous\"] . --- current_episode : \"S01E03\" episode_metadata : previous : \"S01E02\" next : \"S01E04\" --- You can also retrieve data from objects (which map text to data values) also using the index operator, where indexes are now strings/text instead of numbers. You can also use the shorthand object.<name> , where <name> is the name of the value to retrieve. For the previous frontmatter example, we could also use episode_metadata.previous to obtain the same value. Index expressions also work on objects which have fields that are not directly supported by the query language. A good example is where , since it is a keyword. If your frontmatter/metadata contains a field where , you can reference it via the row syntax: row[\"where\"] . See the note in the FAQ and the corresponding issue for further information.","title":"Array/Object Indexing"},{"location":"reference/expressions/#function-calls","text":"Dataview supports various functions for manipulating data, which are described in full in the functions documentation . They have the general syntax function(arg1, arg2, ...) - i.e., lower(\"yes\") or regexmatch(\"text\", \".+\") .","title":"Function Calls"},{"location":"reference/expressions/#lambdas","text":"Lambdas are advanced literals which let you define a function that takes some number of inputs, and produces an output. They have the general form: (arg1, arg2, arg3, ...) => <expression using args> Lambdas are used in several advanced operators like reduce and map to allow for complex transformations of data. A few examples: (x, y) => x + y (sum x and y) (x) => 2 * x (double x) (value) => length(value) = 4 (return true if value is length 4)","title":"Lambdas"},{"location":"reference/expressions/#type-specific-interactions-values","text":"Most dataview types have special interactions with operators, or have additional fields that can be retrieved using the index operator.","title":"Type-specific Interactions &amp; Values"},{"location":"reference/expressions/#dates","text":"You can retrieve various components of a date via indexing: date.year , date.month , date.day , date.hour , date.minute , date.second , date.week , date.weekyear . You can also add durations to dates to get new dates.","title":"Dates"},{"location":"reference/expressions/#durations","text":"Durations can be added to each other or to dates. You can retrieve various components of a duration via indexing: duration.years , duration.months , duration.days , duration.hours , duration.minutes , duration.seconds .","title":"Durations"},{"location":"reference/expressions/#links","text":"You can \"index through\" a link to get values on the corresponding page. For example [[Link]].value would get the value value from page Link . Link Indexing in Expressions If your link is a field that you defined in an inline field or in front-matter, like Key:: [[Link]] , then you should index into it by just writing Key.value ; Using [[Key]].value would look up the page literally called Key , which is probably not what you want!","title":"Links"},{"location":"reference/faq/","text":"Frequently Asked Questions A collection of frequently asked questions for Dataview queries and the expression language. How do I use fields with the same name as keywords (like \"from\", \"where\")? Dataview provides a special \"fake\" field called row which can be indexed into to obtain fields which conflict with Dataview keywords: row . from /* Same as \"from\" */ row . where /* Same as \"where\" */ How do I access fields with spaces in the name? There are two ways: Use the normalized Dataview name for such a field - just convert the name to lowercase and replace whitespace with dashes (\"-\"). Something like Field With Space In It becomes field-with-space-in-it . Use the implicit row field: row [ \"Field With Space In It\" ] Do you have a list of resources to learn from? Yes! Please see the Resources page.","title":"Frequently Asked Questions"},{"location":"reference/faq/#frequently-asked-questions","text":"A collection of frequently asked questions for Dataview queries and the expression language.","title":"Frequently Asked Questions"},{"location":"reference/faq/#how-do-i-use-fields-with-the-same-name-as-keywords-like-from-where","text":"Dataview provides a special \"fake\" field called row which can be indexed into to obtain fields which conflict with Dataview keywords: row . from /* Same as \"from\" */ row . where /* Same as \"where\" */","title":"How do I use fields with the same name as keywords (like \"from\", \"where\")?"},{"location":"reference/faq/#how-do-i-access-fields-with-spaces-in-the-name","text":"There are two ways: Use the normalized Dataview name for such a field - just convert the name to lowercase and replace whitespace with dashes (\"-\"). Something like Field With Space In It becomes field-with-space-in-it . Use the implicit row field: row [ \"Field With Space In It\" ]","title":"How do I access fields with spaces in the name?"},{"location":"reference/faq/#do-you-have-a-list-of-resources-to-learn-from","text":"Yes! Please see the Resources page.","title":"Do you have a list of resources to learn from?"},{"location":"reference/functions/","text":"Functions Dataview functions provide more advanced ways to manipulate data. Function Vectorization Most functions can be applied either to single values (like number , string , date , etc.) OR to lists of those values. If a function is applied to a list, it also returns a list after the function is applied to each element in the list. For example: lower(\"YES\") = \"yes\" lower([\"YES\", \"NO\"]) = [\"yes\", \"no\"] replace(\"yes\", \"e\", \"a\") = \"yas\" replace([\"yes\", \"ree\"], \"e\", \"a\") = [\"yas\", \"raa\"] Constructors Constructors which create values. object(key1, value1, ...) Creates a new object with the given keys and values. Keys and values should alternate in the call, and keys should always be strings/text. object() => empty object object(\"a\", 6) => object which maps \"a\" to 6 object(\"a\", 4, \"c\", \"yes\") => object which maps a to 4, and c to \"yes\" list(value1, value2, ...) Creates a new list with the given values in it. list() => empty list list(1, 2, 3) => list with 1, 2, and 3 list(\"a\", \"b\", \"c\") => list with \"a\", \"b\", and \"c\" date(any) Parses a date from the provided string, date, or link object, if possible, returning null otherwise. date(\"2020-04-18\") = <date object representing April 18th, 2020> date([[2021-04-16]]) = <date object for the given page, refering to file.day> dur(any) Parses a duration from the provided string or duration, returning null on failure. dur(8 minutes) = <8 minutes> dur(\"8 minutes, 4 seconds\") = <8 minutes, 4 seconds> dur(dur(8 minutes)) = dur(8 minutes) = <8 minutes> number(string) Pulls the first number out of the given string, returning it if possible. Returns null if there are no numbers in the string. number(\"18 years\") = 18 number(34) = 34 number(\"hmm\") = null string(any) Converts any value into a \"reasonable\" string representation. This sometimes produces less pretty results than just directly using the value in a query - it is mostly useful for coercing dates, durations, numbers, and so on into strings for manipulation. string(18) = \"18\" string(dur(8 hours)) = \"8 hours\" string(date(2021-08-15)) = \"August 15th, 2021\" link(path, [display]) Construct a link object from the given file path or name. If provided with two arguments, the second argument is the display name for the link. link(\"Hello\") => link to page named 'Hello' link(\"Hello\", \"Goodbye\") => link to page named 'Hello', displays as 'Goodbye' embed(link, [embed?]) Convert a link object into an embedded link; support for embedded links is somewhat spotty in Dataview views, though embedding of images should work. embed(link(\"Hello.png\")) => embedded link to the \"Hello.png\" image, which will render as an actual image. elink(url, [display]) Construct a link to an external url (like www.google.com ). If provided with two arguments, the second argument is the display name for the link. elink(\"www.google.com\") => link element to google.com elink(\"www.google.com\", \"Google\") => link element to google.com, displays as \"Google\" typeof(any) Get the type of any object for inspection. Can be used in conjunction with other operators to change behavior based on type. typeof(8) => \"number\" typeof(\"text\") => \"string\" typeof([1, 2, 3]) => \"array\" typeof({ a: 1, b: 2 }) => \"object\" typeof(date(2020-01-01)) => \"date\" typeof(dur(8 minutes)) => \"duration\" Numeric Operations round(number, [digits]) Round a number to a given number of digits. If the second argument is not specified, rounds to the nearest whole number; otherwise, rounds to the given number of digits. round(16.555555) = 7 round(16.555555, 2) = 16.56 product() Calculates the product of a list of numbers. product([1,2,3]) = 6 -- Objects, Arrays, and String Operations Operations that manipulate values inside of container objects. contains() and friends For a quick summary, here are some examples: contains(\"Hello\", \"Lo\") = false contains(\"Hello\", \"lo\") = true icontains(\"Hello\", \"Lo\") = true icontains(\"Hello\", \"lo\") = true econtains(\"Hello\", \"Lo\") = false econtains(\"Hello\", \"lo\") = true econtains([\"this\",\"is\",\"example\"], \"ex\") = false econtains([\"this\",\"is\",\"example\"], \"is\") = true contains(object|list|string, value) Checks if the given container type has the given value in it. This function behave slightly differently based on whether the first argument is an object, a list, or a string. This function is case-sensitive. For objects, checks if the object has a key with the given name. For example, contains(file, \"ctime\") = true contains(file, \"day\") = true (if file has a date in its title, false otherwise) For lists, checks if any of the array elements equals the given value. For example, contains(list(1, 2, 3), 3) = true contains(list(), 1) = false For strings, checks if the given value is a substring (i.e., inside) the string. contains(\"hello\", \"lo\") = true contains(\"yes\", \"no\") = false icontains(object|list|string, value) Case insensitive version of contains() . econtains(object|list|string, value) \"Exact contains\" checks if the exact match is found in the string/list. This function is case sensitive. For strings, it behaves exactly like contains() . econtains(\"Hello\", \"Lo\") = false econtains(\"Hello\", \"lo\") = true For lists, it checks if the exact word is in the list. econtains([\"These\", \"are\", \"words\"], \"word\") = false econtains([\"These\", \"are\", \"words\"], \"words\") = true For objects, it checks if the exact key name is present in the object. It does not do recursive checks. econtains({key:\"value\", pairs:\"here\"}, \"here\") = false econtains({key:\"value\", pairs:\"here\"}, \"key\") = true econtains({key:\"value\", recur:{recurkey: \"val\"}}, \"value\") = false econtains({key:\"value\", recur:{recurkey: \"val\"}}, \"Recur\") = false econtains({key:\"value\", recur:{recurkey: \"val\"}}, \"recurkey\") = false containsword(list|string, value) Checks if value has an exact word match in string or list . This is case insensitive. The outputs are different for different types of input, see examples. For strings, it checks if the word is present in the given string. containsword(\"word\", \"word\") = true containsword(\"word\", \"Word\") = true containsword(\"words\", \"Word\") = false containsword(\"Hello there!, \"hello\") = true containsword(\"Hello there!, \"HeLLo\") = true containsword(\"Hello there chaps!, \"chap\") = false containsword(\"Hello there chaps!, \"chaps\") = true For lists, it returns a list of booleans indicating if the word's exact case insensitive match was found. containsword([\"I have no words.\", \"words\"], \"Word\") = [false, false] containsword([\"word\", \"Words\"], \"Word\") = [true, false] containsword([\"Word\", \"Words in word\"], \"WORD\") = [true, true] extract(object, key1, key2, ...) Pulls multiple fields out of an object, creating a new object with just those fields. extract(file, \"ctime\", \"mtime\") = object(\"ctime\", file.ctime, \"mtime\", file.mtime) extract(object(\"test\", 1)) = object() sort(list) Sorts a list, returning a new list in sorted order. sort(list(3, 2, 1)) = list(1, 2, 3) sort(list(\"a\", \"b\", \"aa\")) = list(\"a\", \"aa\", \"b\") reverse(list) Reverses a list, returning a new list in reversed order. reverse(list(1, 2, 3)) = list(3, 2, 1) reverse(list(\"a\", \"b\", \"c\")) = list(\"c\", \"b\", \"a\") length(object|array) Returns the number of fields in an object, or the number of entries in an array. length(list()) = 0 length(list(1, 2, 3)) = 3 length(object(\"hello\", 1, \"goodbye\", 2)) = 2 sum(array) Sums all numeric values in the array sum(list(1, 2, 3)) = 6 all(array) Returns true only if ALL values in the array are truthy. You can also pass multiple arguments to this function, in which case it returns true only if all arguments are truthy. all(list(1, 2, 3)) = true all(list(true, false)) = false all(true, false) = false all(true, true, true) = true You can pass a function as second argument to return only true if all elements in the array matches the predicate. all(list(1, 2, 3), (x) => x > 0) = true all(list(1, 2, 3), (x) => x > 1) = false all(list(\"apple\", \"pie\", 3), (x) => typeof(x) = \"string\") = false any(array) Returns true if ANY of the values in the array are truthy. You can also pass multiple arguments to this function, in which case it returns true if any of the arguments are truthy. any(list(1, 2, 3)) = true any(list(true, false)) = true any(list(false, false, false)) = false any(true, false) = true any(false, false) = false You can pass a function as second argument to return only true if any element in the array matches the predicate. any(list(1, 2, 3), (x) => x > 2) = true any(list(1, 2, 3), (x) => x = 0) = false none(array) Returns true if NONE of the values in the array are truthy. none([]) = true none([false, false]) = true none([false, true]) = false none([1, 2, 3]) = false You can pass a function as second argument to return only true if none of the elements in the array matches the predicate. none([1, 2, 3], (x) => x = 0) = true none([true, true], (x) => x = false) = true none([\"Apple\", \"Pi\", \"Banana\"], (x) => startswith(x, \"A\")) = false join(array) Joins elements in an array into a single string (i.e., rendering them all on the same line). If provided with a second argument, then each element will be separated by the given separator. join(list(1, 2, 3)) = \"1, 2, 3\" join(list(1, 2, 3), \" \") = \"1 2 3\" join(6) = \"6\" join(list()) = \"\" filter(array, predicate) Filters elements in an array according to the predicate, returning a new list of the elements which matched. filter([1, 2, 3], (x) => x >= 2) = [2, 3] filter([\"yes\", \"no\", \"yas\"], (x) => startswith(x, \"y\")) = [\"yes\", \"yas\"] map(array, func) Applies the function to each element in the array, returning a list of the mapped results. map([1, 2, 3], (x) => x + 2) = [3, 4, 5] map([\"yes\", \"no\"], (x) => x + \"?\") = [\"yes?\", \"no?\"] String Operations regexmatch(pattern, string) Checks if the given string matches the given pattern (using the JavaScript regex engine). regexmatch(\"\\w+\", \"hello\") = true regexmatch(\".\", \"a\") = true regexmatch(\"yes|no\", \"maybe\") = false regexreplace(string, pattern, replacement) Replaces all instances where the regex pattern matches in string , with replacement . This uses the JavaScript replace method under the hood, so you can use special characters like $1 to refer to the first capture group, and so on. regexreplace(\"yes\", \"[ys]\", \"a\") = \"aea\" regexreplace(\"Suite 1000\", \"\\d+\", \"-\") = \"Suite -\" replace(string, pattern, replacement) Replace all instances of pattern in string with replacement . replace(\"what\", \"wh\", \"h\") = \"hat\" replace(\"The big dog chased the big cat.\", \"big\", \"small\") = \"The small dog chased the small cat.\" replace(\"test\", \"test\", \"no\") = \"no\" lower(string) Convert a string to all lower case. lower(\"Test\") = \"test\" lower(\"TEST\") = \"test\" upper(string) Convert a string to all upper case. upper(\"Test\") = \"TEST\" upper(\"test\") = \"TEST\" split(string, delimiter, [limit]) Split a string on the given delimiter string. If a third argument is provided, it limits the number of splits that occur. The delimiter string is interpreted as a regular expression. If there are capture groups in the delimiter, matches are spliced into the result array, and non-matching captures are empty strings. split(\"hello world\", \" \") = list(\"hello\", \"world\") split(\"hello world\", \"\\s\") = list(\"hello\", \"world\") split(\"hello there world\", \" \", 2) = list(\"hello\", \"there\") split(\"hello there world\", \"(t?here)\") = list(\"hello \", \"there\", \" world\") split(\"hello there world\", \"( )(x)?\") = list(\"hello\", \" \", \"\", \"there\", \" \", \"\", \"world\") startswith(string, prefix) Checks if a string starts with the given prefix. startswith(\"yes\", \"ye\") = true startswith(\"path/to/something\", \"path/\") = true startswith(\"yes\", \"no\") = false endswith(string, suffix) Checks if a string ends with the given suffix. endswith(\"yes\", \"es\") = true endswith(\"path/to/something\", \"something\") = true endswith(\"yes\", \"ye\") = false padleft(string, length, [padding]) Pads a string up to the desired length by adding padding on the left side. If you omit the padding character, spaces will be used by default. padleft(\"hello\", 7) = \" hello\" padleft(\"yes\", 5, \"!\") = \"!!yes\" padright(string, length, [padding]) Equivalent to padleft , but pads to the right instead. padright(\"hello\", 7) = \"hello \" padright(\"yes\", 5, \"!\") = \"yes!!\" substring(string, start, [end]) Take a slice of a string, starting at start and ending at end (or the end of the string if unspecified). substring(\"hello\", 0, 2) = \"he\" substring(\"hello\", 2, 4) = \"ll\" substring(\"hello\", 2) = \"llo\" substring(\"hello\", 0) = \"hello\" truncate(string, length, [suffix]) Truncate a string to be at most the given length, including the suffix (which defaults to ... ). Generally useful to cut off long text in tables. truncate(\"Hello there!\", 8) = \"Hello...\" truncate(\"Hello there!\", 8, \"/\") = \"Hello t/\" truncate(\"Hello there!\", 10) = \"Hello t...\" truncate(\"Hello there!\", 10, \"!\") = \"Hello the!\" truncate(\"Hello there!\", 20) = \"Hello there!\" Utility Functions default(field, value) If field is null, return value ; otherwise return field . Useful for replacing null values with defaults. For example, to show projects which haven't been completed yet, use \"incomplete\" as their defualt value: default(dateCompleted, \"incomplete\") Default is vectorized in both arguments; if you need to use default explicitly on a list argument, use ldefault , which is the same as default but is not vectorized. default(list(1, 2, null), 3) = list(1, 2, 3) ldefault(list(1, 2, null), 3) = list(1, 2, null) choice(bool, left, right) A primitive if statement - if the first argument is truthy, returns left; otherwise, returns right. choice(true, \"yes\", \"no\") = \"yes\" choice(false, \"yes\", \"no\") = \"no\" choice(x > 4, y, z) = y if x > 4, else z striptime(date) Strip the time component of a date, leaving only the year, month, and day. Good for date comparisons if you don't care about the time. striptime(file.ctime) = file.cday striptime(file.mtime) = file.mday dateformat(date|datetime, string) Format a Dataview date using a formatting string. Uses Luxon tokens . dateformat(file.ctime,\"yyyy-MM-dd\") = \"2022-01-05\" dateformat(file.ctime,\"HH:mm:ss\") = \"12:18:04\" dateformat(date(now),\"x\") = \"1407287224054\" dateformat(file.mtime,\"ffff\") = \"Wednesday, August 6, 2014, 1:07 PM Eastern Daylight Time\" localtime(date) Converts a date in a fixed timezone to a date in the current timezone. meta(link) Get an object containing metadata of a link. When you access a property on a link what you get back is the property value from the linked file. The meta function makes it possible to access properties of the link itself. There are several properties on the object returned by meta : meta(link).display Get the display text of a link, or null if the link does not have defined display text. meta([[2021-11-01|Displayed link text]]).display = \"Displayed link text\" meta([[2021-11-01]]).display = null meta(link).embed True or false depending on whether the link is an embed. Those are links that begin with an exclamation mark, like ![[Some Link]] . meta(link).path Get the path portion of a link. meta([[My Project]]).path = \"My Project\" meta([[My Project#Next Actions]]).path = \"My Project\" meta([[My Project#^9bcbe8]]).path = \"My Project\" meta(link).subpath Get the subpath of a link. For links to a heading within a file the subpath will be the text of the heading. For links to a block the subpath will be the block ID. If neither of those cases applies then the subpath will be null. meta([[My Project#Next Actions]]).subpath = \"Next Actions\" meta([[My Project#^9bcbe8]]).subpath = \"9bcbe8\" meta([[My Project]]).subpath = null This can be used to select tasks under specific headings. ```dataview task where meta(section).subpath = \"Next Actions\" ``` meta(link).type Has the value \"file\", \"header\", or \"block\" depending on whether the link links to an entire file, a heading within a file, or to a block within a file. meta([[My Project]]).type = \"file\" meta([[My Project#Next Actions]]).type = \"header\" meta([[My Project#^9bcbe8]]).type = \"block\"","title":"Functions"},{"location":"reference/functions/#functions","text":"Dataview functions provide more advanced ways to manipulate data.","title":"Functions"},{"location":"reference/functions/#function-vectorization","text":"Most functions can be applied either to single values (like number , string , date , etc.) OR to lists of those values. If a function is applied to a list, it also returns a list after the function is applied to each element in the list. For example: lower(\"YES\") = \"yes\" lower([\"YES\", \"NO\"]) = [\"yes\", \"no\"] replace(\"yes\", \"e\", \"a\") = \"yas\" replace([\"yes\", \"ree\"], \"e\", \"a\") = [\"yas\", \"raa\"]","title":"Function Vectorization"},{"location":"reference/functions/#constructors","text":"Constructors which create values.","title":"Constructors"},{"location":"reference/functions/#objectkey1-value1","text":"Creates a new object with the given keys and values. Keys and values should alternate in the call, and keys should always be strings/text. object() => empty object object(\"a\", 6) => object which maps \"a\" to 6 object(\"a\", 4, \"c\", \"yes\") => object which maps a to 4, and c to \"yes\"","title":"object(key1, value1, ...)"},{"location":"reference/functions/#listvalue1-value2","text":"Creates a new list with the given values in it. list() => empty list list(1, 2, 3) => list with 1, 2, and 3 list(\"a\", \"b\", \"c\") => list with \"a\", \"b\", and \"c\"","title":"list(value1, value2, ...)"},{"location":"reference/functions/#dateany","text":"Parses a date from the provided string, date, or link object, if possible, returning null otherwise. date(\"2020-04-18\") = <date object representing April 18th, 2020> date([[2021-04-16]]) = <date object for the given page, refering to file.day>","title":"date(any)"},{"location":"reference/functions/#durany","text":"Parses a duration from the provided string or duration, returning null on failure. dur(8 minutes) = <8 minutes> dur(\"8 minutes, 4 seconds\") = <8 minutes, 4 seconds> dur(dur(8 minutes)) = dur(8 minutes) = <8 minutes>","title":"dur(any)"},{"location":"reference/functions/#numberstring","text":"Pulls the first number out of the given string, returning it if possible. Returns null if there are no numbers in the string. number(\"18 years\") = 18 number(34) = 34 number(\"hmm\") = null","title":"number(string)"},{"location":"reference/functions/#stringany","text":"Converts any value into a \"reasonable\" string representation. This sometimes produces less pretty results than just directly using the value in a query - it is mostly useful for coercing dates, durations, numbers, and so on into strings for manipulation. string(18) = \"18\" string(dur(8 hours)) = \"8 hours\" string(date(2021-08-15)) = \"August 15th, 2021\"","title":"string(any)"},{"location":"reference/functions/#linkpath-display","text":"Construct a link object from the given file path or name. If provided with two arguments, the second argument is the display name for the link. link(\"Hello\") => link to page named 'Hello' link(\"Hello\", \"Goodbye\") => link to page named 'Hello', displays as 'Goodbye'","title":"link(path, [display])"},{"location":"reference/functions/#embedlink-embed","text":"Convert a link object into an embedded link; support for embedded links is somewhat spotty in Dataview views, though embedding of images should work. embed(link(\"Hello.png\")) => embedded link to the \"Hello.png\" image, which will render as an actual image.","title":"embed(link, [embed?])"},{"location":"reference/functions/#elinkurl-display","text":"Construct a link to an external url (like www.google.com ). If provided with two arguments, the second argument is the display name for the link. elink(\"www.google.com\") => link element to google.com elink(\"www.google.com\", \"Google\") => link element to google.com, displays as \"Google\"","title":"elink(url, [display])"},{"location":"reference/functions/#typeofany","text":"Get the type of any object for inspection. Can be used in conjunction with other operators to change behavior based on type. typeof(8) => \"number\" typeof(\"text\") => \"string\" typeof([1, 2, 3]) => \"array\" typeof({ a: 1, b: 2 }) => \"object\" typeof(date(2020-01-01)) => \"date\" typeof(dur(8 minutes)) => \"duration\"","title":"typeof(any)"},{"location":"reference/functions/#numeric-operations","text":"","title":"Numeric Operations"},{"location":"reference/functions/#roundnumber-digits","text":"Round a number to a given number of digits. If the second argument is not specified, rounds to the nearest whole number; otherwise, rounds to the given number of digits. round(16.555555) = 7 round(16.555555, 2) = 16.56","title":"round(number, [digits])"},{"location":"reference/functions/#product","text":"Calculates the product of a list of numbers. product([1,2,3]) = 6 --","title":"product()"},{"location":"reference/functions/#objects-arrays-and-string-operations","text":"Operations that manipulate values inside of container objects.","title":"Objects, Arrays, and String Operations"},{"location":"reference/functions/#contains-and-friends","text":"For a quick summary, here are some examples: contains(\"Hello\", \"Lo\") = false contains(\"Hello\", \"lo\") = true icontains(\"Hello\", \"Lo\") = true icontains(\"Hello\", \"lo\") = true econtains(\"Hello\", \"Lo\") = false econtains(\"Hello\", \"lo\") = true econtains([\"this\",\"is\",\"example\"], \"ex\") = false econtains([\"this\",\"is\",\"example\"], \"is\") = true","title":"contains() and friends"},{"location":"reference/functions/#containsobjectliststring-value","text":"Checks if the given container type has the given value in it. This function behave slightly differently based on whether the first argument is an object, a list, or a string. This function is case-sensitive. For objects, checks if the object has a key with the given name. For example, contains(file, \"ctime\") = true contains(file, \"day\") = true (if file has a date in its title, false otherwise) For lists, checks if any of the array elements equals the given value. For example, contains(list(1, 2, 3), 3) = true contains(list(), 1) = false For strings, checks if the given value is a substring (i.e., inside) the string. contains(\"hello\", \"lo\") = true contains(\"yes\", \"no\") = false","title":"contains(object|list|string, value)"},{"location":"reference/functions/#icontainsobjectliststring-value","text":"Case insensitive version of contains() .","title":"icontains(object|list|string, value)"},{"location":"reference/functions/#econtainsobjectliststring-value","text":"\"Exact contains\" checks if the exact match is found in the string/list. This function is case sensitive. For strings, it behaves exactly like contains() . econtains(\"Hello\", \"Lo\") = false econtains(\"Hello\", \"lo\") = true For lists, it checks if the exact word is in the list. econtains([\"These\", \"are\", \"words\"], \"word\") = false econtains([\"These\", \"are\", \"words\"], \"words\") = true For objects, it checks if the exact key name is present in the object. It does not do recursive checks. econtains({key:\"value\", pairs:\"here\"}, \"here\") = false econtains({key:\"value\", pairs:\"here\"}, \"key\") = true econtains({key:\"value\", recur:{recurkey: \"val\"}}, \"value\") = false econtains({key:\"value\", recur:{recurkey: \"val\"}}, \"Recur\") = false econtains({key:\"value\", recur:{recurkey: \"val\"}}, \"recurkey\") = false","title":"econtains(object|list|string, value)"},{"location":"reference/functions/#containswordliststring-value","text":"Checks if value has an exact word match in string or list . This is case insensitive. The outputs are different for different types of input, see examples. For strings, it checks if the word is present in the given string. containsword(\"word\", \"word\") = true containsword(\"word\", \"Word\") = true containsword(\"words\", \"Word\") = false containsword(\"Hello there!, \"hello\") = true containsword(\"Hello there!, \"HeLLo\") = true containsword(\"Hello there chaps!, \"chap\") = false containsword(\"Hello there chaps!, \"chaps\") = true For lists, it returns a list of booleans indicating if the word's exact case insensitive match was found. containsword([\"I have no words.\", \"words\"], \"Word\") = [false, false] containsword([\"word\", \"Words\"], \"Word\") = [true, false] containsword([\"Word\", \"Words in word\"], \"WORD\") = [true, true]","title":"containsword(list|string, value)"},{"location":"reference/functions/#extractobject-key1-key2","text":"Pulls multiple fields out of an object, creating a new object with just those fields. extract(file, \"ctime\", \"mtime\") = object(\"ctime\", file.ctime, \"mtime\", file.mtime) extract(object(\"test\", 1)) = object()","title":"extract(object, key1, key2, ...)"},{"location":"reference/functions/#sortlist","text":"Sorts a list, returning a new list in sorted order. sort(list(3, 2, 1)) = list(1, 2, 3) sort(list(\"a\", \"b\", \"aa\")) = list(\"a\", \"aa\", \"b\")","title":"sort(list)"},{"location":"reference/functions/#reverselist","text":"Reverses a list, returning a new list in reversed order. reverse(list(1, 2, 3)) = list(3, 2, 1) reverse(list(\"a\", \"b\", \"c\")) = list(\"c\", \"b\", \"a\")","title":"reverse(list)"},{"location":"reference/functions/#lengthobjectarray","text":"Returns the number of fields in an object, or the number of entries in an array. length(list()) = 0 length(list(1, 2, 3)) = 3 length(object(\"hello\", 1, \"goodbye\", 2)) = 2","title":"length(object|array)"},{"location":"reference/functions/#sumarray","text":"Sums all numeric values in the array sum(list(1, 2, 3)) = 6","title":"sum(array)"},{"location":"reference/functions/#allarray","text":"Returns true only if ALL values in the array are truthy. You can also pass multiple arguments to this function, in which case it returns true only if all arguments are truthy. all(list(1, 2, 3)) = true all(list(true, false)) = false all(true, false) = false all(true, true, true) = true You can pass a function as second argument to return only true if all elements in the array matches the predicate. all(list(1, 2, 3), (x) => x > 0) = true all(list(1, 2, 3), (x) => x > 1) = false all(list(\"apple\", \"pie\", 3), (x) => typeof(x) = \"string\") = false","title":"all(array)"},{"location":"reference/functions/#anyarray","text":"Returns true if ANY of the values in the array are truthy. You can also pass multiple arguments to this function, in which case it returns true if any of the arguments are truthy. any(list(1, 2, 3)) = true any(list(true, false)) = true any(list(false, false, false)) = false any(true, false) = true any(false, false) = false You can pass a function as second argument to return only true if any element in the array matches the predicate. any(list(1, 2, 3), (x) => x > 2) = true any(list(1, 2, 3), (x) => x = 0) = false","title":"any(array)"},{"location":"reference/functions/#nonearray","text":"Returns true if NONE of the values in the array are truthy. none([]) = true none([false, false]) = true none([false, true]) = false none([1, 2, 3]) = false You can pass a function as second argument to return only true if none of the elements in the array matches the predicate. none([1, 2, 3], (x) => x = 0) = true none([true, true], (x) => x = false) = true none([\"Apple\", \"Pi\", \"Banana\"], (x) => startswith(x, \"A\")) = false","title":"none(array)"},{"location":"reference/functions/#joinarray","text":"Joins elements in an array into a single string (i.e., rendering them all on the same line). If provided with a second argument, then each element will be separated by the given separator. join(list(1, 2, 3)) = \"1, 2, 3\" join(list(1, 2, 3), \" \") = \"1 2 3\" join(6) = \"6\" join(list()) = \"\"","title":"join(array)"},{"location":"reference/functions/#filterarray-predicate","text":"Filters elements in an array according to the predicate, returning a new list of the elements which matched. filter([1, 2, 3], (x) => x >= 2) = [2, 3] filter([\"yes\", \"no\", \"yas\"], (x) => startswith(x, \"y\")) = [\"yes\", \"yas\"]","title":"filter(array, predicate)"},{"location":"reference/functions/#maparray-func","text":"Applies the function to each element in the array, returning a list of the mapped results. map([1, 2, 3], (x) => x + 2) = [3, 4, 5] map([\"yes\", \"no\"], (x) => x + \"?\") = [\"yes?\", \"no?\"]","title":"map(array, func)"},{"location":"reference/functions/#string-operations","text":"","title":"String Operations"},{"location":"reference/functions/#regexmatchpattern-string","text":"Checks if the given string matches the given pattern (using the JavaScript regex engine). regexmatch(\"\\w+\", \"hello\") = true regexmatch(\".\", \"a\") = true regexmatch(\"yes|no\", \"maybe\") = false","title":"regexmatch(pattern, string)"},{"location":"reference/functions/#regexreplacestring-pattern-replacement","text":"Replaces all instances where the regex pattern matches in string , with replacement . This uses the JavaScript replace method under the hood, so you can use special characters like $1 to refer to the first capture group, and so on. regexreplace(\"yes\", \"[ys]\", \"a\") = \"aea\" regexreplace(\"Suite 1000\", \"\\d+\", \"-\") = \"Suite -\"","title":"regexreplace(string, pattern, replacement)"},{"location":"reference/functions/#replacestring-pattern-replacement","text":"Replace all instances of pattern in string with replacement . replace(\"what\", \"wh\", \"h\") = \"hat\" replace(\"The big dog chased the big cat.\", \"big\", \"small\") = \"The small dog chased the small cat.\" replace(\"test\", \"test\", \"no\") = \"no\"","title":"replace(string, pattern, replacement)"},{"location":"reference/functions/#lowerstring","text":"Convert a string to all lower case. lower(\"Test\") = \"test\" lower(\"TEST\") = \"test\"","title":"lower(string)"},{"location":"reference/functions/#upperstring","text":"Convert a string to all upper case. upper(\"Test\") = \"TEST\" upper(\"test\") = \"TEST\"","title":"upper(string)"},{"location":"reference/functions/#splitstring-delimiter-limit","text":"Split a string on the given delimiter string. If a third argument is provided, it limits the number of splits that occur. The delimiter string is interpreted as a regular expression. If there are capture groups in the delimiter, matches are spliced into the result array, and non-matching captures are empty strings. split(\"hello world\", \" \") = list(\"hello\", \"world\") split(\"hello world\", \"\\s\") = list(\"hello\", \"world\") split(\"hello there world\", \" \", 2) = list(\"hello\", \"there\") split(\"hello there world\", \"(t?here)\") = list(\"hello \", \"there\", \" world\") split(\"hello there world\", \"( )(x)?\") = list(\"hello\", \" \", \"\", \"there\", \" \", \"\", \"world\")","title":"split(string, delimiter, [limit])"},{"location":"reference/functions/#startswithstring-prefix","text":"Checks if a string starts with the given prefix. startswith(\"yes\", \"ye\") = true startswith(\"path/to/something\", \"path/\") = true startswith(\"yes\", \"no\") = false","title":"startswith(string, prefix)"},{"location":"reference/functions/#endswithstring-suffix","text":"Checks if a string ends with the given suffix. endswith(\"yes\", \"es\") = true endswith(\"path/to/something\", \"something\") = true endswith(\"yes\", \"ye\") = false","title":"endswith(string, suffix)"},{"location":"reference/functions/#padleftstring-length-padding","text":"Pads a string up to the desired length by adding padding on the left side. If you omit the padding character, spaces will be used by default. padleft(\"hello\", 7) = \" hello\" padleft(\"yes\", 5, \"!\") = \"!!yes\"","title":"padleft(string, length, [padding])"},{"location":"reference/functions/#padrightstring-length-padding","text":"Equivalent to padleft , but pads to the right instead. padright(\"hello\", 7) = \"hello \" padright(\"yes\", 5, \"!\") = \"yes!!\"","title":"padright(string, length, [padding])"},{"location":"reference/functions/#substringstring-start-end","text":"Take a slice of a string, starting at start and ending at end (or the end of the string if unspecified). substring(\"hello\", 0, 2) = \"he\" substring(\"hello\", 2, 4) = \"ll\" substring(\"hello\", 2) = \"llo\" substring(\"hello\", 0) = \"hello\"","title":"substring(string, start, [end])"},{"location":"reference/functions/#truncatestring-length-suffix","text":"Truncate a string to be at most the given length, including the suffix (which defaults to ... ). Generally useful to cut off long text in tables. truncate(\"Hello there!\", 8) = \"Hello...\" truncate(\"Hello there!\", 8, \"/\") = \"Hello t/\" truncate(\"Hello there!\", 10) = \"Hello t...\" truncate(\"Hello there!\", 10, \"!\") = \"Hello the!\" truncate(\"Hello there!\", 20) = \"Hello there!\"","title":"truncate(string, length, [suffix])"},{"location":"reference/functions/#utility-functions","text":"","title":"Utility Functions"},{"location":"reference/functions/#defaultfield-value","text":"If field is null, return value ; otherwise return field . Useful for replacing null values with defaults. For example, to show projects which haven't been completed yet, use \"incomplete\" as their defualt value: default(dateCompleted, \"incomplete\") Default is vectorized in both arguments; if you need to use default explicitly on a list argument, use ldefault , which is the same as default but is not vectorized. default(list(1, 2, null), 3) = list(1, 2, 3) ldefault(list(1, 2, null), 3) = list(1, 2, null)","title":"default(field, value)"},{"location":"reference/functions/#choicebool-left-right","text":"A primitive if statement - if the first argument is truthy, returns left; otherwise, returns right. choice(true, \"yes\", \"no\") = \"yes\" choice(false, \"yes\", \"no\") = \"no\" choice(x > 4, y, z) = y if x > 4, else z","title":"choice(bool, left, right)"},{"location":"reference/functions/#striptimedate","text":"Strip the time component of a date, leaving only the year, month, and day. Good for date comparisons if you don't care about the time. striptime(file.ctime) = file.cday striptime(file.mtime) = file.mday","title":"striptime(date)"},{"location":"reference/functions/#dateformatdatedatetime-string","text":"Format a Dataview date using a formatting string. Uses Luxon tokens . dateformat(file.ctime,\"yyyy-MM-dd\") = \"2022-01-05\" dateformat(file.ctime,\"HH:mm:ss\") = \"12:18:04\" dateformat(date(now),\"x\") = \"1407287224054\" dateformat(file.mtime,\"ffff\") = \"Wednesday, August 6, 2014, 1:07 PM Eastern Daylight Time\"","title":"dateformat(date|datetime, string)"},{"location":"reference/functions/#localtimedate","text":"Converts a date in a fixed timezone to a date in the current timezone.","title":"localtime(date)"},{"location":"reference/functions/#metalink","text":"Get an object containing metadata of a link. When you access a property on a link what you get back is the property value from the linked file. The meta function makes it possible to access properties of the link itself. There are several properties on the object returned by meta :","title":"meta(link)"},{"location":"reference/functions/#metalinkdisplay","text":"Get the display text of a link, or null if the link does not have defined display text. meta([[2021-11-01|Displayed link text]]).display = \"Displayed link text\" meta([[2021-11-01]]).display = null","title":"meta(link).display"},{"location":"reference/functions/#metalinkembed","text":"True or false depending on whether the link is an embed. Those are links that begin with an exclamation mark, like ![[Some Link]] .","title":"meta(link).embed"},{"location":"reference/functions/#metalinkpath","text":"Get the path portion of a link. meta([[My Project]]).path = \"My Project\" meta([[My Project#Next Actions]]).path = \"My Project\" meta([[My Project#^9bcbe8]]).path = \"My Project\"","title":"meta(link).path"},{"location":"reference/functions/#metalinksubpath","text":"Get the subpath of a link. For links to a heading within a file the subpath will be the text of the heading. For links to a block the subpath will be the block ID. If neither of those cases applies then the subpath will be null. meta([[My Project#Next Actions]]).subpath = \"Next Actions\" meta([[My Project#^9bcbe8]]).subpath = \"9bcbe8\" meta([[My Project]]).subpath = null This can be used to select tasks under specific headings. ```dataview task where meta(section).subpath = \"Next Actions\" ```","title":"meta(link).subpath"},{"location":"reference/functions/#metalinktype","text":"Has the value \"file\", \"header\", or \"block\" depending on whether the link links to an entire file, a heading within a file, or to a block within a file. meta([[My Project]]).type = \"file\" meta([[My Project#Next Actions]]).type = \"header\" meta([[My Project#^9bcbe8]]).type = \"block\"","title":"meta(link).type"},{"location":"reference/literals/","text":"Literals Dataview query language literals are expressions which represent constant values like \"hello\" or 1337 . The following is an extensive, but non-exhaustive list of possible literals in DQL. General Literal Description 0 The number zero 1337 A positive number -1337 A negative number \"The quick brown fox jumps over the lazy dog\" Some text, commonly referred to by programmers as a string [[Link]] A link to the file named \"Link\" [[]] A link to the current file [1, 2, 3] A list of numbers 1, 2, and 3 [[1, 2],[3, 4]] A list of lists { a: 1, b: 2 } An object Dates Note that date() is also a function , which can be called on text to extract dates. Literal Description date(2021-11-11) A date, November 11th, 2021 date(today) A date representing the current date date(now) A date representing the current date and time date(tomorrow) A date representing tomorrow's date date(yesterday) A date representing yesterday's date date(sow) A date representing the start of the current week date(eow) A date representing the end of the current week date(som) A date representing the start of the current month date(eom) A date representing the end of the current month date(soy) A date representing the start of the current year date(eoy) A date representing the end of the current year Durations Seconds Literal Description dur(1 s) one second dur(3 s) three seconds dur(1 sec) one second dur(3 secs) three seconds dur(1 second) one second dur(3 seconds) three seconds Minutes Literal Description dur(1 m) one minute dur(3 m) three minutes dur(1 min) one minute dur(3 mins) three minutes dur(1 minute) one minute dur(3 minutes) three minutes Hours Literal Description dur(1 h) one hour dur(3 h) three hours dur(1 hr) one hour dur(3 hrs) three hours dur(1 hour) one hour dur(3 hours) three hours Days Literal Description dur(1 d) one day dur(3 d) three days dur(1 day) one day dur(3 days) three days Weeks Literal Description dur(1 w) one week dur(3 w) three weeks dur(1 wk) one week dur(3 wks) three weeks dur(1 week) one week dur(3 weeks) three weeks Months Literal Description dur(1 mo) one month dur(3 mo) three month dur(1 month) one month dur(3 months) three months Years Literal Description dur(1 yr) one year dur(3 yrs) three years dur(1 year) one year dur(3 years) three years Combinations Literal Description dur(1 s, 2 m, 3 h) three hours, two minutes, and one second dur(1 s 2 m 3 h) three hours, two minutes, and one second dur(1s 2m 3h) three hours, two minutes, and one second dur(1second 2min 3h) three hours, two minutes, and one second","title":"Literals"},{"location":"reference/literals/#literals","text":"Dataview query language literals are expressions which represent constant values like \"hello\" or 1337 . The following is an extensive, but non-exhaustive list of possible literals in DQL.","title":"Literals"},{"location":"reference/literals/#general","text":"Literal Description 0 The number zero 1337 A positive number -1337 A negative number \"The quick brown fox jumps over the lazy dog\" Some text, commonly referred to by programmers as a string [[Link]] A link to the file named \"Link\" [[]] A link to the current file [1, 2, 3] A list of numbers 1, 2, and 3 [[1, 2],[3, 4]] A list of lists { a: 1, b: 2 } An object","title":"General"},{"location":"reference/literals/#dates","text":"Note that date() is also a function , which can be called on text to extract dates. Literal Description date(2021-11-11) A date, November 11th, 2021 date(today) A date representing the current date date(now) A date representing the current date and time date(tomorrow) A date representing tomorrow's date date(yesterday) A date representing yesterday's date date(sow) A date representing the start of the current week date(eow) A date representing the end of the current week date(som) A date representing the start of the current month date(eom) A date representing the end of the current month date(soy) A date representing the start of the current year date(eoy) A date representing the end of the current year","title":"Dates"},{"location":"reference/literals/#durations","text":"","title":"Durations"},{"location":"reference/literals/#seconds","text":"Literal Description dur(1 s) one second dur(3 s) three seconds dur(1 sec) one second dur(3 secs) three seconds dur(1 second) one second dur(3 seconds) three seconds","title":"Seconds"},{"location":"reference/literals/#minutes","text":"Literal Description dur(1 m) one minute dur(3 m) three minutes dur(1 min) one minute dur(3 mins) three minutes dur(1 minute) one minute dur(3 minutes) three minutes","title":"Minutes"},{"location":"reference/literals/#hours","text":"Literal Description dur(1 h) one hour dur(3 h) three hours dur(1 hr) one hour dur(3 hrs) three hours dur(1 hour) one hour dur(3 hours) three hours","title":"Hours"},{"location":"reference/literals/#days","text":"Literal Description dur(1 d) one day dur(3 d) three days dur(1 day) one day dur(3 days) three days","title":"Days"},{"location":"reference/literals/#weeks","text":"Literal Description dur(1 w) one week dur(3 w) three weeks dur(1 wk) one week dur(3 wks) three weeks dur(1 week) one week dur(3 weeks) three weeks","title":"Weeks"},{"location":"reference/literals/#months","text":"Literal Description dur(1 mo) one month dur(3 mo) three month dur(1 month) one month dur(3 months) three months","title":"Months"},{"location":"reference/literals/#years","text":"Literal Description dur(1 yr) one year dur(3 yrs) three years dur(1 year) one year dur(3 years) three years","title":"Years"},{"location":"reference/literals/#combinations","text":"Literal Description dur(1 s, 2 m, 3 h) three hours, two minutes, and one second dur(1 s 2 m 3 h) three hours, two minutes, and one second dur(1s 2m 3h) three hours, two minutes, and one second dur(1second 2min 3h) three hours, two minutes, and one second","title":"Combinations"},{"location":"reference/sources/","text":"Sources A dataview \"source\" is something that identifies a set of files, tasks, or other data object. Sources are indexed internally by Dataview, so they are fast to query. Dataview currently supports four source types: Tags : Sources of the form #tag . These match all files / sections / tasks with the given tag. Folders : Sources of the form \"folder\" . These match all files / sections / tasks contained in the given folder. The full vault path is expected instead of just the folder name. Note that trailing slashes are not supported, i.e. \"Path/To/Folder/\" will not work but \"Path/To/Folder\" will. Specific Files : You can select from a specific file by specifying it's full path: \"folder/File\" . If you have both a file and a folder with the exact same path, Dataview will prefer the folder. You can force it to read from the file by specifying an extension: folder/File.md . Links : You can either select links to a file, or all links from a file. To obtain all pages which link to [[note]] , use [[note]] . To obtain all pages which link from [[note]] (i.e., all the links in that file), use outgoing([[note]]) . You can implicitly reference the current file via [[#]] or [[]] , i.e. [[]] lets you query from all files linking to the current file. You can compose these filters in order to get more advanced sources using and and or . For example, #tag and \"folder\" will return all pages in folder and with #tag . Querying from #food and !#fastfood will only return pages that contain #food but does not contain #fastfood . [[Food]] or [[Exercise]] will give any pages which link to [[Food]] OR [[Exercise]] . If you have complex queries where grouping or predecence matters, you can use parenthesis to logically group them: #tag and (\"folder\" or #other-tag) (#tag1 or #tag2) and (#tag3 or #tag4) Sources are used in both the FROM query statement , as well as various JavaScript API query calls.","title":"Sources"},{"location":"reference/sources/#sources","text":"A dataview \"source\" is something that identifies a set of files, tasks, or other data object. Sources are indexed internally by Dataview, so they are fast to query. Dataview currently supports four source types: Tags : Sources of the form #tag . These match all files / sections / tasks with the given tag. Folders : Sources of the form \"folder\" . These match all files / sections / tasks contained in the given folder. The full vault path is expected instead of just the folder name. Note that trailing slashes are not supported, i.e. \"Path/To/Folder/\" will not work but \"Path/To/Folder\" will. Specific Files : You can select from a specific file by specifying it's full path: \"folder/File\" . If you have both a file and a folder with the exact same path, Dataview will prefer the folder. You can force it to read from the file by specifying an extension: folder/File.md . Links : You can either select links to a file, or all links from a file. To obtain all pages which link to [[note]] , use [[note]] . To obtain all pages which link from [[note]] (i.e., all the links in that file), use outgoing([[note]]) . You can implicitly reference the current file via [[#]] or [[]] , i.e. [[]] lets you query from all files linking to the current file. You can compose these filters in order to get more advanced sources using and and or . For example, #tag and \"folder\" will return all pages in folder and with #tag . Querying from #food and !#fastfood will only return pages that contain #food but does not contain #fastfood . [[Food]] or [[Exercise]] will give any pages which link to [[Food]] OR [[Exercise]] . If you have complex queries where grouping or predecence matters, you can use parenthesis to logically group them: #tag and (\"folder\" or #other-tag) (#tag1 or #tag2) and (#tag3 or #tag4) Sources are used in both the FROM query statement , as well as various JavaScript API query calls.","title":"Sources"}]}