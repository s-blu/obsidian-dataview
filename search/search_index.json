{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Overview Dataview is a live index and query engine over your personal knowledge base. You can add metadata to your notes and query them with the Dataview Query Language to list, filter, sort or group your data. Dataview keeps your queries always up to date and makes data aggregation a breeze. You could Track your sleep by recording it in daily notes, and automatically create weekly tables of your sleep schedule. Automatically collect links to books in your notes, and render them all sorted by rating. Automatically collect pages associated with today's date and show them in your daily note. Find pages with no tags for follow-up, or show pretty views of specifically-tagged pages. Create dynamic views which show upcoming birthdays or events recorded in your notes and many more things. Dataview gives you a fast way to search, display and operate on indexed data in your vault! Dataview is highly generic and high performance, scaling up to hundreds of thousands of annotated notes without issue. If the built in query language is insufficient for your purpose, you can run arbitrary JavaScript against the dataview API and build whatever utility you might need yourself, right in your notes. Dataview is about displaying, not editing Dataview is meant for displaying and calculating data. It is not meant to edit your notes/metadata and will always leave them untouched (... except if you're checking a Task through Dataview.) How to Use Dataview Dataview consists of two big building blocks: Data Indexing and Data Querying . More details on the linked documentation pages The following sections should give you a general overview about what you can do with dataview and how. Be sure to visit the linked pages to find out more about the individual parts. Data Indexing Dataview operates on metadata in your Markdown files. It cannot read everything in your vault, but only specific data. Some of your content, like tags and bullet points (including tasks), are available automatically in Dataview. You can add other data through fields , either on top of your file per YAML Frontmatter or in the middle of your content with Inline Fields via the [key:: value] syntax. Dataview indexes these data to make it available for you to query. Dataview indexes certain information like tags and list items and the data you add via fields. Only indexed data is available in a Dataview query! For example, a file might look like this: --- author: \"Edgar Allan Poe\" published: 1845 tags: poems --- # The Raven Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore\u2014 Or like this: #poems # The Raven From [author:: Edgar Allan Poe], written in (published:: 1845) Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore\u2014 In terms of indexed metadata (or what you can query), they are identical, and only differ in their annotation style. How you want to annotate your metadata is up to you and your personal preference. With this file, you'd have the metadata field author available and everything Dataview provides you automatically as implicit fields , like the tag or note title. Data needs to be indexed In the above example, you do not have the poem itself available in Dataview: It is a paragraph, no metadata field and nothing Dataview indexes automatically. It is not part of Dataviews index, so you won't be able to query it. Data Querying You can access indexed data with the help of Queries . There are three different ways you can write a Query: With help of the Dataview Query Language , as an inline statement or in the most flexible but most complex way: as a Javascript Query . The Dataview Query Language ( DQL ) gives you a broad and powerful toolbelt to query, display and operate on your data. An inline query gives you the possibility to display exactly one indexed value anywhere in your note. You can also do calculations this way. With DQL at your hands, you'll be probably fine without any Javascript throurough your data journey. A DQL Query consists of several parts: Exactly one Query Type that determines what your Query Output looks like None or one FROM statement to pick a specific tag or folder (or another source ) to look at None to multiple other Data Commands that help you filter, group and sort your wanted output For example, a Query can look like this: ```dataview LIST ``` which list all files in your vault. Everything but the Query Type is optional The only thing you need for a valid DQL Query is the Query Type (and on CALENDAR s, a date field.) A more restricted Query might look like this: ```dataview LIST FROM #poems WHERE author = \"Edgar Allan Poe\" ``` which lists all files in your vault that have the tag #poems and a field named author with the value Edgar Allan Poe . This query would find our example page from above. LIST is only one out of four Query Types you can use. For example, with a TABLE , we could add some more information to our output: ```dataview TABLE author, published, file.inlinks AS \"Mentions\" FROM #poems ``` This'll give you back a result like: File (3) author published Mentions The Bells Edgar Allan Poe 1849 The New Colossus Emma Lazarus 1883 - [[Favorite Poems]] The Raven Edgar Allan Poe 1845 - [[Favorite Poems]] That's not where the capabilities of dataview end, though. You can also operate on your data with help of functions . Mind that these operations are only made inside your query - your data in your files stays untouched . ```dataview TABLE author, date(now).year - published AS \"Age in Yrs\", length(file.inlinks) AS \"Counts of Mentions\" FROM #poems ``` gives you back File (3) author Age in Yrs Count of Mentions The Bells Edgar Allan Poe 173 0 The New Colossus Emma Lazarus 139 1 The Raven Edgar Allan Poe 177 1 Find more examples here . As you can see, dataview doesn't only allow you to aggregate your data swiftly and always up to date, it also can help you with operations to give you new insights on your dataset. Browse through the documentation to find out more on how to interact with your data. Have fun exploring your vault in new ways! Resources and Help This documentation is not the only place that can help you out on your data journey. Take a look at Resources and Support for a list of helpful pages and videos.","title":"Overview"},{"location":"#overview","text":"Dataview is a live index and query engine over your personal knowledge base. You can add metadata to your notes and query them with the Dataview Query Language to list, filter, sort or group your data. Dataview keeps your queries always up to date and makes data aggregation a breeze. You could Track your sleep by recording it in daily notes, and automatically create weekly tables of your sleep schedule. Automatically collect links to books in your notes, and render them all sorted by rating. Automatically collect pages associated with today's date and show them in your daily note. Find pages with no tags for follow-up, or show pretty views of specifically-tagged pages. Create dynamic views which show upcoming birthdays or events recorded in your notes and many more things. Dataview gives you a fast way to search, display and operate on indexed data in your vault! Dataview is highly generic and high performance, scaling up to hundreds of thousands of annotated notes without issue. If the built in query language is insufficient for your purpose, you can run arbitrary JavaScript against the dataview API and build whatever utility you might need yourself, right in your notes. Dataview is about displaying, not editing Dataview is meant for displaying and calculating data. It is not meant to edit your notes/metadata and will always leave them untouched (... except if you're checking a Task through Dataview.)","title":"Overview"},{"location":"#how-to-use-dataview","text":"Dataview consists of two big building blocks: Data Indexing and Data Querying . More details on the linked documentation pages The following sections should give you a general overview about what you can do with dataview and how. Be sure to visit the linked pages to find out more about the individual parts.","title":"How to Use Dataview"},{"location":"#data-indexing","text":"Dataview operates on metadata in your Markdown files. It cannot read everything in your vault, but only specific data. Some of your content, like tags and bullet points (including tasks), are available automatically in Dataview. You can add other data through fields , either on top of your file per YAML Frontmatter or in the middle of your content with Inline Fields via the [key:: value] syntax. Dataview indexes these data to make it available for you to query. Dataview indexes certain information like tags and list items and the data you add via fields. Only indexed data is available in a Dataview query! For example, a file might look like this: --- author: \"Edgar Allan Poe\" published: 1845 tags: poems --- # The Raven Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore\u2014 Or like this: #poems # The Raven From [author:: Edgar Allan Poe], written in (published:: 1845) Once upon a midnight dreary, while I pondered, weak and weary, Over many a quaint and curious volume of forgotten lore\u2014 In terms of indexed metadata (or what you can query), they are identical, and only differ in their annotation style. How you want to annotate your metadata is up to you and your personal preference. With this file, you'd have the metadata field author available and everything Dataview provides you automatically as implicit fields , like the tag or note title. Data needs to be indexed In the above example, you do not have the poem itself available in Dataview: It is a paragraph, no metadata field and nothing Dataview indexes automatically. It is not part of Dataviews index, so you won't be able to query it.","title":"Data Indexing"},{"location":"#data-querying","text":"You can access indexed data with the help of Queries . There are three different ways you can write a Query: With help of the Dataview Query Language , as an inline statement or in the most flexible but most complex way: as a Javascript Query . The Dataview Query Language ( DQL ) gives you a broad and powerful toolbelt to query, display and operate on your data. An inline query gives you the possibility to display exactly one indexed value anywhere in your note. You can also do calculations this way. With DQL at your hands, you'll be probably fine without any Javascript throurough your data journey. A DQL Query consists of several parts: Exactly one Query Type that determines what your Query Output looks like None or one FROM statement to pick a specific tag or folder (or another source ) to look at None to multiple other Data Commands that help you filter, group and sort your wanted output For example, a Query can look like this: ```dataview LIST ``` which list all files in your vault. Everything but the Query Type is optional The only thing you need for a valid DQL Query is the Query Type (and on CALENDAR s, a date field.) A more restricted Query might look like this: ```dataview LIST FROM #poems WHERE author = \"Edgar Allan Poe\" ``` which lists all files in your vault that have the tag #poems and a field named author with the value Edgar Allan Poe . This query would find our example page from above. LIST is only one out of four Query Types you can use. For example, with a TABLE , we could add some more information to our output: ```dataview TABLE author, published, file.inlinks AS \"Mentions\" FROM #poems ``` This'll give you back a result like: File (3) author published Mentions The Bells Edgar Allan Poe 1849 The New Colossus Emma Lazarus 1883 - [[Favorite Poems]] The Raven Edgar Allan Poe 1845 - [[Favorite Poems]] That's not where the capabilities of dataview end, though. You can also operate on your data with help of functions . Mind that these operations are only made inside your query - your data in your files stays untouched . ```dataview TABLE author, date(now).year - published AS \"Age in Yrs\", length(file.inlinks) AS \"Counts of Mentions\" FROM #poems ``` gives you back File (3) author Age in Yrs Count of Mentions The Bells Edgar Allan Poe 173 0 The New Colossus Emma Lazarus 139 1 The Raven Edgar Allan Poe 177 1 Find more examples here . As you can see, dataview doesn't only allow you to aggregate your data swiftly and always up to date, it also can help you with operations to give you new insights on your dataset. Browse through the documentation to find out more on how to interact with your data. Have fun exploring your vault in new ways!","title":"Data Querying"},{"location":"#resources-and-help","text":"This documentation is not the only place that can help you out on your data journey. Take a look at Resources and Support for a list of helpful pages and videos.","title":"Resources and Help"},{"location":"changelog/","text":"0.5.51 (Beta) Allow disabling regular Dataview inline queries via configuration option. 0.5.50 (Beta) Expose dataview EXPRESSION and QUERY parsing to the dataview npm plugin, so others can parse dataview ASTs. Fix documentation issue with join . 0.5.49 (Beta) Add the average function to compute averages of lists ( average([list of things]) ). Added documentation for average , min , max , minby , and maxby functions. Fixed the broken nonnull function and documented it. 0.5.48 (Beta) We're back to more regular beta releases while I trial out new functionality! Fixed broken list behavior for dv.markdownTaskList . @GamerGirlandCo: Better handling of block IDs when checking off tasks! @s-blu and @AB1908: Lots of big documentation upgrades! Nice! @leoccyao: More block ID task checking fixes. Should work after this one. Add expression/query parsing to the dataview NPM package. @charleshan: Fix a missing header level in the dataview dv.header example. 0.5.47 Improves date + duration behavior when either the date or duration are null. 0.5.46 Fix #1412: Fix bad file.cday and file.ctime comparisons due to wrong timezone being set. Ugh. 0.5.45 1400: Properly use the group by field for the group name. Fix bad table highlighting in some themes. 0.5.44 1404: Fixed dates in non-local timezones parsing incorrectly. Fixed some build non-determinism issues. Swapped to pull requests for adding new functionality, and added some more internal tests. 0.5.43 Fix #1366: Better handling of calendar emoji (used as due dates in tasks). 0.5.42 It's been over a month since the last release! Anyway, this release bundles several nice user-contributed features: @AB1908: Tag queries are now case insensitive. @AB1908: Shift-clicking a link/task to open in a new tab now works properly on Mac. @AB1908: Numerous documentation fixes for clarity and more examples. @AnnaKornfeldSimpson: Additional emoji shorthands for more task fields (finished, due). @ooker777: Documentation improvements for some DataviewJS functions, and the ability to use inline emoji for the completion tracking feature. @mt-krainski: Custom date formats for task completions. @gentlegiantJGC: Better support for nested inline fields (i.e., less crashy). 0.5.41 Fix a bad regex doing escaping in markdown tables. Improve async documentation. 0.5.40 Adds some more documentation about the new markdown functionality. 0.5.39 Fixed an issue where checking a task in a task view would check the wrong box visually. Added experimental plugin APIs for querying dataview directly as markdown, and converting dataview results to properly formatted markdown. 0.5.38 Some minor documentation improvements. Fix an issue with inline fields rendering out of order. That was a weird bug. 0.5.37 Fixes inline field rendering to once again work for highlighting/links, as well as some other rendering quirks with inline queries in codeblocks. 0.5.36 Fix a bug when checking if an element is an HTMLElement. Properly include the nice improvements to the file count in tables and lists. 0.5.35 Fix #1196, #1176: Re-enable HTML values. This was never a featured I advertised since it was just for some internal hackery, but it appears people just discovered it in DataviewJS queries. Improved initial time to popular queries that use file.starred . 0.5.34 Fix #1174: Fix indexing with a variable. Fix an issue with the experimental calendar view. 0.5.33 Fix a bug with inline views that was introduced in 0.5.32. 0.5.32 The Dataview API has been noticably revamped - there are now approximately twice as many functions available on the plugin API as there were before, and some additional utilities have been added to both the plugin and inline API. I will be finishing up the associated new \"extension\" functionality shortly, which will allow: For custom Dataview + DataviewJS functions to be added via plugins. For custom renderable objects (progress bars, embedded task lists, embedded tables) to be added to any Dataview view via plugins. For plugins to provide alternative behavior for some dataview functionality (such as integrating task plugins with the dataview task query). As part of the API revamp, it is now possible to programmatically execute Dataview and DataviewJS queries - either for using the existing Dataview query language in your own plugin, or for embedding dataview. The Dataview npm library also now exposes many useful internal Dataview types, including the AST structure for all dataview queries. I am hoping that cleaning up the Dataview API and making it much more extensible will allow for Dataview to integrate much better with existing plugins, and to provide the full power of the in-memory index for plugins. I have been very carefully watching index performance in recent weeks to ensure smooth frontend performance for anyone using the API (with a goal of <10ms for most queries). 0.5.31 Tasks now have an outlinks list field which includes all links in the task; this can be used for finding tasks with links in them. 0.5.30 Added the typeof(any) function in Dataview, which obtains the type of any value for comparison: typeof ( \"text\" ) = \"string\" typeof ( 1 ) = \"number\" typeof ([ 1 , 2 , 3 ]) = \"array\" Added the modulo operator ( % ) for doing integer division remainder. I.e., 14 % 2 = 0 and 14 % 3 = 2 . Fixed some minor spacing issues with lists in tables. 0.5.29 Fix another subtle incompatibility between 0.4.26 and 0.5.29 - if you frequently used empty inline fields (like Key:: with no value), the 0.5+ behavior is now the same as 0.4 behavior and will map such fields to null instead of an empty string. This may fix a broad variety of \"subtly wrong\" queries that you may have seen after the upgrade. 0.5.28 Fix a bug with some more string concatenations and null handling. 0.5.27 More performance + correctness bugfixes. The parser has been made a little more robust to prevent major indexing issues (or at least recover from them quickly). Several new strange tag variants are now supported. Markdown links are now properly indexed again. Some DataviewJS performance issues should be resolved now, especially for external plugins using Dataview. This fix does involve a slight API break w.r.t. what types are wrapped into Dataview Arrays (which provide functions like .where() ). Generally, only Dataview-provided implicits are wrapped in data arrays now; frontmatter and inline fields are always now regular JS arrays - use dv.array() to explicitly make a data array if you want the advanced querying. 0.5.26 More small bugfixes: Fix a few small link rendering issues. Tag extraction from tasks now handles punctuation properly. Upgrade luxon (which is embedded in DataviewJS) to 2.4.0. 0.5.25 Fix #1147: Fix there being a #null tag for files with an empty tag or tags frontmatter. 0.5.24 Several bugfixes: Nulls are now sorted first rather than last; it's generally good practice to explicitly check for nulls in your queries to avoid strange behavior. Dataview now properly parses space-delimited tags (like tags: abc def ghi ). Dataview now supports dropping the entire file cache in case of bugs. 0.5.23 Fix #1140: Force API objects to be arrays if they are iterables. 0.5.22 Fix #1135: Use 'x' instead of 'X' for checkboxes. 0.5.21 A long-overdue swap from the beta branch to the stable branch. The beta branch should not include any (intended) breaking changes, and has some nice performance improvements that come along with it! Here are the major changes: Most views now use React and no longer flicker when updating; this is not the case yet for DataviewJS, which will be getting equivalent treament in the future. Dataview now caches metadata, so Dataview loads are very fast after the first time you open your vault. Dataview still needs to visit every file when you update the plugin version, so that should be the only times you experience slower load times. A brand new task view backend and query which allows you to filter per-task, rather than per-page! Check the documentation for details, but this broadly means WHERE statements now use task properties instead of page properties. Some additional metadata is now available for use - file.starred , file.lists , and more metadata in file.tasks . There have been some moderate documentation touch-ups to keep things up to date; I'm still working on a walkthrough for common Dataview use cases. This review also includes about ~30-40 bugfixes; some new bugs may arise due to internal changes, so please flag them if you encounter them. 0.5.20 (Beta) Slight fix to hopefully improve some strange reported cases of bad indexing at startup. 0.5.19 (Beta) Dataview now uses IndexedDB to cache file metadata, reducing startup time to virtually nothing if you've opened the vault before; if you have a small vault (<1000 notes), you may notice a slight improvement, but large vaults and mobile devices will notice a very significant performance improvement to \"first valid paint\". Some other performance parameters have been tuned to hopefully make the default experience better. A few small bugs related to rendering have also been squashed, including an issue with images being scaled wrongly. 0.5.18 (Beta) Tasks in task views now support alternative task status characters like '!' and '/'; thanks @ebullient. A few documentation nit fixes. Added DataArray#sortInPlace for a more efficient mutable sort for niche use cases. 0.5.17 (Beta) Improved behavior when clicking on tasks in the task view; will now properly scroll to the relevant line in long files! Fixed a bug with incorrect counts being displayed in task views. Added tags as a field available on task items, so you can now do things like TASK WHERE contains(tags, \"#tag\") . 0.5.16 (Beta) Dataview now tracks initialization and will report when all files have been indexed in the console; you can programmatically see this via dataview:index-ready , or by checking api.index.initialized . 0.5.15 (Beta) Add hover highlights to tables to make seeing rows a little easier. Tables and task lists now include counts of the number of results in the headers. Further improved task selection in the task view. 0.5.14 (Beta) Fix task highlighting when not grouping. Remove some spurious console logging. Slightly improve task highlighting behavior when clicking on a task. 0.5.13 (Beta) Several smaller bugfixes! Fix #997: Use the group by field name in the table name. Prevent tons of errors if you incorrectly set the inline query prefix. 0.5.12 (Beta) Improve error messages for queries somewhat and get rid of some ugly output. 0.5.11 (Beta) Add detection of tasks inside of block quotes, as well as correctly implement automatic checking and unchecking of these tasks. 0.5.10 (Beta) Adds the Dataview: Force Refresh Views Command (accessible via the Ctrl+P command view) to force current views to refresh immediately. 0.5.9 (Beta) Another fix for due-date related emoji in tasks. I hate emoji. 0.5.8 (Beta) Fix some issues with infinite loops of tasks due to bad Obsidian metadata (potentially due to being out of date?). 0.5.7 (Beta) Fix issues with parsing '\ud83d\uddd3\ufe0f2021-08-29' due-date annotations on tasks, as well as an issue with properly extracting due/completed/completed times for use in queries. 0.5.6 (Beta) Proper release of 0.5.5 plus one additional small improvement: Add duration * number and duration / number operations for manipulation durations numerically. 0.5.5 (Beta) More small features: Fix issues with task sorting not doing anything. Sort away! Table headers can now be arbitrary markdown. So you can put things like links in your headers: `TABLE (1 + 2) AS \"[[File]]\". You can now specify the size of an image embed by providing WxH in it's display property: ![[image.png|50x50]] . 0.5.4 (Beta) Improved image rendering for some link types, and adds the embed(link) and embed(link, false) options to convert links to/from their embedded equivalents. 0.5.3 (Beta) Iterative beta which adds a few nice QoL features and fixes some more bugs: Internally swapped to a React-based renderer; this should not have a noticeable perf or usability impact, but makes it easier for me to implement complex table/list behaviors. Naming your fields with AS \"Name\" is now optional; Dataview will infer the name from the expression automatically. For example, TABLE 8 + 4, 3 + 6 FROM ... is now a valid table expression, and the columns will be named 8 + 4 and 3 + 6 respectively. Some issues with array and object rendering were corrected. Error messages on empty dataview results were improved and now show up for all views. Inline images are now rendered correctly in Dataview tables and lists - no more hacky app://local/ schenanigans! 0.5.2 (Beta) Fix #971: Objects now work properly inside DataviewQL evaluation. 0.5.1 (Beta) Temporarily revert the new task metadata behavior: inline fields in sublists of tasks are added to the page, instead of the task. This behavior is not good, but is compatible with legacy usages of task metadata, which should uinbreak some existing queries. This behavior will be removed in the future behind a flag. Added the 'visual' field to tasks - if set, tasks render 'visual' instead of their regular text. Fixed DataArray#mutate() . 0.5.0 (Beta) Re-release of broken release 0.4.23, now hopefully with fixes that make it work on (most) machines. I'll be doing beta releases for a little while until I can confirm the new version is stable; use BRAT (https://github.com/TfTHacker/obsidian42-brat) to easily track Dataview beta versions if you are interested in cutting edge features. 0.4.25 Fix #867: Create a container div per taskList to allow for multiple task views. 0.4.24 Re-release of 0.4.23f since Obsidian does not automatically update between non-semver versions. 0.4.23f Remove some code which attempted to make tag queries case-insensitive; I'll reimplement this more generally later (it conflicts with existing queries which check tags via contains(file.tags, \"#Tag\") and similar). 0.4.23e More task bugfixes / improvements, and a fix that caused task metadata to be duplicated. 0.4.23d More inline field list parsing bug fixes. Hopefully we're back to a nice working order! 0.4.23c Bugfix which adds support for '1)' style lists, as well as a very annoying null issue due to JavaScript being a very sad, very sad language. 0.4.23b Bugfix for bad inlink/outlink computations; links were not being normalized properly so reverse lookups were not working. 0.4.23 The Task Update! This release reworks how dataview handles tasks and list items so that they should be much more intuitive to use and interact with: Subtask Support : Queries now search over all list items, instead of only over root elements. This should make task filtering much more usable, especially if you tend to put tasks under other list items or care specifically about subtasks. Multiline Support : Dataview now understands multi-line tasks and renders/updates them correctly. Immediately Navigate to Task : The new task view, aside from looking a little cleaner than previous views, now immediately navigates to the task in it's original file on click and selects it. Grouping Support : For DataviewJS users, dv.taskList now supports grouping (as produced by groupBy and the new groupIn ) natively. For DataviewJS users, the task and list representation has changed: file.tasks (and the new file.lists ) contain every single task (including subtasks) in the file, instead of only the root elements. You can return to previous behavior by filtering out tasks with a non-null parent - i.e., file.tasks.where(task => !task.parent) . dv.taskList will intelligently deal with properly nesting and de-duplicating tasks, so just filter to the tasks you want to render and the API will do the rest. This release also includes general backend improvements as we prepare for live-editing in Dataview views, as well as several community-contributed API improvements: DataArray#groupIn : For grouping already grouped data, you can now use array.groupIn(v => ...) , which will group the innermost (original) data in the array instead of the top level groups. This allows for more easily grouping recursively, such as dv.pages().groupBy(page => page.file.folder).groupIn(page => page.title) producing a grouping of folders, then page titles. substring(string, start[, end]) : The last major missing string function is now available! Take slices of strings. Improved dv.el() and other HTML functions - thanks @vitaly. null and undefined entries sort at the end instead of the beginning by default; sorry to those whose code sorts wrong because of this, but it is a better default for most people's use cases. All links are now properly normalized to their full paths, fixing many link comparison edge cases in DataviewJS. Documentation additions for the new task functionality will be coming out in the next few days. The next release 0.4.24 is currently targeting expanded FROM query support, basic table view improvements, and general exporting functionality for Dataview. See you then! 0.4.22 The @pjeby update! This includes several performance improvements suggested by @pjeby to dramatically improve background Dataview performance as well as reduce some memory pressure. It also includes some minor bug-fixes and preliminary functionality: Target ES2018 for better Promise support Allow parsing shorthands in dv.date() . Add additional metadata to inline field rendering which can be styled. Cleanup events & workers on plugin uninstall, improving the Dataview uninstall/disable/reload experience. Add preliminary CALENDAR queries - rendering similar to the obsidian-calendar plugin, see the documentation! Dataview should perform much better on startup and when you have lots of tabs open - thanks again to @pjeby. 0.4.21 Bugfix release which primarily fixes issues that Dataview had with the live preview mode in upcoming Obsidian versions; Dataview live preview should now be functional. Also includes a number of smaller bugfixes. Fix #646: Add date(yesterday) to create a date 24 hours ago. Fix #618: Luxon is now available on the dataview API ( dv.luxon ). Fix #510: Add dv.duration() for parsing durations. Fix #647: All HTML functions in the DataviewJS API now return their rendered objects. Fix #652: Fix parsing of invalid dates. Fix #629: Fix block link parsing. Fix #601: Timezones are now rendered properly and parsed properly in Dataview dates. PR #637: Add meta(link) which allows you to access various metadata about a link itself. Various minor null safety fixes. Dataview now reports it's exact version and build time in logs. 0.4.20 Some feature work (mostly by other contributors) while I while away at section metadata. May also fix a few bugs! Fix #448: You can now use the \"Task Completion Tracking\" option to automatically add completion metadata to tasks which are checked/unchecked through Dataview. Thanks to @sheeley. Add a search bar to documentation. Thanks to @tzhou. Add new date expressions for the start of the week ( date(sow) ), and the end of the week ( date(eow) ). Thanks @Jeamee and @v_mujunma. Small minor bugfix / security releases may follow in the near future; otherwise, the next major release will include section and object metadata. 0.4.19 Bugfix release which corrects emoji parsing & localization issues. Add DataArray#into , which lets you index into objects without flattening. Renamed 'header' to 'section' in task metadata; 'header' will remain around for a few major releases to let people naturally migrate. Fix #487: You no longer need spaces around '*' in expressions. Fix #559: Fix unicode issues in variable canonicalization which was causing problems with non-Latin inline field keys. Duration Parsing You can now include multiple units in durations: dur(8 minutes, 4 seconds) or dur(2yr8mo12d) . You can separate durations by commas, or use the abbreviated syntax with/without spaces. 0.4.18 Bugfix release which fixes bad inline field highlighting if '[' and '(' are mixed on the same line in particular orders. 0.4.17 Minor feature release to patch up more implementation holes. Single File Queries You can now query from a specific file (instead of just folders and tags) by specifying the full file path: TASK FROM \"dataview/Test\" ... This is primarily useful for task queries, but will soon be useful for section and object queries in the near future as well. Better Inline Field Highlighting The CSS for inline field highlighting has been fixed and some compatibility issues improved, so it should work on all themes now instead of only a few. dv.el() DataviewJS now has dv.el() , which is like existing functions like dv.paragraph and dv.span but can create any HTML element type; for example: dv . el ( \"b\" , \"Text!\" ); dv . el ( \"i\" , 18 ); 0.4.16 Small performance release which substantially reduces the impact Dataview has on vault loading times (by spreading out file loading). The Dataview Index is now also eagerly initialized, so plugin consumers of the API can immediately start using it instead of waiting for the dataview:api-ready event. 0.4.15 A simple fix for #537 which properly 'awaits' value rendering in dv.view() . Fixes issues with values rendering out of order. 0.4.14 Small bugfix release. Fixes inline field evaluation when using the new fancy highlighting. You can now configure whether task links should show up at the beginning or end of the task (or just disable them) in the \"Task Link Location\" setting. Most setting updates will immediately be applied to existing Dataviews. 0.4.13 Bugfix release which adds fancy rendering to inline-inline fields and includes a few bugfixes. Pretty Inline Fields Inline fields of the form [key:: value] will now be rendered with fancy new HTML! By default, they are rendered with both the key and value. You can only render the value using parenthesis instead: (key:: value) . You can disable this feature in the configuration. Full-line inline fields (that Dataview has supported for a long time) will gain similar rendering support soon; in the meanwhile, give the new syntax a try! Task Linking Tasks now render with a link to the page/section that they are defined in, making GROUP BY and custom task editing easier to do: A Task. \ud83d\udd17 Another Task. \ud83d\udd17 Some Random Subtask. \ud83d\udd17 You can configure the symbol for the link or disable it altogether. Improving DataviewJS Posture I am currently actively looking into improving DataviewJS sandboxing and general security posture. As a first small step in this, I have made DataviewJS opt-in instead of opt-out, and added a separate control for Inline DataviewJS. You may need to re-enable it in your settings if you use it. More improvements and better JavaScript sandboxing will follow. 0.4.12-hotfix1 Re-release of 0.4.12 that fixes an important indexing issue. Fix #505: Use completion instead of completed when setting task completion time. Fix #509: Add startswith / endswith string functions. Fix #488: Add padleft and padright , and string . Fix #506, #512: Fix date comparisons due to a bizarre date zone issue. 0.4.12 Bugfix release following up 0.4.11 which includes a few minor function additions. Fix #512: Strange zone issue causing dates to not be equal. Fix #506: Same as #512. Fix #488: Add padleft / padright functions. Fix #509: Add startswith and endswith functions. Fix #505: Correctly read completion dates for tasks from completion . This release also includes improved testing thanks to mocking Obsidian plugin APIs! 0.4.11 Fixes task behavior and adds \"truly inline\" fields! Improved Task Behavior Task queries are now much improved from their primitive foundations - you can now filter, sort, and group them! The FROM block is still page-based, sadly, though you can simply use WHERE instead if desired. For example, you can now access task fields like text , line , or completed : TASK WHERE contains(text, \"#tag\") WHERE !completed GROUP BY file.folder The full list of all available task metadata can be found here ; tasks include all the information needed to uniquely identify them, and automatically inherit all of the metadata from their parent file as well (so you can access file.name , for example). You can also annotate tasks with inline fields, as described in the section below. There is some additional UX work to be done - primarily on more easily allowing you to navigate to where the task is defined, as well as render tasks in views other than the TASK view. The semantics of how grouping works (to make it more intuitive/useful than it currently is) will likely also be revisited. Inline Inline Fields Early support for truly inline fields have been added, where you can add metadata in the middle of a sentence. It looks similar to existing inline field syntax, but with brackets or parenthesis: I would rate this a [rating:: 6]. It was (thoughts:: acceptable). Improved rendering for all inline fields is coming in an upcoming update to improve the visual look of these inline fields. Issues Fix #496: Fix task SORT functionality to do something. Fix #492: Tasks now properly annotated with parent file information. Fix #498: Fix task checking/unchecking logic (which broke due to a change in the task regex...). Initial Start of the automatic changelog.","title":"Changelog"},{"location":"changelog/#0551-beta","text":"Allow disabling regular Dataview inline queries via configuration option.","title":"0.5.51 (Beta)"},{"location":"changelog/#0550-beta","text":"Expose dataview EXPRESSION and QUERY parsing to the dataview npm plugin, so others can parse dataview ASTs. Fix documentation issue with join .","title":"0.5.50 (Beta)"},{"location":"changelog/#0549-beta","text":"Add the average function to compute averages of lists ( average([list of things]) ). Added documentation for average , min , max , minby , and maxby functions. Fixed the broken nonnull function and documented it.","title":"0.5.49 (Beta)"},{"location":"changelog/#0548-beta","text":"We're back to more regular beta releases while I trial out new functionality! Fixed broken list behavior for dv.markdownTaskList . @GamerGirlandCo: Better handling of block IDs when checking off tasks! @s-blu and @AB1908: Lots of big documentation upgrades! Nice! @leoccyao: More block ID task checking fixes. Should work after this one. Add expression/query parsing to the dataview NPM package. @charleshan: Fix a missing header level in the dataview dv.header example.","title":"0.5.48 (Beta)"},{"location":"changelog/#0547","text":"Improves date + duration behavior when either the date or duration are null.","title":"0.5.47"},{"location":"changelog/#0546","text":"Fix #1412: Fix bad file.cday and file.ctime comparisons due to wrong timezone being set. Ugh.","title":"0.5.46"},{"location":"changelog/#0545","text":"","title":"0.5.45"},{"location":"changelog/#1400-properly-use-the-group-by-field-for-the-group-name","text":"Fix bad table highlighting in some themes.","title":"1400: Properly use the group by field for the group name."},{"location":"changelog/#0544","text":"","title":"0.5.44"},{"location":"changelog/#1404-fixed-dates-in-non-local-timezones-parsing-incorrectly","text":"Fixed some build non-determinism issues. Swapped to pull requests for adding new functionality, and added some more internal tests.","title":"1404: Fixed dates in non-local timezones parsing incorrectly."},{"location":"changelog/#0543","text":"Fix #1366: Better handling of calendar emoji (used as due dates in tasks).","title":"0.5.43"},{"location":"changelog/#0542","text":"It's been over a month since the last release! Anyway, this release bundles several nice user-contributed features: @AB1908: Tag queries are now case insensitive. @AB1908: Shift-clicking a link/task to open in a new tab now works properly on Mac. @AB1908: Numerous documentation fixes for clarity and more examples. @AnnaKornfeldSimpson: Additional emoji shorthands for more task fields (finished, due). @ooker777: Documentation improvements for some DataviewJS functions, and the ability to use inline emoji for the completion tracking feature. @mt-krainski: Custom date formats for task completions. @gentlegiantJGC: Better support for nested inline fields (i.e., less crashy).","title":"0.5.42"},{"location":"changelog/#0541","text":"Fix a bad regex doing escaping in markdown tables. Improve async documentation.","title":"0.5.41"},{"location":"changelog/#0540","text":"Adds some more documentation about the new markdown functionality.","title":"0.5.40"},{"location":"changelog/#0539","text":"Fixed an issue where checking a task in a task view would check the wrong box visually. Added experimental plugin APIs for querying dataview directly as markdown, and converting dataview results to properly formatted markdown.","title":"0.5.39"},{"location":"changelog/#0538","text":"Some minor documentation improvements. Fix an issue with inline fields rendering out of order. That was a weird bug.","title":"0.5.38"},{"location":"changelog/#0537","text":"Fixes inline field rendering to once again work for highlighting/links, as well as some other rendering quirks with inline queries in codeblocks.","title":"0.5.37"},{"location":"changelog/#0536","text":"Fix a bug when checking if an element is an HTMLElement. Properly include the nice improvements to the file count in tables and lists.","title":"0.5.36"},{"location":"changelog/#0535","text":"Fix #1196, #1176: Re-enable HTML values. This was never a featured I advertised since it was just for some internal hackery, but it appears people just discovered it in DataviewJS queries. Improved initial time to popular queries that use file.starred .","title":"0.5.35"},{"location":"changelog/#0534","text":"Fix #1174: Fix indexing with a variable. Fix an issue with the experimental calendar view.","title":"0.5.34"},{"location":"changelog/#0533","text":"Fix a bug with inline views that was introduced in 0.5.32.","title":"0.5.33"},{"location":"changelog/#0532","text":"The Dataview API has been noticably revamped - there are now approximately twice as many functions available on the plugin API as there were before, and some additional utilities have been added to both the plugin and inline API. I will be finishing up the associated new \"extension\" functionality shortly, which will allow: For custom Dataview + DataviewJS functions to be added via plugins. For custom renderable objects (progress bars, embedded task lists, embedded tables) to be added to any Dataview view via plugins. For plugins to provide alternative behavior for some dataview functionality (such as integrating task plugins with the dataview task query). As part of the API revamp, it is now possible to programmatically execute Dataview and DataviewJS queries - either for using the existing Dataview query language in your own plugin, or for embedding dataview. The Dataview npm library also now exposes many useful internal Dataview types, including the AST structure for all dataview queries. I am hoping that cleaning up the Dataview API and making it much more extensible will allow for Dataview to integrate much better with existing plugins, and to provide the full power of the in-memory index for plugins. I have been very carefully watching index performance in recent weeks to ensure smooth frontend performance for anyone using the API (with a goal of <10ms for most queries).","title":"0.5.32"},{"location":"changelog/#0531","text":"Tasks now have an outlinks list field which includes all links in the task; this can be used for finding tasks with links in them.","title":"0.5.31"},{"location":"changelog/#0530","text":"Added the typeof(any) function in Dataview, which obtains the type of any value for comparison: typeof ( \"text\" ) = \"string\" typeof ( 1 ) = \"number\" typeof ([ 1 , 2 , 3 ]) = \"array\" Added the modulo operator ( % ) for doing integer division remainder. I.e., 14 % 2 = 0 and 14 % 3 = 2 . Fixed some minor spacing issues with lists in tables.","title":"0.5.30"},{"location":"changelog/#0529","text":"Fix another subtle incompatibility between 0.4.26 and 0.5.29 - if you frequently used empty inline fields (like Key:: with no value), the 0.5+ behavior is now the same as 0.4 behavior and will map such fields to null instead of an empty string. This may fix a broad variety of \"subtly wrong\" queries that you may have seen after the upgrade.","title":"0.5.29"},{"location":"changelog/#0528","text":"Fix a bug with some more string concatenations and null handling.","title":"0.5.28"},{"location":"changelog/#0527","text":"More performance + correctness bugfixes. The parser has been made a little more robust to prevent major indexing issues (or at least recover from them quickly). Several new strange tag variants are now supported. Markdown links are now properly indexed again. Some DataviewJS performance issues should be resolved now, especially for external plugins using Dataview. This fix does involve a slight API break w.r.t. what types are wrapped into Dataview Arrays (which provide functions like .where() ). Generally, only Dataview-provided implicits are wrapped in data arrays now; frontmatter and inline fields are always now regular JS arrays - use dv.array() to explicitly make a data array if you want the advanced querying.","title":"0.5.27"},{"location":"changelog/#0526","text":"More small bugfixes: Fix a few small link rendering issues. Tag extraction from tasks now handles punctuation properly. Upgrade luxon (which is embedded in DataviewJS) to 2.4.0.","title":"0.5.26"},{"location":"changelog/#0525","text":"Fix #1147: Fix there being a #null tag for files with an empty tag or tags frontmatter.","title":"0.5.25"},{"location":"changelog/#0524","text":"Several bugfixes: Nulls are now sorted first rather than last; it's generally good practice to explicitly check for nulls in your queries to avoid strange behavior. Dataview now properly parses space-delimited tags (like tags: abc def ghi ). Dataview now supports dropping the entire file cache in case of bugs.","title":"0.5.24"},{"location":"changelog/#0523","text":"Fix #1140: Force API objects to be arrays if they are iterables.","title":"0.5.23"},{"location":"changelog/#0522","text":"Fix #1135: Use 'x' instead of 'X' for checkboxes.","title":"0.5.22"},{"location":"changelog/#0521","text":"A long-overdue swap from the beta branch to the stable branch. The beta branch should not include any (intended) breaking changes, and has some nice performance improvements that come along with it! Here are the major changes: Most views now use React and no longer flicker when updating; this is not the case yet for DataviewJS, which will be getting equivalent treament in the future. Dataview now caches metadata, so Dataview loads are very fast after the first time you open your vault. Dataview still needs to visit every file when you update the plugin version, so that should be the only times you experience slower load times. A brand new task view backend and query which allows you to filter per-task, rather than per-page! Check the documentation for details, but this broadly means WHERE statements now use task properties instead of page properties. Some additional metadata is now available for use - file.starred , file.lists , and more metadata in file.tasks . There have been some moderate documentation touch-ups to keep things up to date; I'm still working on a walkthrough for common Dataview use cases. This review also includes about ~30-40 bugfixes; some new bugs may arise due to internal changes, so please flag them if you encounter them.","title":"0.5.21"},{"location":"changelog/#0520-beta","text":"Slight fix to hopefully improve some strange reported cases of bad indexing at startup.","title":"0.5.20 (Beta)"},{"location":"changelog/#0519-beta","text":"Dataview now uses IndexedDB to cache file metadata, reducing startup time to virtually nothing if you've opened the vault before; if you have a small vault (<1000 notes), you may notice a slight improvement, but large vaults and mobile devices will notice a very significant performance improvement to \"first valid paint\". Some other performance parameters have been tuned to hopefully make the default experience better. A few small bugs related to rendering have also been squashed, including an issue with images being scaled wrongly.","title":"0.5.19 (Beta)"},{"location":"changelog/#0518-beta","text":"Tasks in task views now support alternative task status characters like '!' and '/'; thanks @ebullient. A few documentation nit fixes. Added DataArray#sortInPlace for a more efficient mutable sort for niche use cases.","title":"0.5.18 (Beta)"},{"location":"changelog/#0517-beta","text":"Improved behavior when clicking on tasks in the task view; will now properly scroll to the relevant line in long files! Fixed a bug with incorrect counts being displayed in task views. Added tags as a field available on task items, so you can now do things like TASK WHERE contains(tags, \"#tag\") .","title":"0.5.17 (Beta)"},{"location":"changelog/#0516-beta","text":"Dataview now tracks initialization and will report when all files have been indexed in the console; you can programmatically see this via dataview:index-ready , or by checking api.index.initialized .","title":"0.5.16 (Beta)"},{"location":"changelog/#0515-beta","text":"Add hover highlights to tables to make seeing rows a little easier. Tables and task lists now include counts of the number of results in the headers. Further improved task selection in the task view.","title":"0.5.15 (Beta)"},{"location":"changelog/#0514-beta","text":"Fix task highlighting when not grouping. Remove some spurious console logging. Slightly improve task highlighting behavior when clicking on a task.","title":"0.5.14 (Beta)"},{"location":"changelog/#0513-beta","text":"Several smaller bugfixes! Fix #997: Use the group by field name in the table name. Prevent tons of errors if you incorrectly set the inline query prefix.","title":"0.5.13 (Beta)"},{"location":"changelog/#0512-beta","text":"Improve error messages for queries somewhat and get rid of some ugly output.","title":"0.5.12 (Beta)"},{"location":"changelog/#0511-beta","text":"Add detection of tasks inside of block quotes, as well as correctly implement automatic checking and unchecking of these tasks.","title":"0.5.11 (Beta)"},{"location":"changelog/#0510-beta","text":"Adds the Dataview: Force Refresh Views Command (accessible via the Ctrl+P command view) to force current views to refresh immediately.","title":"0.5.10 (Beta)"},{"location":"changelog/#059-beta","text":"Another fix for due-date related emoji in tasks. I hate emoji.","title":"0.5.9 (Beta)"},{"location":"changelog/#058-beta","text":"Fix some issues with infinite loops of tasks due to bad Obsidian metadata (potentially due to being out of date?).","title":"0.5.8 (Beta)"},{"location":"changelog/#057-beta","text":"Fix issues with parsing '\ud83d\uddd3\ufe0f2021-08-29' due-date annotations on tasks, as well as an issue with properly extracting due/completed/completed times for use in queries.","title":"0.5.7 (Beta)"},{"location":"changelog/#056-beta","text":"Proper release of 0.5.5 plus one additional small improvement: Add duration * number and duration / number operations for manipulation durations numerically.","title":"0.5.6 (Beta)"},{"location":"changelog/#055-beta","text":"More small features: Fix issues with task sorting not doing anything. Sort away! Table headers can now be arbitrary markdown. So you can put things like links in your headers: `TABLE (1 + 2) AS \"[[File]]\". You can now specify the size of an image embed by providing WxH in it's display property: ![[image.png|50x50]] .","title":"0.5.5 (Beta)"},{"location":"changelog/#054-beta","text":"Improved image rendering for some link types, and adds the embed(link) and embed(link, false) options to convert links to/from their embedded equivalents.","title":"0.5.4 (Beta)"},{"location":"changelog/#053-beta","text":"Iterative beta which adds a few nice QoL features and fixes some more bugs: Internally swapped to a React-based renderer; this should not have a noticeable perf or usability impact, but makes it easier for me to implement complex table/list behaviors. Naming your fields with AS \"Name\" is now optional; Dataview will infer the name from the expression automatically. For example, TABLE 8 + 4, 3 + 6 FROM ... is now a valid table expression, and the columns will be named 8 + 4 and 3 + 6 respectively. Some issues with array and object rendering were corrected. Error messages on empty dataview results were improved and now show up for all views. Inline images are now rendered correctly in Dataview tables and lists - no more hacky app://local/ schenanigans!","title":"0.5.3 (Beta)"},{"location":"changelog/#052-beta","text":"Fix #971: Objects now work properly inside DataviewQL evaluation.","title":"0.5.2 (Beta)"},{"location":"changelog/#051-beta","text":"Temporarily revert the new task metadata behavior: inline fields in sublists of tasks are added to the page, instead of the task. This behavior is not good, but is compatible with legacy usages of task metadata, which should uinbreak some existing queries. This behavior will be removed in the future behind a flag. Added the 'visual' field to tasks - if set, tasks render 'visual' instead of their regular text. Fixed DataArray#mutate() .","title":"0.5.1 (Beta)"},{"location":"changelog/#050-beta","text":"Re-release of broken release 0.4.23, now hopefully with fixes that make it work on (most) machines. I'll be doing beta releases for a little while until I can confirm the new version is stable; use BRAT (https://github.com/TfTHacker/obsidian42-brat) to easily track Dataview beta versions if you are interested in cutting edge features.","title":"0.5.0 (Beta)"},{"location":"changelog/#0425","text":"Fix #867: Create a container div per taskList to allow for multiple task views.","title":"0.4.25"},{"location":"changelog/#0424","text":"Re-release of 0.4.23f since Obsidian does not automatically update between non-semver versions.","title":"0.4.24"},{"location":"changelog/#0423f","text":"Remove some code which attempted to make tag queries case-insensitive; I'll reimplement this more generally later (it conflicts with existing queries which check tags via contains(file.tags, \"#Tag\") and similar).","title":"0.4.23f"},{"location":"changelog/#0423e","text":"More task bugfixes / improvements, and a fix that caused task metadata to be duplicated.","title":"0.4.23e"},{"location":"changelog/#0423d","text":"More inline field list parsing bug fixes. Hopefully we're back to a nice working order!","title":"0.4.23d"},{"location":"changelog/#0423c","text":"Bugfix which adds support for '1)' style lists, as well as a very annoying null issue due to JavaScript being a very sad, very sad language.","title":"0.4.23c"},{"location":"changelog/#0423b","text":"Bugfix for bad inlink/outlink computations; links were not being normalized properly so reverse lookups were not working.","title":"0.4.23b"},{"location":"changelog/#0423","text":"The Task Update! This release reworks how dataview handles tasks and list items so that they should be much more intuitive to use and interact with: Subtask Support : Queries now search over all list items, instead of only over root elements. This should make task filtering much more usable, especially if you tend to put tasks under other list items or care specifically about subtasks. Multiline Support : Dataview now understands multi-line tasks and renders/updates them correctly. Immediately Navigate to Task : The new task view, aside from looking a little cleaner than previous views, now immediately navigates to the task in it's original file on click and selects it. Grouping Support : For DataviewJS users, dv.taskList now supports grouping (as produced by groupBy and the new groupIn ) natively. For DataviewJS users, the task and list representation has changed: file.tasks (and the new file.lists ) contain every single task (including subtasks) in the file, instead of only the root elements. You can return to previous behavior by filtering out tasks with a non-null parent - i.e., file.tasks.where(task => !task.parent) . dv.taskList will intelligently deal with properly nesting and de-duplicating tasks, so just filter to the tasks you want to render and the API will do the rest. This release also includes general backend improvements as we prepare for live-editing in Dataview views, as well as several community-contributed API improvements: DataArray#groupIn : For grouping already grouped data, you can now use array.groupIn(v => ...) , which will group the innermost (original) data in the array instead of the top level groups. This allows for more easily grouping recursively, such as dv.pages().groupBy(page => page.file.folder).groupIn(page => page.title) producing a grouping of folders, then page titles. substring(string, start[, end]) : The last major missing string function is now available! Take slices of strings. Improved dv.el() and other HTML functions - thanks @vitaly. null and undefined entries sort at the end instead of the beginning by default; sorry to those whose code sorts wrong because of this, but it is a better default for most people's use cases. All links are now properly normalized to their full paths, fixing many link comparison edge cases in DataviewJS. Documentation additions for the new task functionality will be coming out in the next few days. The next release 0.4.24 is currently targeting expanded FROM query support, basic table view improvements, and general exporting functionality for Dataview. See you then!","title":"0.4.23"},{"location":"changelog/#0422","text":"The @pjeby update! This includes several performance improvements suggested by @pjeby to dramatically improve background Dataview performance as well as reduce some memory pressure. It also includes some minor bug-fixes and preliminary functionality: Target ES2018 for better Promise support Allow parsing shorthands in dv.date() . Add additional metadata to inline field rendering which can be styled. Cleanup events & workers on plugin uninstall, improving the Dataview uninstall/disable/reload experience. Add preliminary CALENDAR queries - rendering similar to the obsidian-calendar plugin, see the documentation! Dataview should perform much better on startup and when you have lots of tabs open - thanks again to @pjeby.","title":"0.4.22"},{"location":"changelog/#0421","text":"Bugfix release which primarily fixes issues that Dataview had with the live preview mode in upcoming Obsidian versions; Dataview live preview should now be functional. Also includes a number of smaller bugfixes. Fix #646: Add date(yesterday) to create a date 24 hours ago. Fix #618: Luxon is now available on the dataview API ( dv.luxon ). Fix #510: Add dv.duration() for parsing durations. Fix #647: All HTML functions in the DataviewJS API now return their rendered objects. Fix #652: Fix parsing of invalid dates. Fix #629: Fix block link parsing. Fix #601: Timezones are now rendered properly and parsed properly in Dataview dates. PR #637: Add meta(link) which allows you to access various metadata about a link itself. Various minor null safety fixes. Dataview now reports it's exact version and build time in logs.","title":"0.4.21"},{"location":"changelog/#0420","text":"Some feature work (mostly by other contributors) while I while away at section metadata. May also fix a few bugs! Fix #448: You can now use the \"Task Completion Tracking\" option to automatically add completion metadata to tasks which are checked/unchecked through Dataview. Thanks to @sheeley. Add a search bar to documentation. Thanks to @tzhou. Add new date expressions for the start of the week ( date(sow) ), and the end of the week ( date(eow) ). Thanks @Jeamee and @v_mujunma. Small minor bugfix / security releases may follow in the near future; otherwise, the next major release will include section and object metadata.","title":"0.4.20"},{"location":"changelog/#0419","text":"Bugfix release which corrects emoji parsing & localization issues. Add DataArray#into , which lets you index into objects without flattening. Renamed 'header' to 'section' in task metadata; 'header' will remain around for a few major releases to let people naturally migrate. Fix #487: You no longer need spaces around '*' in expressions. Fix #559: Fix unicode issues in variable canonicalization which was causing problems with non-Latin inline field keys.","title":"0.4.19"},{"location":"changelog/#duration-parsing","text":"You can now include multiple units in durations: dur(8 minutes, 4 seconds) or dur(2yr8mo12d) . You can separate durations by commas, or use the abbreviated syntax with/without spaces.","title":"Duration Parsing"},{"location":"changelog/#0418","text":"Bugfix release which fixes bad inline field highlighting if '[' and '(' are mixed on the same line in particular orders.","title":"0.4.18"},{"location":"changelog/#0417","text":"Minor feature release to patch up more implementation holes.","title":"0.4.17"},{"location":"changelog/#single-file-queries","text":"You can now query from a specific file (instead of just folders and tags) by specifying the full file path: TASK FROM \"dataview/Test\" ... This is primarily useful for task queries, but will soon be useful for section and object queries in the near future as well.","title":"Single File Queries"},{"location":"changelog/#better-inline-field-highlighting","text":"The CSS for inline field highlighting has been fixed and some compatibility issues improved, so it should work on all themes now instead of only a few.","title":"Better Inline Field Highlighting"},{"location":"changelog/#dvel","text":"DataviewJS now has dv.el() , which is like existing functions like dv.paragraph and dv.span but can create any HTML element type; for example: dv . el ( \"b\" , \"Text!\" ); dv . el ( \"i\" , 18 );","title":"dv.el()"},{"location":"changelog/#0416","text":"Small performance release which substantially reduces the impact Dataview has on vault loading times (by spreading out file loading). The Dataview Index is now also eagerly initialized, so plugin consumers of the API can immediately start using it instead of waiting for the dataview:api-ready event.","title":"0.4.16"},{"location":"changelog/#0415","text":"A simple fix for #537 which properly 'awaits' value rendering in dv.view() . Fixes issues with values rendering out of order.","title":"0.4.15"},{"location":"changelog/#0414","text":"Small bugfix release. Fixes inline field evaluation when using the new fancy highlighting. You can now configure whether task links should show up at the beginning or end of the task (or just disable them) in the \"Task Link Location\" setting. Most setting updates will immediately be applied to existing Dataviews.","title":"0.4.14"},{"location":"changelog/#0413","text":"Bugfix release which adds fancy rendering to inline-inline fields and includes a few bugfixes.","title":"0.4.13"},{"location":"changelog/#pretty-inline-fields","text":"Inline fields of the form [key:: value] will now be rendered with fancy new HTML! By default, they are rendered with both the key and value. You can only render the value using parenthesis instead: (key:: value) . You can disable this feature in the configuration. Full-line inline fields (that Dataview has supported for a long time) will gain similar rendering support soon; in the meanwhile, give the new syntax a try!","title":"Pretty Inline Fields"},{"location":"changelog/#task-linking","text":"Tasks now render with a link to the page/section that they are defined in, making GROUP BY and custom task editing easier to do: A Task. \ud83d\udd17 Another Task. \ud83d\udd17 Some Random Subtask. \ud83d\udd17 You can configure the symbol for the link or disable it altogether.","title":"Task Linking"},{"location":"changelog/#improving-dataviewjs-posture","text":"I am currently actively looking into improving DataviewJS sandboxing and general security posture. As a first small step in this, I have made DataviewJS opt-in instead of opt-out, and added a separate control for Inline DataviewJS. You may need to re-enable it in your settings if you use it. More improvements and better JavaScript sandboxing will follow.","title":"Improving DataviewJS Posture"},{"location":"changelog/#0412-hotfix1","text":"Re-release of 0.4.12 that fixes an important indexing issue. Fix #505: Use completion instead of completed when setting task completion time. Fix #509: Add startswith / endswith string functions. Fix #488: Add padleft and padright , and string . Fix #506, #512: Fix date comparisons due to a bizarre date zone issue.","title":"0.4.12-hotfix1"},{"location":"changelog/#0412","text":"Bugfix release following up 0.4.11 which includes a few minor function additions. Fix #512: Strange zone issue causing dates to not be equal. Fix #506: Same as #512. Fix #488: Add padleft / padright functions. Fix #509: Add startswith and endswith functions. Fix #505: Correctly read completion dates for tasks from completion . This release also includes improved testing thanks to mocking Obsidian plugin APIs!","title":"0.4.12"},{"location":"changelog/#0411","text":"Fixes task behavior and adds \"truly inline\" fields!","title":"0.4.11"},{"location":"changelog/#improved-task-behavior","text":"Task queries are now much improved from their primitive foundations - you can now filter, sort, and group them! The FROM block is still page-based, sadly, though you can simply use WHERE instead if desired. For example, you can now access task fields like text , line , or completed : TASK WHERE contains(text, \"#tag\") WHERE !completed GROUP BY file.folder The full list of all available task metadata can be found here ; tasks include all the information needed to uniquely identify them, and automatically inherit all of the metadata from their parent file as well (so you can access file.name , for example). You can also annotate tasks with inline fields, as described in the section below. There is some additional UX work to be done - primarily on more easily allowing you to navigate to where the task is defined, as well as render tasks in views other than the TASK view. The semantics of how grouping works (to make it more intuitive/useful than it currently is) will likely also be revisited.","title":"Improved Task Behavior"},{"location":"changelog/#inline-inline-fields","text":"Early support for truly inline fields have been added, where you can add metadata in the middle of a sentence. It looks similar to existing inline field syntax, but with brackets or parenthesis: I would rate this a [rating:: 6]. It was (thoughts:: acceptable). Improved rendering for all inline fields is coming in an upcoming update to improve the visual look of these inline fields.","title":"Inline Inline Fields"},{"location":"changelog/#issues","text":"Fix #496: Fix task SORT functionality to do something. Fix #492: Tasks now properly annotated with parent file information. Fix #498: Fix task checking/unchecking logic (which broke due to a change in the task regex...).","title":"Issues"},{"location":"changelog/#initial","text":"Start of the automatic changelog.","title":"Initial"},{"location":"friends/","text":"Friends of Dataview A list of plugins which may be helpful for Dataview related workflows: MetaEdit - Add or update yaml properties and Dataview fields easily Another non-exhaustive list of plugins which use Dataview for some of the heavy-lifting required for their features: Kanban - Create markdown-backed Kanban boards in Obsidian Breadcrumbs - Gives you a way to visualise a custom-built hierarchy in your Obsidian vault Supercharged Links - Allows you to style links in your Obsidian vault based on note metadata A full list can be found using GitHub's Dependents feature.","title":"Friends of Dataview"},{"location":"friends/#friends-of-dataview","text":"A list of plugins which may be helpful for Dataview related workflows: MetaEdit - Add or update yaml properties and Dataview fields easily Another non-exhaustive list of plugins which use Dataview for some of the heavy-lifting required for their features: Kanban - Create markdown-backed Kanban boards in Obsidian Breadcrumbs - Gives you a way to visualise a custom-built hierarchy in your Obsidian vault Supercharged Links - Allows you to style links in your Obsidian vault based on note metadata A full list can be found using GitHub's Dependents feature.","title":"Friends of Dataview"},{"location":"annotation/add-metadata/","text":"Adding Metadata to your Pages Dataview cannot query all content of your vault. In order to be able to search, filter and display content, this content needs to be indexed . Some content is indexed automatically, like bullet points or task lists - so called Implicit fields , more on that below - and other data needs to be saved in a metadata field to be accessible through dataview. What is a \"field\"? A metadata field is a pair of a key and a value . The value of a field has a data type (more on that here ) that determines how this field will behave when querying it. You can add any number of fields to a note , a list item or a task . How do I add fields? You can add fields to a note in three different ways. How a field look like depends on the way you add it. On tasks or list items , you will have YAML Frontmatter information available, but won't be able to add them to a specific list item. If you want to add metadata to one list item or task only, use Inline Fields . Frontmatter Frontmatter is a common Markdown extension which allows for YAML metadata to be added to the top of a page. It is natively supported by Obsidian and explained in its official documentation . All YAML Frontmatter fields will be automatically available as Dataview fields. --- alias : \"document\" last-reviewed : 2021-08-17 thoughts : rating : 8 reviewable : false --- With this your note has metadata fields named alias , last-reviewed , and thoughts . Each of these have different data types : alias is a text , because its wrapped in \"\" last-reviewed is a date , because it follows the ISO date format thoughts is a object field, because it uses the YAML Frontmatter object syntax You could i.e. query for this note with the following query, because thoughts is a object with the value rating : ```dataview LIST WHERE thoughts.rating = 8 ``` Inline Fields For those wanting a more natural-looking annotation, Dataview supports \"inline\" fields via a Key:: Value syntax that you can use everywhere in your file. This allows you to write your queryable data right where you need it - for example in the middle of a sentence. If your inline field has an own line, without any content beforehand, you can write it like this: # Markdown Page Basic Field:: Some random Value **Bold Field** :: Nice! All content after the :: is the value of the field until the next line break. Mind the :: Note that you need to use a double colon :: between key and value when using inline fields, contrary to YAML Frontmatter fields where one colon is enough. If you want to embed metadata inside sentences, or multiple fields on the same line, you can use the bracket syntax and wrap your field in square brackets: I would rate this a [rating:: 9]! It was [mood:: acceptable]. Fields on list items and tasks When you want to annotate a list item, e.g. a task, with metadata, you always need to use the bracket syntax (because the field is not the only information in this line) - [ ] Send an mail to David about the deadline [due:: 2022-04-05]. Bracketed inline fields are the only way to explicitly add fields to specific list items, YAML frontmatter always applies to the whole page (but is also available in context of list items.) There is also the alternative parenthesis syntax, which hides the key when rendered in Reader mode: This will not show the (longKeyIDontNeedWhenReading:: key). will render to: This will not show the key. You can use YAML Frontmatter and Inline fields with all syntax variants together in one file. You do not need to decide for one and can mix them to fit your workflow. Field names Imagine you used all the examples for Inline fields you see above in one note, then following metadata would be available to you: Metadata Key Sanitized Metadata key Value Data Type of Value Basic Field basic-field Some random Value Text Bold Field bold-field Nice! Text rating - 9 Number mood - acceptable Text due - Date Object for 2022-04-05 Date longKeyIDontNeedWhenReading longkeyidontneedwhenreading key Text Like you can see in the table, if you are using spaces or capitalized letters in your metadata key name, dataview will provide you with a sanitized version of the key. Keys with spaces cannot be used in a query as-is. You have two possibilities here: Either use the sanitized name, that is always all lowercase and with dashes instead of spaces or use the row variable syntax. Find out more in the FAQ . Keys with capitalized letters can be used as-is, if you wish. The sanitized version allows you to query for a key independent of its capitalization and makes it easier to use: You can query the same field thats, for example, in one file named someMetadata and in another someMetaData when using the sanitized key somemetadata . In addition, the bold field key is missing its formatting tokens . Even though the ** used to make it appear bold are part of the key name in the file, they are left out when indexing your note. The same goes for all other built-in formatting, like strike through or italic. This means formatted keys can only be queried without their formatting. This allows you to format the key in context of the note without worrying that you might create different keys for the same type of information. Usage of emojis and non-latin characters You are not limited to latin characters when naming your metadata fields. You can use all characters available in UTF-8: No\u00ebl:: Un jeu de console \u30af\u30ea\u30b9\u30de\u30b9:: \u5bb6\u5ead\u7528\u30b2\u30fc\u30e0\u6a5f [\ud83c\udf85:: a console game] [xmas\ud83c\udf84:: a console game] Using emojis as metadata keys is possible, but it comes with some limitations. When using emojis in field names, you need to put them into square brackets so that dataview recognize them correctly. Also, please be aware when switching the OS (i.e. from Windows to Android), the same emoji could use another character code and you might don't find your metadata when querying it. Task Field Shorthands An exception to this are the shorthand syntax in Tasks. You can use shorthands without bracketing. Please mind though that this only counts for listed shorthands - every other field (if with emojis or not) need to use the [key:: value] syntax. Implicit fields Even if you do not add any metadata explicitly to your note, dataview provides you with a big amount of indexed data out of the box. Some examples for implicit fields are: day the file was created ( file.cday ) links in the file ( file.outlinks ) tags in the file ( file.etags ) all list items in the file ( file.lists and file.tasks ) and many more. Available implicit fields differ depending if you look at a page or a list item. Find the full list of available implicit fields on Metadata on pages and Metadata on Tasks and Lists .","title":"Adding Metadata"},{"location":"annotation/add-metadata/#adding-metadata-to-your-pages","text":"Dataview cannot query all content of your vault. In order to be able to search, filter and display content, this content needs to be indexed . Some content is indexed automatically, like bullet points or task lists - so called Implicit fields , more on that below - and other data needs to be saved in a metadata field to be accessible through dataview.","title":"Adding Metadata to your Pages"},{"location":"annotation/add-metadata/#what-is-a-field","text":"A metadata field is a pair of a key and a value . The value of a field has a data type (more on that here ) that determines how this field will behave when querying it. You can add any number of fields to a note , a list item or a task .","title":"What is a \"field\"?"},{"location":"annotation/add-metadata/#how-do-i-add-fields","text":"You can add fields to a note in three different ways. How a field look like depends on the way you add it. On tasks or list items , you will have YAML Frontmatter information available, but won't be able to add them to a specific list item. If you want to add metadata to one list item or task only, use Inline Fields .","title":"How do I add fields?"},{"location":"annotation/add-metadata/#frontmatter","text":"Frontmatter is a common Markdown extension which allows for YAML metadata to be added to the top of a page. It is natively supported by Obsidian and explained in its official documentation . All YAML Frontmatter fields will be automatically available as Dataview fields. --- alias : \"document\" last-reviewed : 2021-08-17 thoughts : rating : 8 reviewable : false --- With this your note has metadata fields named alias , last-reviewed , and thoughts . Each of these have different data types : alias is a text , because its wrapped in \"\" last-reviewed is a date , because it follows the ISO date format thoughts is a object field, because it uses the YAML Frontmatter object syntax You could i.e. query for this note with the following query, because thoughts is a object with the value rating : ```dataview LIST WHERE thoughts.rating = 8 ```","title":"Frontmatter"},{"location":"annotation/add-metadata/#inline-fields","text":"For those wanting a more natural-looking annotation, Dataview supports \"inline\" fields via a Key:: Value syntax that you can use everywhere in your file. This allows you to write your queryable data right where you need it - for example in the middle of a sentence. If your inline field has an own line, without any content beforehand, you can write it like this: # Markdown Page Basic Field:: Some random Value **Bold Field** :: Nice! All content after the :: is the value of the field until the next line break. Mind the :: Note that you need to use a double colon :: between key and value when using inline fields, contrary to YAML Frontmatter fields where one colon is enough. If you want to embed metadata inside sentences, or multiple fields on the same line, you can use the bracket syntax and wrap your field in square brackets: I would rate this a [rating:: 9]! It was [mood:: acceptable]. Fields on list items and tasks When you want to annotate a list item, e.g. a task, with metadata, you always need to use the bracket syntax (because the field is not the only information in this line) - [ ] Send an mail to David about the deadline [due:: 2022-04-05]. Bracketed inline fields are the only way to explicitly add fields to specific list items, YAML frontmatter always applies to the whole page (but is also available in context of list items.) There is also the alternative parenthesis syntax, which hides the key when rendered in Reader mode: This will not show the (longKeyIDontNeedWhenReading:: key). will render to: This will not show the key. You can use YAML Frontmatter and Inline fields with all syntax variants together in one file. You do not need to decide for one and can mix them to fit your workflow.","title":"Inline Fields"},{"location":"annotation/add-metadata/#field-names","text":"Imagine you used all the examples for Inline fields you see above in one note, then following metadata would be available to you: Metadata Key Sanitized Metadata key Value Data Type of Value Basic Field basic-field Some random Value Text Bold Field bold-field Nice! Text rating - 9 Number mood - acceptable Text due - Date Object for 2022-04-05 Date longKeyIDontNeedWhenReading longkeyidontneedwhenreading key Text Like you can see in the table, if you are using spaces or capitalized letters in your metadata key name, dataview will provide you with a sanitized version of the key. Keys with spaces cannot be used in a query as-is. You have two possibilities here: Either use the sanitized name, that is always all lowercase and with dashes instead of spaces or use the row variable syntax. Find out more in the FAQ . Keys with capitalized letters can be used as-is, if you wish. The sanitized version allows you to query for a key independent of its capitalization and makes it easier to use: You can query the same field thats, for example, in one file named someMetadata and in another someMetaData when using the sanitized key somemetadata . In addition, the bold field key is missing its formatting tokens . Even though the ** used to make it appear bold are part of the key name in the file, they are left out when indexing your note. The same goes for all other built-in formatting, like strike through or italic. This means formatted keys can only be queried without their formatting. This allows you to format the key in context of the note without worrying that you might create different keys for the same type of information.","title":"Field names"},{"location":"annotation/add-metadata/#usage-of-emojis-and-non-latin-characters","text":"You are not limited to latin characters when naming your metadata fields. You can use all characters available in UTF-8: No\u00ebl:: Un jeu de console \u30af\u30ea\u30b9\u30de\u30b9:: \u5bb6\u5ead\u7528\u30b2\u30fc\u30e0\u6a5f [\ud83c\udf85:: a console game] [xmas\ud83c\udf84:: a console game] Using emojis as metadata keys is possible, but it comes with some limitations. When using emojis in field names, you need to put them into square brackets so that dataview recognize them correctly. Also, please be aware when switching the OS (i.e. from Windows to Android), the same emoji could use another character code and you might don't find your metadata when querying it. Task Field Shorthands An exception to this are the shorthand syntax in Tasks. You can use shorthands without bracketing. Please mind though that this only counts for listed shorthands - every other field (if with emojis or not) need to use the [key:: value] syntax.","title":"Usage of emojis and non-latin characters"},{"location":"annotation/add-metadata/#implicit-fields","text":"Even if you do not add any metadata explicitly to your note, dataview provides you with a big amount of indexed data out of the box. Some examples for implicit fields are: day the file was created ( file.cday ) links in the file ( file.outlinks ) tags in the file ( file.etags ) all list items in the file ( file.lists and file.tasks ) and many more. Available implicit fields differ depending if you look at a page or a list item. Find the full list of available implicit fields on Metadata on pages and Metadata on Tasks and Lists .","title":"Implicit fields"},{"location":"annotation/metadata-pages/","text":"Metadata on Pages You can add fields to a markdown page (a note) in three different ways - via Frontmatter, Inline fields and Implicit fields. Read more about the first two possibilities in \"how to add metadata\" . Implicit Fields Dataview automatically adds a large amount of metadata to each page. These implicit and automatically added fields are collected under the field file . Following are available: Field Name Data Type Description file.name Text The file name as seen in Obsidians sidebar. file.folder Text The path of the folder this file belongs to. file.path Text The full file path, including the files name. file.ext Text The extension of the file type; generally md . file.link Link A link to the file. file.size Number The size (in bytes) of the file. file.ctime Date with Time The date that the file was created. file.cday Date The date that the file was created. file.mtime Date with Time The date that the file was last modified. file.mday Date The date that the file was last modified. file.tags List A list of all unique tags in the note. Subtags are broken down by each level, so #Tag/1/A will be stored in the list as [#Tag, #Tag/1, #Tag/1/A] . file.etags List A list of all explicit tags in the note; unlike file.tags , does not break subtags down, i.e. [#Tag/1/A] file.inlinks List A list of all incoming links to this file, meaning all files that contain a link to this file. file.outlinks List A list of all outgoing links from this file, meaning all links the file contains. file.aliases List A list of all aliases for the note as defined via the YAML frontmatter . file.tasks List A list of all tasks (I.e., | [ ] some task ) in this file. file.lists List A list of all list elements in the file (including tasks); these elements are effectively tasks and can be rendered in task views. file.frontmatter List Contains the raw values of all frontmatter in form of key | value text values; mainly useful for checking raw frontmatter values or for dynamically listing frontmatter keys. file.day Date Only available if the file has a date inside its file name (of form yyyy-mm-dd or yyyymmdd ), or has a Date field/inline field. file.starred Boolean if this file has been starred via the Obsidian Core Plugin \"Starred Files\". Example page This is a small Markdown page which includes both user-defined ways to add metadata: --- genre: \"action\" reviewed: false --- # Movie X #movies **Thoughts** :: It was decent. **Rating** :: 6 [mood:: okay] | [length:: 2 hours] In addition to the values you see here, the page has also all keys listed above available. Example Query You can query part of the above information with following query, for example: ``` dataview TABLE file.ctime, length, rating, reviewed FROM #movies ```","title":"Metadata on Pages"},{"location":"annotation/metadata-pages/#metadata-on-pages","text":"You can add fields to a markdown page (a note) in three different ways - via Frontmatter, Inline fields and Implicit fields. Read more about the first two possibilities in \"how to add metadata\" .","title":"Metadata on Pages"},{"location":"annotation/metadata-pages/#implicit-fields","text":"Dataview automatically adds a large amount of metadata to each page. These implicit and automatically added fields are collected under the field file . Following are available: Field Name Data Type Description file.name Text The file name as seen in Obsidians sidebar. file.folder Text The path of the folder this file belongs to. file.path Text The full file path, including the files name. file.ext Text The extension of the file type; generally md . file.link Link A link to the file. file.size Number The size (in bytes) of the file. file.ctime Date with Time The date that the file was created. file.cday Date The date that the file was created. file.mtime Date with Time The date that the file was last modified. file.mday Date The date that the file was last modified. file.tags List A list of all unique tags in the note. Subtags are broken down by each level, so #Tag/1/A will be stored in the list as [#Tag, #Tag/1, #Tag/1/A] . file.etags List A list of all explicit tags in the note; unlike file.tags , does not break subtags down, i.e. [#Tag/1/A] file.inlinks List A list of all incoming links to this file, meaning all files that contain a link to this file. file.outlinks List A list of all outgoing links from this file, meaning all links the file contains. file.aliases List A list of all aliases for the note as defined via the YAML frontmatter . file.tasks List A list of all tasks (I.e., | [ ] some task ) in this file. file.lists List A list of all list elements in the file (including tasks); these elements are effectively tasks and can be rendered in task views. file.frontmatter List Contains the raw values of all frontmatter in form of key | value text values; mainly useful for checking raw frontmatter values or for dynamically listing frontmatter keys. file.day Date Only available if the file has a date inside its file name (of form yyyy-mm-dd or yyyymmdd ), or has a Date field/inline field. file.starred Boolean if this file has been starred via the Obsidian Core Plugin \"Starred Files\".","title":"Implicit Fields"},{"location":"annotation/metadata-pages/#example-page","text":"This is a small Markdown page which includes both user-defined ways to add metadata: --- genre: \"action\" reviewed: false --- # Movie X #movies **Thoughts** :: It was decent. **Rating** :: 6 [mood:: okay] | [length:: 2 hours] In addition to the values you see here, the page has also all keys listed above available.","title":"Example page"},{"location":"annotation/metadata-pages/#example-query","text":"You can query part of the above information with following query, for example: ``` dataview TABLE file.ctime, length, rating, reviewed FROM #movies ```","title":"Example Query"},{"location":"annotation/metadata-tasks/","text":"Metadata on Tasks and Lists Just like pages, you can also add fields on list item and task level to bind it to a specific task as context. For this you need to use the inline field syntax : - [ ] Hello, this is some [metadata:: value]! - [X] I finished this on [completion:: 2021-08-15]. Tasks and list items are the same data wise, so all your bullet points have all the information described here available, too. Field Shorthands For supporting \"common use cases\", Dataview understands a few shorthands for some fields you may want to annotate task with: Example Due this Saturday \ud83d\uddd3\ufe0f2021-08-29 Completed last Saturday \u27052021-08-22 I made this on \u27951990-06-14 Task I can start this weekend \ud83d\udeeb2021-08-29 Task I finished ahead of schedule \u23f32021-08-29 \u27052021-08-22 There are two specifics to these emoji-shorthands. First, they omit the inline field syntax (no [\ud83d\uddd3\ufe0f:: YYYY-MM-DD] needed) and secondly, they map to a textual field name data-wise: Field name Short hand syntax due \ud83d\uddd3\ufe0fYYYY-MM-DD completion \u2705YYYY-MM-DD created \u2795YYYY-MM-DD start \ud83d\udeebYYYY-MM-DD scheduled \u23f3YYYY-MM-DD This means if you want to query for all tasks that are completed 2021-08-22, you'll write: ```dataview TASK WHERE completion = date(\"2021-08-22\") ``` Which will list both variants - shorthands and textual annotation: - [x] Completed last Saturday \u27052021-08-22 - [x] Some Done Task [completion:: 2021-08-22] Implicit Fields As with pages, Dataview adds a number of implicit fields to each task or list item: Inheritance of Fields Tasks inherit all fields from their parent page - so if you have a rating field in your page, you can also access it on your task in a TASK Query. Field name Data Type Description status Text The completion status of this task, as determined by the character inside the [ ] brackets. Generally a space \" \" for incomplete tasks and a \"x\" for complete tasks, but allows for plugins which support alternative task statuses. checked Boolean Whether or not this task status is empty, meaning it has a space in its [ ] brackets completed Boolean Whether or not this specific task has been completed; this does not consider the completionnon-completion of any child tasks. A task is explicitly considered \"completed\" if it has been marked with an 'x'. If you use a custom status, i.e. [-] , checked will be true, whereas completed will be false. fullyCompleted Boolean Whether or not this task and all of its subtasks are completed. text Text The plain text of this task, including any metadata field annotations. line Number The line of the file this task shows up on. lineCount Number The number of Markdown lines that this task takes up. path Text The full path of the file this task is in. Equals to file.path for pages section Link link to the section this task is contained in. tags List Any tags inside of the text task. outlinks List Any links defined in this task. link Link link to the closest linkable block near this task; useful for making links which go to the task. children List ny subtasks or sublists of this task. task Boolean If true, this is a task; otherwise, it is a regular list element. annotated Boolean True if the task text contains any metadata fields, false otherwise. parent Number The line number of the task above this task, if present; will be null if this is a root-level task. blockId Text The block ID of this task / list element, if one has been defined with the ^blockId syntax; otherwise null. With usage of the shorthand syntax , following additional properties may be available: completion : The date a task was completed. due : The date a task is due, if it has one. created : The date a task was created. start : The date a task can be started. scheduled : The date a task is scheduled to work on. Access of Implicit Fields for List Items and Tasks If you're using a TASK Query, your tasks are the top level information and can be used without any prefix: ```dataview TASK WHERE !fullyCompleted ``` On every other Query Type, you first need to access the implicit field file.lists or file.tasks to check for these list item specific implicit fields: ```dataview LIST WHERE any(file.tasks, (t) => !t.fullyCompleted) ``` This'll give you back all file links that have unfinished tasks inside. We get back a list of tasks on page level and thus need to use a list function to look at each element.","title":"Metadata on Tasks and Lists"},{"location":"annotation/metadata-tasks/#metadata-on-tasks-and-lists","text":"Just like pages, you can also add fields on list item and task level to bind it to a specific task as context. For this you need to use the inline field syntax : - [ ] Hello, this is some [metadata:: value]! - [X] I finished this on [completion:: 2021-08-15]. Tasks and list items are the same data wise, so all your bullet points have all the information described here available, too.","title":"Metadata on Tasks and Lists"},{"location":"annotation/metadata-tasks/#field-shorthands","text":"For supporting \"common use cases\", Dataview understands a few shorthands for some fields you may want to annotate task with: Example Due this Saturday \ud83d\uddd3\ufe0f2021-08-29 Completed last Saturday \u27052021-08-22 I made this on \u27951990-06-14 Task I can start this weekend \ud83d\udeeb2021-08-29 Task I finished ahead of schedule \u23f32021-08-29 \u27052021-08-22 There are two specifics to these emoji-shorthands. First, they omit the inline field syntax (no [\ud83d\uddd3\ufe0f:: YYYY-MM-DD] needed) and secondly, they map to a textual field name data-wise: Field name Short hand syntax due \ud83d\uddd3\ufe0fYYYY-MM-DD completion \u2705YYYY-MM-DD created \u2795YYYY-MM-DD start \ud83d\udeebYYYY-MM-DD scheduled \u23f3YYYY-MM-DD This means if you want to query for all tasks that are completed 2021-08-22, you'll write: ```dataview TASK WHERE completion = date(\"2021-08-22\") ``` Which will list both variants - shorthands and textual annotation: - [x] Completed last Saturday \u27052021-08-22 - [x] Some Done Task [completion:: 2021-08-22]","title":"Field Shorthands"},{"location":"annotation/metadata-tasks/#implicit-fields","text":"As with pages, Dataview adds a number of implicit fields to each task or list item: Inheritance of Fields Tasks inherit all fields from their parent page - so if you have a rating field in your page, you can also access it on your task in a TASK Query. Field name Data Type Description status Text The completion status of this task, as determined by the character inside the [ ] brackets. Generally a space \" \" for incomplete tasks and a \"x\" for complete tasks, but allows for plugins which support alternative task statuses. checked Boolean Whether or not this task status is empty, meaning it has a space in its [ ] brackets completed Boolean Whether or not this specific task has been completed; this does not consider the completionnon-completion of any child tasks. A task is explicitly considered \"completed\" if it has been marked with an 'x'. If you use a custom status, i.e. [-] , checked will be true, whereas completed will be false. fullyCompleted Boolean Whether or not this task and all of its subtasks are completed. text Text The plain text of this task, including any metadata field annotations. line Number The line of the file this task shows up on. lineCount Number The number of Markdown lines that this task takes up. path Text The full path of the file this task is in. Equals to file.path for pages section Link link to the section this task is contained in. tags List Any tags inside of the text task. outlinks List Any links defined in this task. link Link link to the closest linkable block near this task; useful for making links which go to the task. children List ny subtasks or sublists of this task. task Boolean If true, this is a task; otherwise, it is a regular list element. annotated Boolean True if the task text contains any metadata fields, false otherwise. parent Number The line number of the task above this task, if present; will be null if this is a root-level task. blockId Text The block ID of this task / list element, if one has been defined with the ^blockId syntax; otherwise null. With usage of the shorthand syntax , following additional properties may be available: completion : The date a task was completed. due : The date a task is due, if it has one. created : The date a task was created. start : The date a task can be started. scheduled : The date a task is scheduled to work on.","title":"Implicit Fields"},{"location":"annotation/metadata-tasks/#access-of-implicit-fields-for-list-items-and-tasks","text":"If you're using a TASK Query, your tasks are the top level information and can be used without any prefix: ```dataview TASK WHERE !fullyCompleted ``` On every other Query Type, you first need to access the implicit field file.lists or file.tasks to check for these list item specific implicit fields: ```dataview LIST WHERE any(file.tasks, (t) => !t.fullyCompleted) ``` This'll give you back all file links that have unfinished tasks inside. We get back a list of tasks on page level and thus need to use a list function to look at each element.","title":"Access of Implicit Fields for List Items and Tasks"},{"location":"annotation/types-of-metadata/","text":"Field Types All fields in dataview have a type , which determines how dataview will render, sort, and operate on that field. Read more about how to create fields on \"Adding metadata\" and which information you have automatically available on metadata on pages and metadata on tasks and lists . Why does the type matter? Dataview provides functions you can use to modify your metadata and allows you to write all sorts of complex queries. Specific functions need specific data types to work correctly. That means the data type of your field determines which functions you can use on these fields and how the functions behave. Furthermore, depending on the type, the output dataview renders can be different. Most of the time you do not need to worry too much about the type of your fields, but if you want to perform calculations and other magical operations on your data, you should be aware of them. Different rendering based on type If you have this file: date1: : 2021-02-26T15:15 date2: : 2021-04-17 18:00 ``` dataview TABLE date1, date2 WHERE file = this.file ``` You'll see the following output (depending on your Date + Time Format Setting for dataview): File (1) date1 date2 Untitled 2 3:15 PM - Februar 26, 2021 2021-04-17 18:00 date1 is recognized as a Date while date2 is a normal Text to dataview, that's why date1 is parsed differently for you. Find out more on Dates below . Available Field Types Dataview knows several field types to cover common use cases. Text The default catch-all. If a field doesn't match a more specific type, it is plain text. Example:: This is some normal text. Multiline text Multiline text as a value is only possible via YAML Frontmatter and the pipe operator: --- poem : | Because I could not stop for Death, He kindly stopped for me; The carriage held but just ourselves And Immortality. author : \"[[Emily Dickinson]]\" title : \"Because I could not stop for Death\" --- For inline fields, a line break means the end of the value. Number Numbers like '6' and '3.6'. Example:: 6 Example:: 2.4 Example:: -80 In YAML Frontmatter, you write a number without surrounding quotes: --- rating : 8 description : \"A nice little horror movie\" --- Boolean Boolean only knows two values: true or false, as the programming concept. Example:: true Example:: false Date Text that matches the ISO8601 notation will be automatically transformed into a date object. ISO8601 follows the format YYYY-MM[-DDTHH:mm:ss.nnn+ZZ] . Everything after the month is optional. Example:: 2021-04 Example:: 2021-04-18 Example:: 2021-04-18T04:19:35.000 Example:: 2021-04-18T04:19:35.000+06:30 When querying for these dates, you can access properties that give you a certain portion of your date back: field.year field.month field.weekyear field.week field.weekday field.day field.hour field.minute field.second field.millisecond For example, if you're interested in which month your date lies, you can access it via datefield.month : birthday:: 2001-06-11 ```dataview LIST birthday WHERE birthday.month = date(now).month ``` gives you back all birthdays happening this month. Curious about date(now) ? Read more about it under literals . Displaying of date objects Dataview renders date objects in a human readable format, i.e. 3:15 PM - Februar 26, 2021 . You can adjust how this format looks like in Dataview's Setting under \"General\" with \"Date Format\" and \"Date + Time Format\". If you want to adjust the format in a specific query only, use the dateformat function . Duration Durations are text of the form <time> <unit> , like 6 hours or 4 minutes . Common English abbreviations like 6hrs or 2m are accepted. You can specify multiple units in one field, i.e. 6hr 4min , optionally with comma separator: 6 hours, 4 minutes Example:: 7 hours Example:: 16days Example:: 4min Example:: 6hr7min Example:: 9 years, 8 months, 4 days, 16 hours, 2 minutes Example:: 9 yrs 8 min Find the complete list of values that are recognized as a duration on literals . Calculations with dates and durations Date and Duration types are compatible with each other. This means you can, for example, add durations to a date to produce a new date: departure:: 2022-10-07T15:15 length of travel:: 1 day, 3 hours **Arrival** : `= this.departure + this.length-of-travel` and you get back a duration when calculating with dates: release-date:: 2023-02-14T12:00 `= this.release-date - date(now)` until release!! Curious about date(now) ? Read more about it under literals . Link Obsidian links like [[Page]] or [[Page|Page Display]] . Example:: [[A Page]] Example:: [[Some Other Page|Render Text]] Links in YAML Frontmatter If you reference a link in frontmatter, you need to quote it, as so: key: \"[[Link]]\" . This is default Obsidian-supported behavior. Unquoted links lead to a invalid YAML frontmatter that cannot be parsed anymore. --- parent : \"[[parentPage]]\" --- Please be aware that this is only a link for dataview, but not for Obsidian anymore - that means it won't show up in the outgoing links, won't be displayed on graph view and won't be updated on i.e. a rename. List Lists are multi-value fields. In YAML, these are defined as normal YAML lists: --- key3 : [ one , two , three ] key4 : - four - five - six --- In inline fields, they are comma-separated lists values: Example1:: 1, 2, 3 Example2:: \"yes\", \"or\", \"no\" Please be aware that in Inline fields, you need to wrap text values into quotes to be recognized as a list (see Example2 ). yes, or, no is recognized as plain text. Duplicated metadata keys in the same file lead to lists If you're using a metadata key twice or more in the same note, dataview will collect all values and give you a list. For example grocery:: flour [...] grocery:: soap ```dataview LIST grocery WHERE file = this.file ``` will give you a list out of flour and soap back. Arrays are lists In some places of this documentation, you'll read the term \"array\". Array is the term for lists in Javascript - Lists and Arrays are the same. A function that needs an array as argument needs a list as argument. Object Objects are a map of multiple fields under one parent field. These can only be defined in YAML frontmatter, using the YAML object syntax: --- obj : key1 : \"Val\" key2 : 3 key3 : - \"List1\" - \"List2\" - \"List3\" --- In queries, you can then access these child values via obj.key1 etc: ```dataview TABLE obj.key1, obj.key2, obj.key3 WHERE file = this.file ```","title":"Data Types"},{"location":"annotation/types-of-metadata/#field-types","text":"All fields in dataview have a type , which determines how dataview will render, sort, and operate on that field. Read more about how to create fields on \"Adding metadata\" and which information you have automatically available on metadata on pages and metadata on tasks and lists .","title":"Field Types"},{"location":"annotation/types-of-metadata/#why-does-the-type-matter","text":"Dataview provides functions you can use to modify your metadata and allows you to write all sorts of complex queries. Specific functions need specific data types to work correctly. That means the data type of your field determines which functions you can use on these fields and how the functions behave. Furthermore, depending on the type, the output dataview renders can be different. Most of the time you do not need to worry too much about the type of your fields, but if you want to perform calculations and other magical operations on your data, you should be aware of them. Different rendering based on type If you have this file: date1: : 2021-02-26T15:15 date2: : 2021-04-17 18:00 ``` dataview TABLE date1, date2 WHERE file = this.file ``` You'll see the following output (depending on your Date + Time Format Setting for dataview): File (1) date1 date2 Untitled 2 3:15 PM - Februar 26, 2021 2021-04-17 18:00 date1 is recognized as a Date while date2 is a normal Text to dataview, that's why date1 is parsed differently for you. Find out more on Dates below .","title":"Why does the type matter?"},{"location":"annotation/types-of-metadata/#available-field-types","text":"Dataview knows several field types to cover common use cases.","title":"Available Field Types"},{"location":"annotation/types-of-metadata/#text","text":"The default catch-all. If a field doesn't match a more specific type, it is plain text. Example:: This is some normal text. Multiline text Multiline text as a value is only possible via YAML Frontmatter and the pipe operator: --- poem : | Because I could not stop for Death, He kindly stopped for me; The carriage held but just ourselves And Immortality. author : \"[[Emily Dickinson]]\" title : \"Because I could not stop for Death\" --- For inline fields, a line break means the end of the value.","title":"Text"},{"location":"annotation/types-of-metadata/#number","text":"Numbers like '6' and '3.6'. Example:: 6 Example:: 2.4 Example:: -80 In YAML Frontmatter, you write a number without surrounding quotes: --- rating : 8 description : \"A nice little horror movie\" ---","title":"Number"},{"location":"annotation/types-of-metadata/#boolean","text":"Boolean only knows two values: true or false, as the programming concept. Example:: true Example:: false","title":"Boolean"},{"location":"annotation/types-of-metadata/#date","text":"Text that matches the ISO8601 notation will be automatically transformed into a date object. ISO8601 follows the format YYYY-MM[-DDTHH:mm:ss.nnn+ZZ] . Everything after the month is optional. Example:: 2021-04 Example:: 2021-04-18 Example:: 2021-04-18T04:19:35.000 Example:: 2021-04-18T04:19:35.000+06:30 When querying for these dates, you can access properties that give you a certain portion of your date back: field.year field.month field.weekyear field.week field.weekday field.day field.hour field.minute field.second field.millisecond For example, if you're interested in which month your date lies, you can access it via datefield.month : birthday:: 2001-06-11 ```dataview LIST birthday WHERE birthday.month = date(now).month ``` gives you back all birthdays happening this month. Curious about date(now) ? Read more about it under literals . Displaying of date objects Dataview renders date objects in a human readable format, i.e. 3:15 PM - Februar 26, 2021 . You can adjust how this format looks like in Dataview's Setting under \"General\" with \"Date Format\" and \"Date + Time Format\". If you want to adjust the format in a specific query only, use the dateformat function .","title":"Date"},{"location":"annotation/types-of-metadata/#duration","text":"Durations are text of the form <time> <unit> , like 6 hours or 4 minutes . Common English abbreviations like 6hrs or 2m are accepted. You can specify multiple units in one field, i.e. 6hr 4min , optionally with comma separator: 6 hours, 4 minutes Example:: 7 hours Example:: 16days Example:: 4min Example:: 6hr7min Example:: 9 years, 8 months, 4 days, 16 hours, 2 minutes Example:: 9 yrs 8 min Find the complete list of values that are recognized as a duration on literals . Calculations with dates and durations Date and Duration types are compatible with each other. This means you can, for example, add durations to a date to produce a new date: departure:: 2022-10-07T15:15 length of travel:: 1 day, 3 hours **Arrival** : `= this.departure + this.length-of-travel` and you get back a duration when calculating with dates: release-date:: 2023-02-14T12:00 `= this.release-date - date(now)` until release!! Curious about date(now) ? Read more about it under literals .","title":"Duration"},{"location":"annotation/types-of-metadata/#link","text":"Obsidian links like [[Page]] or [[Page|Page Display]] . Example:: [[A Page]] Example:: [[Some Other Page|Render Text]] Links in YAML Frontmatter If you reference a link in frontmatter, you need to quote it, as so: key: \"[[Link]]\" . This is default Obsidian-supported behavior. Unquoted links lead to a invalid YAML frontmatter that cannot be parsed anymore. --- parent : \"[[parentPage]]\" --- Please be aware that this is only a link for dataview, but not for Obsidian anymore - that means it won't show up in the outgoing links, won't be displayed on graph view and won't be updated on i.e. a rename.","title":"Link"},{"location":"annotation/types-of-metadata/#list","text":"Lists are multi-value fields. In YAML, these are defined as normal YAML lists: --- key3 : [ one , two , three ] key4 : - four - five - six --- In inline fields, they are comma-separated lists values: Example1:: 1, 2, 3 Example2:: \"yes\", \"or\", \"no\" Please be aware that in Inline fields, you need to wrap text values into quotes to be recognized as a list (see Example2 ). yes, or, no is recognized as plain text. Duplicated metadata keys in the same file lead to lists If you're using a metadata key twice or more in the same note, dataview will collect all values and give you a list. For example grocery:: flour [...] grocery:: soap ```dataview LIST grocery WHERE file = this.file ``` will give you a list out of flour and soap back. Arrays are lists In some places of this documentation, you'll read the term \"array\". Array is the term for lists in Javascript - Lists and Arrays are the same. A function that needs an array as argument needs a list as argument.","title":"List"},{"location":"annotation/types-of-metadata/#object","text":"Objects are a map of multiple fields under one parent field. These can only be defined in YAML frontmatter, using the YAML object syntax: --- obj : key1 : \"Val\" key2 : 3 key3 : - \"List1\" - \"List2\" - \"List3\" --- In queries, you can then access these child values via obj.key1 etc: ```dataview TABLE obj.key1, obj.key2, obj.key3 WHERE file = this.file ```","title":"Object"},{"location":"api/code-examples/","text":"Codeblock Examples Grouped Books Group your books by genre, then create a table for each sorted by rating via a straightforward usage of the dataview rendering API: for ( let group of dv . pages ( \"#book\" ). groupBy ( p => p . genre )) { dv . header ( 3 , group . key ); dv . table ([ \"Name\" , \"Time Read\" , \"Rating\" ], group . rows . sort ( k => k . rating , 'desc' ) . map ( k => [ k . file . link , k [ \"time-read\" ], k . rating ])) } Find All Direct And Indirectly Linked Pages Use a simple set + stack depth first search to find all notes linked to the current note, or a note of your choosing: let page = dv . current (). file . path ; let pages = new Set (); let stack = [ page ]; while ( stack . length > 0 ) { let elem = stack . pop (); let meta = dv . page ( elem ); if ( ! meta ) continue ; for ( let inlink of meta . file . inlinks . concat ( meta . file . outlinks ). array ()) { console . log ( inlink ); if ( pages . has ( inlink . path )) continue ; pages . add ( inlink . path ); stack . push ( inlink . path ); } } // Data is now the file metadata for every page that directly OR indirectly links to the current page. let data = dv . array ( Array . from ( pages )). map ( p => dv . page ( p ));","title":"Codeblock Examples"},{"location":"api/code-examples/#codeblock-examples","text":"","title":"Codeblock Examples"},{"location":"api/code-examples/#grouped-books","text":"Group your books by genre, then create a table for each sorted by rating via a straightforward usage of the dataview rendering API: for ( let group of dv . pages ( \"#book\" ). groupBy ( p => p . genre )) { dv . header ( 3 , group . key ); dv . table ([ \"Name\" , \"Time Read\" , \"Rating\" ], group . rows . sort ( k => k . rating , 'desc' ) . map ( k => [ k . file . link , k [ \"time-read\" ], k . rating ])) }","title":"Grouped Books"},{"location":"api/code-examples/#find-all-direct-and-indirectly-linked-pages","text":"Use a simple set + stack depth first search to find all notes linked to the current note, or a note of your choosing: let page = dv . current (). file . path ; let pages = new Set (); let stack = [ page ]; while ( stack . length > 0 ) { let elem = stack . pop (); let meta = dv . page ( elem ); if ( ! meta ) continue ; for ( let inlink of meta . file . inlinks . concat ( meta . file . outlinks ). array ()) { console . log ( inlink ); if ( pages . has ( inlink . path )) continue ; pages . add ( inlink . path ); stack . push ( inlink . path ); } } // Data is now the file metadata for every page that directly OR indirectly links to the current page. let data = dv . array ( Array . from ( pages )). map ( p => dv . page ( p ));","title":"Find All Direct And Indirectly Linked Pages"},{"location":"api/code-reference/","text":"Codeblock Reference Dataview JavaScript Codeblocks are created using the dataviewjs language specification for a codeblock: ```dataviewjs dv.table([], ...) ``` The API is available through the implicitly provided dv (or dataview ) variable, through which you can query for information, render HTML, and configure the view. Asynchronous API calls are marked with \u231b . Query Query methods allow you to query the Dataview index for page metadata; to render this data, use the methods in the render section . dv.current() Get page information (via dv.page() ) for the page the script is currently executing on. dv.pages(source) Take a single string argument, source , which is the same form as a query language source . Return a data array of page objects, which are plain objects with all of the page fields as values. dv . pages () => all pages in your vault dv . pages ( \"#books\" ) => all pages with tag 'books' dv . pages ( '\"folder\"' ) => all pages from folder \"folder\" dv . pages ( \"#yes or -#no\" ) => all pages with tag # yes , or which DON 'T have tag #no dv.pages(' \"folder\" or # tag ' ) => all pages with tag # tag , or from folder \"folder\" Note that folders need to be double-quoted inside the string (i.e., dv.pages(\"folder\") does not work, but dv.pages('\"folder\"') does) - this is to exactly match how sources are written in the query language. dv.pagePaths(source) As with dv.pages , but just returns a data array of paths of pages that match the given source. dv . pagePaths ( \"#books\" ) => the paths of pages with tag 'books' dv.page(path) Map a simple path or link to the full page object, which includes all of the pages fields. Automatically does link resolution, and will figure out the extension automatically if not present. dv . page ( \"Index\" ) => The page object for /Index dv . page ( \"books/The Raisin.md\" ) => The page object for /books/The Raisin.md Render dv.el(element, text) Render arbitrary text in the given html element. dv . el ( \"b\" , \"This is some bold text\" ); You can specify custom classes to add to the element via cls , and additional attributes via attr : dv . el ( \"b\" , \"This is some text\" , { cls : \"dataview dataview-class\" , attr : { alt : \"Nice!\" } }); dv.header(level, text) Render a header of level 1 - 6 with the given text. dv . header ( 1 , \"Big!\" ); dv . header ( 6 , \"Tiny\" ); dv.paragraph(text) Render arbitrary text in a paragraph. dv . paragraph ( \"This is some text\" ); dv.span(text) Render arbitrary text in a span (no padding above/below, unlike a paragraph). dv . span ( \"This is some text\" ); dv.execute(source) Execute an arbitrary dataview query and embed the view into the current page. dv . execute ( \"LIST FROM #tag\" ); dv . execute ( \"TABLE field1, field2 FROM #thing\" ); dv.executeJs(source) Execute an arbitrary DataviewJS query and embed the view into the current page. dv . executeJs ( \"dv.list([1, 2, 3])\" ); dv.view(path, input) Complex function which allows for custom views. Will attempt to load a JavaScript file at the given path, passing it dv and input and allowing it to execute. This allows for you to re-use custom view code across multiple pages. Note that this is an asynchronous function since it involves file I/O - make sure to await the result! await dv . view ( \"views/custom\" , { arg1 : ..., arg2 : ... }); If you want to also include custom CSS in your view, you can instead pass a path to a folder containing view.js and view.css ; the CSS will be added to the view automatically: views/custom -> view.js -> view.css View scripts have access to the dv object (the API object), and an input object which is exactly whatever the second argument of dv.view() was. Dataviews dv.list(elements) Render a dataview list of elements; accept both vanilla arrays and data arrays. dv . list ([ 1 , 2 , 3 ]) => list of 1 , 2 , 3 dv . list ( dv . pages (). file . name ) => list of all file names dv . list ( dv . pages (). file . link ) => list of all file links dv . list ( dv . pages ( \"#book\" ). where ( p => p . rating > 7 )) => list of all books with rating greater than 7 dv.taskList(tasks, groupByFile) Render a dataview list of Task objects, as obtained by page.file.tasks . Only the first argument is required; if the second argument groupByFile is provided (and is true), then tasks will be grouped by the file they come from automatically. // List all tasks from pages marked '#project' dv . taskList ( dv . pages ( \"#project\" ). file . tasks ) // List all *uncompleted* tasks from pages marked #project dv . taskList ( dv . pages ( \"#project\" ). file . tasks . where ( t => ! t . completed )) // List all tasks tagged with '#tag' from pages marked #project dv . taskList ( dv . pages ( \"#project\" ). file . tasks . where ( t => t . text . includes ( \"#tag\" ))) dv.table(headers, elements) Render a dataview table with the given list of headers and 2D array of elements. // Render a simple table of book info sorted by rating. dv . table ([ \"File\" , \"Genre\" , \"Time Read\" , \"Rating\" ], dv . pages ( \"#book\" ) . sort ( b => b . rating ) . map ( b => [ b . file . link , b . genre , b [ \"time-read\" ], b . rating ])) Markdown Dataviews Functions which render to plain Markdown strings which you can then render or manipulate as desired. dv.markdownTable(headers, values) Equivalent to dv.table() , which renders a table with the given list of headers and 2D array of elements, but returns plain Markdown. // Render a simple table of book info sorted by rating. const table = dv . markdownTable ([ \"File\" , \"Genre\" , \"Time Read\" , \"Rating\" ], dv . pages ( \"#book\" ) . sort ( b => b . rating ) . map ( b => [ b . file . link , b . genre , b [ \"time-read\" ], b . rating ])) dv . paragraph ( table ); dv.markdownList(values) Equivalent to dv.list() , which renders a list of the given elements, but returns plain Markdown. const markdown = dv . markdownList ([ 1 , 2 , 3 ]); dv . paragraph ( markdown ); dv.markdownTaskList(tasks) Equivalent to dv.taskList() , which renders a task list, but returns plain Markdown. const markdown = dv . markdownTaskList ( dv . pages ( \"#project\" ). file . tasks ); dv . paragraph ( markdown ); Utility dv.array(value) Convert a given value or array into a Dataview data array . If the value is already a data array, returns it unchanged. dv . array ([ 1 , 2 , 3 ]) => dataview data array [ 1 , 2 , 3 ] dv.isArray(value) Returns true if the given value is an array or dataview array. dv . isArray ( dv . array ([ 1 , 2 , 3 ])) => true dv . isArray ([ 1 , 2 , 3 ]) => true dv . isArray ({ x : 1 }) => false dv.fileLink(path, [embed?], [display-name]) Converts a textual path into a Dataview Link object; you can optionally also specify if the link is embedded as well as it's display name. dv . fileLink ( \"2021-08-08\" ) => link to file named \"2021-08-08\" dv . fileLink ( \"book/The Raisin\" , true ) => embed link to \"The Raisin\" dv . fileLink ( \"Test\" , false , \"Test File\" ) => link to file \"Test\" with display name \"Test File\" dv.sectionLink(path, section, [embed?], [display?]) Converts a textual path + section name into a Dataview Link object; you can optionally also specify if the link is embedded and it's display name. dv . sectionLink ( \"Index\" , \"Books\" ) => [[ Index # Books ]] dv . sectionLink ( \"Index\" , \"Books\" , false , \"My Books\" ) => [[ Index # Books | My Books ]] dv.blockLink(path, blockId, [embed?], [display?]) Converts a textual path + block ID into a Dataview Link object; you can optionally also specify if the link is embedded and it's display name. dv . blockLink ( \"Notes\" , \"12gdhjg3\" ) => [[ Index # ^ 12 gdhjg3 ]] dv.date(text) Coerce text and links to luxon DateTime ; if provided with a DateTime , return it unchanged. dv . date ( \"2021-08-08\" ) => DateTime for August 8 th , 2021 dv . date ( dv . fileLink ( \"2021-08-07\" )) => dateTime for August 8 th , 2021 dv.duration(text) Coerce text to a luxon Duration ; uses the same parsing rules as Dataview duration types. dv . duration ( \"8 minutes\" ) => Duration { 8 minutes } dv . duration ( \"9 hours, 2 minutes, 3 seconds\" ) => Duration { 9 hours , 2 minutes , 3 seconds } dv.compare(a, b) Compare two arbitrary JavaScript values according to dataview's default comparison rules; useful if you are writing a custom comparator and want to fall back to the default behavior. Returns a negative value if a < b , 0 if a = b , and a positive value if a > b . dv . compare ( 1 , 2 ) = - 1 dv . compare ( \"yes\" , \"no\" ) = 1 dv . compare ({ what : 0 }, { what : 0 }) = 0 dv.equal(a, b) Compare two arbitrary JavaScript values and return true if they are equal according to Dataview's default comparison rules. dv . equal ( 1 , 2 ) = false dv . equal ( 1 , 1 ) = true dv.clone(value) Deep clone any Dataview value, including dates, arrays, and links. dv . clone ( 1 ) = 1 dv . clone ({ a : 1 }) = { a : 1 } dv.parse(value) Parse an arbitrary string object into a complex Dataview type (mainly supporting links, dates, and durations). dv . parse ( \"[[A]]\" ) = Link { path : A } dv . parse ( \"2020-08-14\" ) = DateTime { 2020 - 08 - 14 } dv . parse ( \"9 seconds\" ) = Duration { 9 seconds } File I/O These utility methods are all contained in the dv.io sub-API, and are all asynchronous (marked by \u231b). \u231b dv.io.csv(path, [origin-file]) Load a CSV from the given path (a link or string). Relative paths will be resolved relative to the optional origin file (defaulting to the current file if not provided). Return a dataview array, each element containing an object of the CSV values; if the file does not exist, return undefined . await dv . io . csv ( \"hello.csv\" ) => [{ column1 : ..., column2 : ...}, ...] \u231b dv.io.load(path, [origin-file]) Load the contents of the given path (a link or string) asynchronously. Relative paths will be resolved relative to the optional origin file (defaulting to the current file if not provided). Returns the string contents of the file, or undefined if the file does not exist. await dv . io . load ( \"File\" ) => \"# File\\nThis is an example file...\" dv.io.normalize(path, [origin-file]) Convert a relative link or path into an absolute path. If origin-file is provided, then the resolution is doing as if you were resolving the link from that file; if not, the path is resolved relative to the current file. dv . io . normalize ( \"Test\" ) => \"dataview/test/Test.md\" , if inside \"dataview/test\" dv . io . normalize ( \"Test\" , \"dataview/test2/Index.md\" ) => \"dataview/test2/Test.md\" , irrespective of the current file Query Evaluation \u231b dv.query(source, [file, settings]) Execute a Dataview query and return the results as a structured return. The return type of this function varies by the query type being executed, though will always be an object with a type denoting the return type. This version of query returns a result type - you may want tryQuery , which instead throws an error on failed query execution. await dv . query ( \"LIST FROM #tag\" ) => Success { type : \"list\" , values : [ value1 , value2 , ...] } await dv . query ( `TABLE WITHOUT ID file.name, value FROM \"path\"` ) => Success { type : \"table\" , headers : [ \"file.name\" , \"value\" ], values : [[ \"A\" , 1 ], [ \"B\" , 2 ]] } await dv . query ( \"TASK WHERE due\" ) => Success { type : \"task\" , values : [ task1 , task2 , ...]} dv.query accepts two additional, optional arguments: 1. file : The file path to resolve the query from (in case of references to this ). Defaults to the current file. 2. settings : Execution settings for running the query. This is largely an advanced use case (where I recommend you directly check the API implementation to see all available options). \u231b dv.tryQuery(source, [file, settings]) Exactly the same as dv.query , but more convenient in short scripts as execution failures will be raised as JavaScript exceptions instead of a result type. \u231b dv.queryMarkdown(source, [file], [settings]) Equivalent to dv.query() , but returns rendered Markdown. await dv . queryMarkdown ( \"LIST FROM #tag\" ) => Success { \"- [[Page 1]]\\n- [[Page 2]]\" } \u231b dv.tryQueryMarkdown(source, [file], [settings]) Exactly the same as dv.queryMarkdown() , but throws an error on parse failure. dv.tryEvaluate(expression, [context]) Evaluate an arbitrary dataview expression (like 2 + 2 or link(\"text\") or x * 9 ); throws an Error on parse or evaluation failure. this is an always-available implicit variable which refers to the current file. dv . tryEvaluate ( \"2 + 2\" ) => 4 dv . tryEvaluate ( \"x + 2\" , { x : 3 }) => 5 dv . tryEvaluate ( \"length(this.file.tasks)\" ) => number of tasks in the current file dv.evaluate(expression, [context]) Evaluate an arbitrary dataview expression (like 2 + 2 or link(\"text\") or x * 9 ), returning a Result object of the result. You can unwrap the result type by checking result.successful (and then fetching either result.value or result.error ). If you want a simpler API that throws an error on a failed evaluation, use dv.tryEvaluate . dv . evaluate ( \"2 + 2\" ) => Successful { value : 4 } dv . evaluate ( \"2 +\" ) => Failure { error : \"Failed to parse ... \" }","title":"Codeblock Reference"},{"location":"api/code-reference/#codeblock-reference","text":"Dataview JavaScript Codeblocks are created using the dataviewjs language specification for a codeblock: ```dataviewjs dv.table([], ...) ``` The API is available through the implicitly provided dv (or dataview ) variable, through which you can query for information, render HTML, and configure the view. Asynchronous API calls are marked with \u231b .","title":"Codeblock Reference"},{"location":"api/code-reference/#query","text":"Query methods allow you to query the Dataview index for page metadata; to render this data, use the methods in the render section .","title":"Query"},{"location":"api/code-reference/#dvcurrent","text":"Get page information (via dv.page() ) for the page the script is currently executing on.","title":"dv.current()"},{"location":"api/code-reference/#dvpagessource","text":"Take a single string argument, source , which is the same form as a query language source . Return a data array of page objects, which are plain objects with all of the page fields as values. dv . pages () => all pages in your vault dv . pages ( \"#books\" ) => all pages with tag 'books' dv . pages ( '\"folder\"' ) => all pages from folder \"folder\" dv . pages ( \"#yes or -#no\" ) => all pages with tag # yes , or which DON 'T have tag #no dv.pages(' \"folder\" or # tag ' ) => all pages with tag # tag , or from folder \"folder\" Note that folders need to be double-quoted inside the string (i.e., dv.pages(\"folder\") does not work, but dv.pages('\"folder\"') does) - this is to exactly match how sources are written in the query language.","title":"dv.pages(source)"},{"location":"api/code-reference/#dvpagepathssource","text":"As with dv.pages , but just returns a data array of paths of pages that match the given source. dv . pagePaths ( \"#books\" ) => the paths of pages with tag 'books'","title":"dv.pagePaths(source)"},{"location":"api/code-reference/#dvpagepath","text":"Map a simple path or link to the full page object, which includes all of the pages fields. Automatically does link resolution, and will figure out the extension automatically if not present. dv . page ( \"Index\" ) => The page object for /Index dv . page ( \"books/The Raisin.md\" ) => The page object for /books/The Raisin.md","title":"dv.page(path)"},{"location":"api/code-reference/#render","text":"","title":"Render"},{"location":"api/code-reference/#dvelelement-text","text":"Render arbitrary text in the given html element. dv . el ( \"b\" , \"This is some bold text\" ); You can specify custom classes to add to the element via cls , and additional attributes via attr : dv . el ( \"b\" , \"This is some text\" , { cls : \"dataview dataview-class\" , attr : { alt : \"Nice!\" } });","title":"dv.el(element, text)"},{"location":"api/code-reference/#dvheaderlevel-text","text":"Render a header of level 1 - 6 with the given text. dv . header ( 1 , \"Big!\" ); dv . header ( 6 , \"Tiny\" );","title":"dv.header(level, text)"},{"location":"api/code-reference/#dvparagraphtext","text":"Render arbitrary text in a paragraph. dv . paragraph ( \"This is some text\" );","title":"dv.paragraph(text)"},{"location":"api/code-reference/#dvspantext","text":"Render arbitrary text in a span (no padding above/below, unlike a paragraph). dv . span ( \"This is some text\" );","title":"dv.span(text)"},{"location":"api/code-reference/#dvexecutesource","text":"Execute an arbitrary dataview query and embed the view into the current page. dv . execute ( \"LIST FROM #tag\" ); dv . execute ( \"TABLE field1, field2 FROM #thing\" );","title":"dv.execute(source)"},{"location":"api/code-reference/#dvexecutejssource","text":"Execute an arbitrary DataviewJS query and embed the view into the current page. dv . executeJs ( \"dv.list([1, 2, 3])\" );","title":"dv.executeJs(source)"},{"location":"api/code-reference/#dvviewpath-input","text":"Complex function which allows for custom views. Will attempt to load a JavaScript file at the given path, passing it dv and input and allowing it to execute. This allows for you to re-use custom view code across multiple pages. Note that this is an asynchronous function since it involves file I/O - make sure to await the result! await dv . view ( \"views/custom\" , { arg1 : ..., arg2 : ... }); If you want to also include custom CSS in your view, you can instead pass a path to a folder containing view.js and view.css ; the CSS will be added to the view automatically: views/custom -> view.js -> view.css View scripts have access to the dv object (the API object), and an input object which is exactly whatever the second argument of dv.view() was.","title":"dv.view(path, input)"},{"location":"api/code-reference/#dataviews","text":"","title":"Dataviews"},{"location":"api/code-reference/#dvlistelements","text":"Render a dataview list of elements; accept both vanilla arrays and data arrays. dv . list ([ 1 , 2 , 3 ]) => list of 1 , 2 , 3 dv . list ( dv . pages (). file . name ) => list of all file names dv . list ( dv . pages (). file . link ) => list of all file links dv . list ( dv . pages ( \"#book\" ). where ( p => p . rating > 7 )) => list of all books with rating greater than 7","title":"dv.list(elements)"},{"location":"api/code-reference/#dvtasklisttasks-groupbyfile","text":"Render a dataview list of Task objects, as obtained by page.file.tasks . Only the first argument is required; if the second argument groupByFile is provided (and is true), then tasks will be grouped by the file they come from automatically. // List all tasks from pages marked '#project' dv . taskList ( dv . pages ( \"#project\" ). file . tasks ) // List all *uncompleted* tasks from pages marked #project dv . taskList ( dv . pages ( \"#project\" ). file . tasks . where ( t => ! t . completed )) // List all tasks tagged with '#tag' from pages marked #project dv . taskList ( dv . pages ( \"#project\" ). file . tasks . where ( t => t . text . includes ( \"#tag\" )))","title":"dv.taskList(tasks, groupByFile)"},{"location":"api/code-reference/#dvtableheaders-elements","text":"Render a dataview table with the given list of headers and 2D array of elements. // Render a simple table of book info sorted by rating. dv . table ([ \"File\" , \"Genre\" , \"Time Read\" , \"Rating\" ], dv . pages ( \"#book\" ) . sort ( b => b . rating ) . map ( b => [ b . file . link , b . genre , b [ \"time-read\" ], b . rating ]))","title":"dv.table(headers, elements)"},{"location":"api/code-reference/#markdown-dataviews","text":"Functions which render to plain Markdown strings which you can then render or manipulate as desired.","title":"Markdown Dataviews"},{"location":"api/code-reference/#dvmarkdowntableheaders-values","text":"Equivalent to dv.table() , which renders a table with the given list of headers and 2D array of elements, but returns plain Markdown. // Render a simple table of book info sorted by rating. const table = dv . markdownTable ([ \"File\" , \"Genre\" , \"Time Read\" , \"Rating\" ], dv . pages ( \"#book\" ) . sort ( b => b . rating ) . map ( b => [ b . file . link , b . genre , b [ \"time-read\" ], b . rating ])) dv . paragraph ( table );","title":"dv.markdownTable(headers, values)"},{"location":"api/code-reference/#dvmarkdownlistvalues","text":"Equivalent to dv.list() , which renders a list of the given elements, but returns plain Markdown. const markdown = dv . markdownList ([ 1 , 2 , 3 ]); dv . paragraph ( markdown );","title":"dv.markdownList(values)"},{"location":"api/code-reference/#dvmarkdowntasklisttasks","text":"Equivalent to dv.taskList() , which renders a task list, but returns plain Markdown. const markdown = dv . markdownTaskList ( dv . pages ( \"#project\" ). file . tasks ); dv . paragraph ( markdown );","title":"dv.markdownTaskList(tasks)"},{"location":"api/code-reference/#utility","text":"","title":"Utility"},{"location":"api/code-reference/#dvarrayvalue","text":"Convert a given value or array into a Dataview data array . If the value is already a data array, returns it unchanged. dv . array ([ 1 , 2 , 3 ]) => dataview data array [ 1 , 2 , 3 ]","title":"dv.array(value)"},{"location":"api/code-reference/#dvisarrayvalue","text":"Returns true if the given value is an array or dataview array. dv . isArray ( dv . array ([ 1 , 2 , 3 ])) => true dv . isArray ([ 1 , 2 , 3 ]) => true dv . isArray ({ x : 1 }) => false","title":"dv.isArray(value)"},{"location":"api/code-reference/#dvfilelinkpath-embed-display-name","text":"Converts a textual path into a Dataview Link object; you can optionally also specify if the link is embedded as well as it's display name. dv . fileLink ( \"2021-08-08\" ) => link to file named \"2021-08-08\" dv . fileLink ( \"book/The Raisin\" , true ) => embed link to \"The Raisin\" dv . fileLink ( \"Test\" , false , \"Test File\" ) => link to file \"Test\" with display name \"Test File\"","title":"dv.fileLink(path, [embed?], [display-name])"},{"location":"api/code-reference/#dvsectionlinkpath-section-embed-display","text":"Converts a textual path + section name into a Dataview Link object; you can optionally also specify if the link is embedded and it's display name. dv . sectionLink ( \"Index\" , \"Books\" ) => [[ Index # Books ]] dv . sectionLink ( \"Index\" , \"Books\" , false , \"My Books\" ) => [[ Index # Books | My Books ]]","title":"dv.sectionLink(path, section, [embed?], [display?])"},{"location":"api/code-reference/#dvblocklinkpath-blockid-embed-display","text":"Converts a textual path + block ID into a Dataview Link object; you can optionally also specify if the link is embedded and it's display name. dv . blockLink ( \"Notes\" , \"12gdhjg3\" ) => [[ Index # ^ 12 gdhjg3 ]]","title":"dv.blockLink(path, blockId, [embed?], [display?])"},{"location":"api/code-reference/#dvdatetext","text":"Coerce text and links to luxon DateTime ; if provided with a DateTime , return it unchanged. dv . date ( \"2021-08-08\" ) => DateTime for August 8 th , 2021 dv . date ( dv . fileLink ( \"2021-08-07\" )) => dateTime for August 8 th , 2021","title":"dv.date(text)"},{"location":"api/code-reference/#dvdurationtext","text":"Coerce text to a luxon Duration ; uses the same parsing rules as Dataview duration types. dv . duration ( \"8 minutes\" ) => Duration { 8 minutes } dv . duration ( \"9 hours, 2 minutes, 3 seconds\" ) => Duration { 9 hours , 2 minutes , 3 seconds }","title":"dv.duration(text)"},{"location":"api/code-reference/#dvcomparea-b","text":"Compare two arbitrary JavaScript values according to dataview's default comparison rules; useful if you are writing a custom comparator and want to fall back to the default behavior. Returns a negative value if a < b , 0 if a = b , and a positive value if a > b . dv . compare ( 1 , 2 ) = - 1 dv . compare ( \"yes\" , \"no\" ) = 1 dv . compare ({ what : 0 }, { what : 0 }) = 0","title":"dv.compare(a, b)"},{"location":"api/code-reference/#dvequala-b","text":"Compare two arbitrary JavaScript values and return true if they are equal according to Dataview's default comparison rules. dv . equal ( 1 , 2 ) = false dv . equal ( 1 , 1 ) = true","title":"dv.equal(a, b)"},{"location":"api/code-reference/#dvclonevalue","text":"Deep clone any Dataview value, including dates, arrays, and links. dv . clone ( 1 ) = 1 dv . clone ({ a : 1 }) = { a : 1 }","title":"dv.clone(value)"},{"location":"api/code-reference/#dvparsevalue","text":"Parse an arbitrary string object into a complex Dataview type (mainly supporting links, dates, and durations). dv . parse ( \"[[A]]\" ) = Link { path : A } dv . parse ( \"2020-08-14\" ) = DateTime { 2020 - 08 - 14 } dv . parse ( \"9 seconds\" ) = Duration { 9 seconds }","title":"dv.parse(value)"},{"location":"api/code-reference/#file-io","text":"These utility methods are all contained in the dv.io sub-API, and are all asynchronous (marked by \u231b).","title":"File I/O"},{"location":"api/code-reference/#dviocsvpath-origin-file","text":"Load a CSV from the given path (a link or string). Relative paths will be resolved relative to the optional origin file (defaulting to the current file if not provided). Return a dataview array, each element containing an object of the CSV values; if the file does not exist, return undefined . await dv . io . csv ( \"hello.csv\" ) => [{ column1 : ..., column2 : ...}, ...]","title":"\u231b dv.io.csv(path, [origin-file])"},{"location":"api/code-reference/#dvioloadpath-origin-file","text":"Load the contents of the given path (a link or string) asynchronously. Relative paths will be resolved relative to the optional origin file (defaulting to the current file if not provided). Returns the string contents of the file, or undefined if the file does not exist. await dv . io . load ( \"File\" ) => \"# File\\nThis is an example file...\"","title":"\u231b dv.io.load(path, [origin-file])"},{"location":"api/code-reference/#dvionormalizepath-origin-file","text":"Convert a relative link or path into an absolute path. If origin-file is provided, then the resolution is doing as if you were resolving the link from that file; if not, the path is resolved relative to the current file. dv . io . normalize ( \"Test\" ) => \"dataview/test/Test.md\" , if inside \"dataview/test\" dv . io . normalize ( \"Test\" , \"dataview/test2/Index.md\" ) => \"dataview/test2/Test.md\" , irrespective of the current file","title":"dv.io.normalize(path, [origin-file])"},{"location":"api/code-reference/#query-evaluation","text":"","title":"Query Evaluation"},{"location":"api/code-reference/#dvquerysource-file-settings","text":"Execute a Dataview query and return the results as a structured return. The return type of this function varies by the query type being executed, though will always be an object with a type denoting the return type. This version of query returns a result type - you may want tryQuery , which instead throws an error on failed query execution. await dv . query ( \"LIST FROM #tag\" ) => Success { type : \"list\" , values : [ value1 , value2 , ...] } await dv . query ( `TABLE WITHOUT ID file.name, value FROM \"path\"` ) => Success { type : \"table\" , headers : [ \"file.name\" , \"value\" ], values : [[ \"A\" , 1 ], [ \"B\" , 2 ]] } await dv . query ( \"TASK WHERE due\" ) => Success { type : \"task\" , values : [ task1 , task2 , ...]} dv.query accepts two additional, optional arguments: 1. file : The file path to resolve the query from (in case of references to this ). Defaults to the current file. 2. settings : Execution settings for running the query. This is largely an advanced use case (where I recommend you directly check the API implementation to see all available options).","title":"\u231b dv.query(source, [file, settings])"},{"location":"api/code-reference/#dvtryquerysource-file-settings","text":"Exactly the same as dv.query , but more convenient in short scripts as execution failures will be raised as JavaScript exceptions instead of a result type.","title":"\u231b dv.tryQuery(source, [file, settings])"},{"location":"api/code-reference/#dvquerymarkdownsource-file-settings","text":"Equivalent to dv.query() , but returns rendered Markdown. await dv . queryMarkdown ( \"LIST FROM #tag\" ) => Success { \"- [[Page 1]]\\n- [[Page 2]]\" }","title":"\u231b dv.queryMarkdown(source, [file], [settings])"},{"location":"api/code-reference/#dvtryquerymarkdownsource-file-settings","text":"Exactly the same as dv.queryMarkdown() , but throws an error on parse failure.","title":"\u231b dv.tryQueryMarkdown(source, [file], [settings])"},{"location":"api/code-reference/#dvtryevaluateexpression-context","text":"Evaluate an arbitrary dataview expression (like 2 + 2 or link(\"text\") or x * 9 ); throws an Error on parse or evaluation failure. this is an always-available implicit variable which refers to the current file. dv . tryEvaluate ( \"2 + 2\" ) => 4 dv . tryEvaluate ( \"x + 2\" , { x : 3 }) => 5 dv . tryEvaluate ( \"length(this.file.tasks)\" ) => number of tasks in the current file","title":"dv.tryEvaluate(expression, [context])"},{"location":"api/code-reference/#dvevaluateexpression-context","text":"Evaluate an arbitrary dataview expression (like 2 + 2 or link(\"text\") or x * 9 ), returning a Result object of the result. You can unwrap the result type by checking result.successful (and then fetching either result.value or result.error ). If you want a simpler API that throws an error on a failed evaluation, use dv.tryEvaluate . dv . evaluate ( \"2 + 2\" ) => Successful { value : 4 } dv . evaluate ( \"2 +\" ) => Failure { error : \"Failed to parse ... \" }","title":"dv.evaluate(expression, [context])"},{"location":"api/data-array/","text":"Data Arrays The general abstraction for lists of results in Dataview is the DataArray , which is a proxied array with additional functionality. Data arrays support indexing and iteration (via for and for ... of loops) as per normal arrays, but also include many data manipulation operators like sort , groupBy , distinct , where , and so on to make manipulating tabular data easy. Creation Data arrays are returned by most Dataview APIs that can return multiple results, such as dv.pages() . You can also explicitly convert a normal JavaScript array into a Dataview array using dv.array(<array>) . If you want to convert a Data array back to a normal array, use DataArray#array() . Indexing and Swizzling Data arrays support regular indexing just like normal arrays (like array[0] ), but importantly, they also support query-language-style \"swizzling\": if you index into a data array with a field name (like array.field ), it automatically maps every element in the array to field , flattening field if it itself is also an array. For example, dv.pages().file.name will return a data array of all file names in your vault; dv.pages(\"#books\").genres will return a flattened list of all genres in your books. Raw Interface The full interface for the data array implementation is provided below for reference: /** A function which maps an array element to some value. */ export type ArrayFunc < T , O > = ( elem : T , index : number , arr : T []) => O ; /** A function which compares two types. */ export type ArrayComparator < T > = ( a : T , b : T ) => number ; /** * Proxied interface which allows manipulating array-based data. All functions on a data array produce a NEW array * (i.e., the arrays are immutable). */ export interface DataArray < T > { /** The total number of elements in the array. */ length : number ; /** Filter the data array down to just elements which match the given predicate. */ where ( predicate : ArrayFunc < T , boolean > ) : DataArray < T > ; /** Alias for 'where' for people who want array semantics. */ filter ( predicate : ArrayFunc < T , boolean > ) : DataArray < T > ; /** Map elements in the data array by applying a function to each. */ map < U > ( f : ArrayFunc < T , U > ) : DataArray < U > ; /** Map elements in the data array by applying a function to each, then flatten the results to produce a new array. */ flatMap < U > ( f : ArrayFunc < T , U [] > ) : DataArray < U > ; /** Mutably change each value in the array, returning the same array which you can further chain off of. */ mutate ( f : ArrayFunc < T , any > ) : DataArray < any > ; /** Limit the total number of entries in the array to the given value. */ limit ( count : number ) : DataArray < T > ; /** * Take a slice of the array. If `start` is undefined, it is assumed to be 0; if `end` is undefined, it is assumbed * to be the end of the array. */ slice ( start? : number , end? : number ) : DataArray < T > ; /** Concatenate the values in this data array with those of another iterable / data array / array. */ concat ( other : Iterable < T > ) : DataArray < T > ; /** Return the first index of the given (optionally starting the search) */ indexOf ( element : T , fromIndex? : number ) : number ; /** Return the first element that satisfies the given predicate. */ find ( pred : ArrayFunc < T , boolean > ) : T | undefined ; /** Find the index of the first element that satisfies the given predicate. Returns -1 if nothing was found. */ findIndex ( pred : ArrayFunc < T , boolean > , fromIndex? : number ) : number ; /** Returns true if the array contains the given element, and false otherwise. */ includes ( element : T ) : boolean ; /** * Return a string obtained by converting each element in the array to a string, and joining it with the * given separator (which defaults to ', '). */ join ( sep? : string ) : string ; /** * Return a sorted array sorted by the given key; an optional comparator can be provided, which will * be used to compare the keys in leiu of the default dataview comparator. */ sort < U > ( key : ArrayFunc < T , U > , direction ?: \"asc\" | \"desc\" , comparator? : ArrayComparator < U > ) : DataArray < T > ; /** * Return an array where elements are grouped by the given key; the resulting array will have objects of the form * { key: <key value>, rows: DataArray }. */ groupBy < U > ( key : ArrayFunc < T , U > , comparator? : ArrayComparator < U > ) : DataArray < { key : U ; rows : DataArray < T > } > ; /** * Return distinct entries. If a key is provided, then rows with distinct keys are returned. */ distinct < U > ( key? : ArrayFunc < T , U > , comparator? : ArrayComparator < U > ) : DataArray < T > ; /** Return true if the predicate is true for all values. */ every ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return true if the predicate is true for at least one value. */ some ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return true if the predicate is FALSE for all values. */ none ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return the first element in the data array. Returns undefined if the array is empty. */ first () : T ; /** Return the last element in the data array. Returns undefined if the array is empty. */ last () : T ; /** Map every element in this data array to the given key, and then flatten it.*/ to ( key : string ) : DataArray < any > ; /** * Recursively expand the given key, flattening a tree structure based on the key into a flat array. Useful for handling * heirarchical data like tasks with 'subtasks'. */ expand ( key : string ) : DataArray < any > ; /** Run a lambda on each element in the array. */ forEach ( f : ArrayFunc < T , void > ) : void ; /** Convert this to a plain javascript array. */ array () : T []; /** Allow iterating directly over the array. */ [ Symbol . iterator ]() : Iterator < T > ; /** Map indexes to values. */ [ index : number ] : any ; /** Automatic flattening of fields. Equivalent to implicitly calling `array.to(\"field\")` */ [ field : string ] : any ; }","title":"Data Arrays"},{"location":"api/data-array/#data-arrays","text":"The general abstraction for lists of results in Dataview is the DataArray , which is a proxied array with additional functionality. Data arrays support indexing and iteration (via for and for ... of loops) as per normal arrays, but also include many data manipulation operators like sort , groupBy , distinct , where , and so on to make manipulating tabular data easy.","title":"Data Arrays"},{"location":"api/data-array/#creation","text":"Data arrays are returned by most Dataview APIs that can return multiple results, such as dv.pages() . You can also explicitly convert a normal JavaScript array into a Dataview array using dv.array(<array>) . If you want to convert a Data array back to a normal array, use DataArray#array() .","title":"Creation"},{"location":"api/data-array/#indexing-and-swizzling","text":"Data arrays support regular indexing just like normal arrays (like array[0] ), but importantly, they also support query-language-style \"swizzling\": if you index into a data array with a field name (like array.field ), it automatically maps every element in the array to field , flattening field if it itself is also an array. For example, dv.pages().file.name will return a data array of all file names in your vault; dv.pages(\"#books\").genres will return a flattened list of all genres in your books.","title":"Indexing and Swizzling"},{"location":"api/data-array/#raw-interface","text":"The full interface for the data array implementation is provided below for reference: /** A function which maps an array element to some value. */ export type ArrayFunc < T , O > = ( elem : T , index : number , arr : T []) => O ; /** A function which compares two types. */ export type ArrayComparator < T > = ( a : T , b : T ) => number ; /** * Proxied interface which allows manipulating array-based data. All functions on a data array produce a NEW array * (i.e., the arrays are immutable). */ export interface DataArray < T > { /** The total number of elements in the array. */ length : number ; /** Filter the data array down to just elements which match the given predicate. */ where ( predicate : ArrayFunc < T , boolean > ) : DataArray < T > ; /** Alias for 'where' for people who want array semantics. */ filter ( predicate : ArrayFunc < T , boolean > ) : DataArray < T > ; /** Map elements in the data array by applying a function to each. */ map < U > ( f : ArrayFunc < T , U > ) : DataArray < U > ; /** Map elements in the data array by applying a function to each, then flatten the results to produce a new array. */ flatMap < U > ( f : ArrayFunc < T , U [] > ) : DataArray < U > ; /** Mutably change each value in the array, returning the same array which you can further chain off of. */ mutate ( f : ArrayFunc < T , any > ) : DataArray < any > ; /** Limit the total number of entries in the array to the given value. */ limit ( count : number ) : DataArray < T > ; /** * Take a slice of the array. If `start` is undefined, it is assumed to be 0; if `end` is undefined, it is assumbed * to be the end of the array. */ slice ( start? : number , end? : number ) : DataArray < T > ; /** Concatenate the values in this data array with those of another iterable / data array / array. */ concat ( other : Iterable < T > ) : DataArray < T > ; /** Return the first index of the given (optionally starting the search) */ indexOf ( element : T , fromIndex? : number ) : number ; /** Return the first element that satisfies the given predicate. */ find ( pred : ArrayFunc < T , boolean > ) : T | undefined ; /** Find the index of the first element that satisfies the given predicate. Returns -1 if nothing was found. */ findIndex ( pred : ArrayFunc < T , boolean > , fromIndex? : number ) : number ; /** Returns true if the array contains the given element, and false otherwise. */ includes ( element : T ) : boolean ; /** * Return a string obtained by converting each element in the array to a string, and joining it with the * given separator (which defaults to ', '). */ join ( sep? : string ) : string ; /** * Return a sorted array sorted by the given key; an optional comparator can be provided, which will * be used to compare the keys in leiu of the default dataview comparator. */ sort < U > ( key : ArrayFunc < T , U > , direction ?: \"asc\" | \"desc\" , comparator? : ArrayComparator < U > ) : DataArray < T > ; /** * Return an array where elements are grouped by the given key; the resulting array will have objects of the form * { key: <key value>, rows: DataArray }. */ groupBy < U > ( key : ArrayFunc < T , U > , comparator? : ArrayComparator < U > ) : DataArray < { key : U ; rows : DataArray < T > } > ; /** * Return distinct entries. If a key is provided, then rows with distinct keys are returned. */ distinct < U > ( key? : ArrayFunc < T , U > , comparator? : ArrayComparator < U > ) : DataArray < T > ; /** Return true if the predicate is true for all values. */ every ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return true if the predicate is true for at least one value. */ some ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return true if the predicate is FALSE for all values. */ none ( f : ArrayFunc < T , boolean > ) : boolean ; /** Return the first element in the data array. Returns undefined if the array is empty. */ first () : T ; /** Return the last element in the data array. Returns undefined if the array is empty. */ last () : T ; /** Map every element in this data array to the given key, and then flatten it.*/ to ( key : string ) : DataArray < any > ; /** * Recursively expand the given key, flattening a tree structure based on the key into a flat array. Useful for handling * heirarchical data like tasks with 'subtasks'. */ expand ( key : string ) : DataArray < any > ; /** Run a lambda on each element in the array. */ forEach ( f : ArrayFunc < T , void > ) : void ; /** Convert this to a plain javascript array. */ array () : T []; /** Allow iterating directly over the array. */ [ Symbol . iterator ]() : Iterator < T > ; /** Map indexes to values. */ [ index : number ] : any ; /** Automatic flattening of fields. Equivalent to implicitly calling `array.to(\"field\")` */ [ field : string ] : any ; }","title":"Raw Interface"},{"location":"api/intro/","text":"Overview The Dataview JavaScript API allows for executing arbitrary JavaScript with access to the dataview indices and query engine, which is good for complex views or interop with other plugins. The API comes in two flavors: plugin facing, and user facing (or 'inline API usage'). Inline Access You can create a \"DataviewJS\" block via: ```dataviewjs dv.pages(\"#thing\")... ``` Code executed in such codeblocks have access to the dv variable, which provides the entirety of the codeblock-relevant dataview API (like dv.table() , dv.pages() , and so on). For more information, check out the codeblock API reference . Plugin Access You can access the Dataview Plugin API (from other plugins or the console) through app.plugins.plugins.dataview.api ; this API is similar to the codeblock reference, with slightly different arguments due to the lack of an implicit file to execute the queries in. For more information, check out the Plugin API reference .","title":"Overview"},{"location":"api/intro/#overview","text":"The Dataview JavaScript API allows for executing arbitrary JavaScript with access to the dataview indices and query engine, which is good for complex views or interop with other plugins. The API comes in two flavors: plugin facing, and user facing (or 'inline API usage').","title":"Overview"},{"location":"api/intro/#inline-access","text":"You can create a \"DataviewJS\" block via: ```dataviewjs dv.pages(\"#thing\")... ``` Code executed in such codeblocks have access to the dv variable, which provides the entirety of the codeblock-relevant dataview API (like dv.table() , dv.pages() , and so on). For more information, check out the codeblock API reference .","title":"Inline Access"},{"location":"api/intro/#plugin-access","text":"You can access the Dataview Plugin API (from other plugins or the console) through app.plugins.plugins.dataview.api ; this API is similar to the codeblock reference, with slightly different arguments due to the lack of an implicit file to execute the queries in. For more information, check out the Plugin API reference .","title":"Plugin Access"},{"location":"queries/data-commands/","text":"Data Commands The different commands that dataview queries can be made up of. Commands are executed in order, and you can have duplicate commands (so multiple WHERE blocks or multiple GROUP BY blocks, for example). FROM The FROM statement determines what pages will initially be collected and passed onto the other commands for further filtering. You can select from any source , which currently means by folder, by tag, or by incoming/outgoing links. Tags : To select from a tag (and all its subtags), use FROM #tag . Folders : To select from a folder (and all its subfolders), use FROM \"folder\" . Single Files : To select from a single file, use FROM \"path/to/file\" . Links : You can either select links TO a file, or all links FROM a file. To obtain all pages which link TO [[note]] , use FROM [[note]] . To obtain all pages which link FROM [[note]] (i.e., all the links in that file), use FROM outgoing([[note]]) . You can compose these filters in order to get more advanced sources using and and or . For example, #tag and \"folder\" will return all pages in folder and with #tag . [[Food]] or [[Exercise]] will give any pages which link to [[Food]] OR [[Exercise]] . You can also \"negate\" sources to obtain anything that does NOT match a source using - : -#tag will exclude files which have the given tag. #tag and -\"folder\" will only include files tagged #tag which are NOT in \"folder\" . WHERE Filter pages on fields. Only pages where the clause evaluates to true will be yielded. WHERE <clause> Obtain all files which were modified in the last 24 hours: LIST WHERE file . mtime >= date ( today ) - dur ( 1 day ) Find all projects which are not marked complete and are more than a month old: LIST FROM # projects WHERE ! completed AND file . ctime <= date ( today ) - dur ( 1 month ) SORT Sorts all results by one or more fields. SORT date [ASCENDING/DESCENDING/ASC/DESC] You can also give multiple fields to sort by. Sorting will be done based on the first field. Then, if a tie occurs, the second field will be used to sort the tied fields. If there is still a tie, the third sort will resolve it, and so on. SORT field1 [ASCENDING/DESCENDING/ASC/DESC], ..., fieldN [ASC/DESC] GROUP BY Group all results on a field. Yields one row per unique field value, which has 2 properties: one corresponding to the field being grouped on, and a rows array field which contains all of the pages that matched. GROUP BY field GROUP BY (computed_field) AS name In order to make working with the rows array easier, Dataview supports field \"swizzling\". If you want the field test from every object in the rows array, then rows.test will automatically fetch the test field from every object in rows , yielding a new array. You can then apply aggregation operators like sum() over the resulting array. FLATTEN Flatten an array in every row, yielding one result row per entry in the array. FLATTEN field FLATTEN (computed_field) AS name For example, flatten the authors field in each literature note to give one row per author: Query TABLE authors FROM # LiteratureNote FLATTEN authors Output File authors stegEnvironmentalPsychologyIntroduction2018 SN Steg, L. stegEnvironmentalPsychologyIntroduction2018 SN Van den Berg, A. E. stegEnvironmentalPsychologyIntroduction2018 SN De Groot, J. I. M. Soap Dragons SN Robert Lamb Soap Dragons SN Joe McCormick smithPainAssaultSelf2007 SN Jonathan A. Smith smithPainAssaultSelf2007 SN Mike Osborn A good use of this would be when there is a deeply nested list that you want to use more easily. For example, file.lists or file.tasks . Note the simpler query though the end results are slightly different (grouped vs non-grouped). You can use a GROUP BY file.link to achieve identical results but would need to use rows.T.text as described earlier. table T.text as \"Task Text\" from \"Scratchpad\" flatten file.tasks as T where T.text table filter(file.tasks.text, (t) => t) as \"Task Text\" from \"Scratchpad\" where file.tasks.text FLATTEN makes it easier to operate on nested lists since you can then use simpler where conditions on them as opposed to using functions like map() or filter() . LIMIT Restrict the results to at most N values. LIMIT 5 Commands are processed in the order they are written, so the following sorts the results after they have already been limited: LIMIT 5 SORT date ASCENDING","title":"Data Commands"},{"location":"queries/data-commands/#data-commands","text":"The different commands that dataview queries can be made up of. Commands are executed in order, and you can have duplicate commands (so multiple WHERE blocks or multiple GROUP BY blocks, for example).","title":"Data Commands"},{"location":"queries/data-commands/#from","text":"The FROM statement determines what pages will initially be collected and passed onto the other commands for further filtering. You can select from any source , which currently means by folder, by tag, or by incoming/outgoing links. Tags : To select from a tag (and all its subtags), use FROM #tag . Folders : To select from a folder (and all its subfolders), use FROM \"folder\" . Single Files : To select from a single file, use FROM \"path/to/file\" . Links : You can either select links TO a file, or all links FROM a file. To obtain all pages which link TO [[note]] , use FROM [[note]] . To obtain all pages which link FROM [[note]] (i.e., all the links in that file), use FROM outgoing([[note]]) . You can compose these filters in order to get more advanced sources using and and or . For example, #tag and \"folder\" will return all pages in folder and with #tag . [[Food]] or [[Exercise]] will give any pages which link to [[Food]] OR [[Exercise]] . You can also \"negate\" sources to obtain anything that does NOT match a source using - : -#tag will exclude files which have the given tag. #tag and -\"folder\" will only include files tagged #tag which are NOT in \"folder\" .","title":"FROM"},{"location":"queries/data-commands/#where","text":"Filter pages on fields. Only pages where the clause evaluates to true will be yielded. WHERE <clause> Obtain all files which were modified in the last 24 hours: LIST WHERE file . mtime >= date ( today ) - dur ( 1 day ) Find all projects which are not marked complete and are more than a month old: LIST FROM # projects WHERE ! completed AND file . ctime <= date ( today ) - dur ( 1 month )","title":"WHERE"},{"location":"queries/data-commands/#sort","text":"Sorts all results by one or more fields. SORT date [ASCENDING/DESCENDING/ASC/DESC] You can also give multiple fields to sort by. Sorting will be done based on the first field. Then, if a tie occurs, the second field will be used to sort the tied fields. If there is still a tie, the third sort will resolve it, and so on. SORT field1 [ASCENDING/DESCENDING/ASC/DESC], ..., fieldN [ASC/DESC]","title":"SORT"},{"location":"queries/data-commands/#group-by","text":"Group all results on a field. Yields one row per unique field value, which has 2 properties: one corresponding to the field being grouped on, and a rows array field which contains all of the pages that matched. GROUP BY field GROUP BY (computed_field) AS name In order to make working with the rows array easier, Dataview supports field \"swizzling\". If you want the field test from every object in the rows array, then rows.test will automatically fetch the test field from every object in rows , yielding a new array. You can then apply aggregation operators like sum() over the resulting array.","title":"GROUP BY"},{"location":"queries/data-commands/#flatten","text":"Flatten an array in every row, yielding one result row per entry in the array. FLATTEN field FLATTEN (computed_field) AS name For example, flatten the authors field in each literature note to give one row per author: Query TABLE authors FROM # LiteratureNote FLATTEN authors Output File authors stegEnvironmentalPsychologyIntroduction2018 SN Steg, L. stegEnvironmentalPsychologyIntroduction2018 SN Van den Berg, A. E. stegEnvironmentalPsychologyIntroduction2018 SN De Groot, J. I. M. Soap Dragons SN Robert Lamb Soap Dragons SN Joe McCormick smithPainAssaultSelf2007 SN Jonathan A. Smith smithPainAssaultSelf2007 SN Mike Osborn A good use of this would be when there is a deeply nested list that you want to use more easily. For example, file.lists or file.tasks . Note the simpler query though the end results are slightly different (grouped vs non-grouped). You can use a GROUP BY file.link to achieve identical results but would need to use rows.T.text as described earlier. table T.text as \"Task Text\" from \"Scratchpad\" flatten file.tasks as T where T.text table filter(file.tasks.text, (t) => t) as \"Task Text\" from \"Scratchpad\" where file.tasks.text FLATTEN makes it easier to operate on nested lists since you can then use simpler where conditions on them as opposed to using functions like map() or filter() .","title":"FLATTEN"},{"location":"queries/data-commands/#limit","text":"Restrict the results to at most N values. LIMIT 5 Commands are processed in the order they are written, so the following sorts the results after they have already been limited: LIMIT 5 SORT date ASCENDING","title":"LIMIT"},{"location":"queries/dql-js-inline/","text":"DQL, JS and Inlines Once you've added useful data to relevant pages , you'll want to actually display it somewhere or operate on it. Dataview allows this in four different ways, all of which are written in codeblocks directly in your Markdown and live-reloaded when your vault changes. Dataview Query Language (DQL) The Dataview Query Language (for short DQL ) is a SQL-like language and Dataviews core functionality. It supports four Query Types to produce different outputs, data commands to refine, resort or group your result and plentiful functions which allow numerous operations and adjustments to achieve your wanted output. You create a DQL query with a codeblock that uses dataview as type: ```dataview TABLE rating AS \"Rating\", summary AS \"Summary\" FROM #games SORT rating DESC ``` Use backticks A valid codeblock needs to use backticks (`) on start and end (three each). Do not confuse the backtick with the similar looking apostrophe ' ! Find a explanation how to write a DQL Query under the query language reference . If you learn better by example, take a look at the query examples . Inline DQL A Inline DQL uses a inline block format instead of a code block and a configurable prefix to mark this inline code block as a DQL block. `= this.file.name` Change of DQL prefix You can change the = to another token (like dv: or ~ ) in Dataviews' settings under \"Codeblock Settings\" > \"Inline Query Prefix\" Inline DQL Queries display exactly one value somewhere in the middle of your note. They seamlessly blend into the content of your note: Today is `= date(today)` - `= [[exams]].deadline - date(today)` until exams! would, for example, render to Today is November 07, 2022 - 2 months, 5 days until exams! Inline DQL cannot query multiple pages. They always display exactly one value, not a list (or table) of values. You can either access the properties of the current page via prefix this. or a different page via [[linkToPage]] . `= this.file.name` `= this.file.mtime` `= this.someMetadataField` `= [[secondPage]].file.name` `= [[secondPage]].file.mtime` `= [[secondPage]].someMetadataField` You can use everything available as expressions and literals in an Inline DQL Query, including functions . Query Types and Data Commands, on the other hand, are not available in Inlines. Assignment due in `= this.due - date(today)` Final paper due in `= [[Computer Science Theory]].due - date(today)` \ud83c\udfc3\u200d\u2642\ufe0f Goal reached? `= choice(this.steps > 10000, \"YES!\", \"**No**, get moving!\")` You have `= length(filter(link(dateformat(date(today), \"yyyy-MM-dd\")).file.tasks, (t) => !t.completed))` tasks to do. `= choice(date(today).weekday > 5, \"Take it easy!\", \"Time to get work done!\")` Dataview JS The dataview JavaScript API gives you the full power of JavaScript and provides a DSL for pulling Dataview data and executing queries, allowing you to create arbitrarily complex queries and views. Similar to the query language, you create Dataview JS blocks via a dataviewjs -annotated codeblock: ``` dataviewjs let pages = dv . pages ( \"#books and -#books/finished\" ). where ( b => b . rating >= 7 ); for ( let group of pages . groupBy ( b => b . genre )) { dv . header ( 3 , group . key ); dv . list ( group . rows . file . name ); } ``` Inside of a JS dataview block, you have access to the full dataview API via the dv variable. For an explanation of what you can do with it, see the API documentation , or the API examples . Advanced usage Writing Javascript queries is a advanced technique that requires understanding in programming and JS. Please be aware that JS Queries have access to your file system and be cautious when using other peopless' JS Queries, especially when they are not publicy shared through the Obsidian Community. Inline Dataview JS Similar to the query language, you can write JS inline queries, which let you embed a computed JS value directly. You create JS inline queries via inline code blocks: `$= dv.current().file.mtime` In inline DataviewJS, you have access to the dv variable, as in dataviewjs codeblocks, and can make all of the same calls. The result should be something which evaluates to a JavaScript value, which Dataview will automatically render appropriately. Unline Inline DQL queries, Inline JS queries do have access to everything a Dataview JS Query has available and can hence query and output multiple pages. Change of Inline JS prefix You can change the $= to another token (like dvjs: or $~ ) in Dataviews' settings under \"Codeblock Settings\" > \"Javascript Inline Query Prefix\"","title":"DQL, JS and Inlines"},{"location":"queries/dql-js-inline/#dql-js-and-inlines","text":"Once you've added useful data to relevant pages , you'll want to actually display it somewhere or operate on it. Dataview allows this in four different ways, all of which are written in codeblocks directly in your Markdown and live-reloaded when your vault changes.","title":"DQL, JS and Inlines"},{"location":"queries/dql-js-inline/#dataview-query-language-dql","text":"The Dataview Query Language (for short DQL ) is a SQL-like language and Dataviews core functionality. It supports four Query Types to produce different outputs, data commands to refine, resort or group your result and plentiful functions which allow numerous operations and adjustments to achieve your wanted output. You create a DQL query with a codeblock that uses dataview as type: ```dataview TABLE rating AS \"Rating\", summary AS \"Summary\" FROM #games SORT rating DESC ``` Use backticks A valid codeblock needs to use backticks (`) on start and end (three each). Do not confuse the backtick with the similar looking apostrophe ' ! Find a explanation how to write a DQL Query under the query language reference . If you learn better by example, take a look at the query examples .","title":"Dataview Query Language (DQL)"},{"location":"queries/dql-js-inline/#inline-dql","text":"A Inline DQL uses a inline block format instead of a code block and a configurable prefix to mark this inline code block as a DQL block. `= this.file.name` Change of DQL prefix You can change the = to another token (like dv: or ~ ) in Dataviews' settings under \"Codeblock Settings\" > \"Inline Query Prefix\" Inline DQL Queries display exactly one value somewhere in the middle of your note. They seamlessly blend into the content of your note: Today is `= date(today)` - `= [[exams]].deadline - date(today)` until exams! would, for example, render to Today is November 07, 2022 - 2 months, 5 days until exams! Inline DQL cannot query multiple pages. They always display exactly one value, not a list (or table) of values. You can either access the properties of the current page via prefix this. or a different page via [[linkToPage]] . `= this.file.name` `= this.file.mtime` `= this.someMetadataField` `= [[secondPage]].file.name` `= [[secondPage]].file.mtime` `= [[secondPage]].someMetadataField` You can use everything available as expressions and literals in an Inline DQL Query, including functions . Query Types and Data Commands, on the other hand, are not available in Inlines. Assignment due in `= this.due - date(today)` Final paper due in `= [[Computer Science Theory]].due - date(today)` \ud83c\udfc3\u200d\u2642\ufe0f Goal reached? `= choice(this.steps > 10000, \"YES!\", \"**No**, get moving!\")` You have `= length(filter(link(dateformat(date(today), \"yyyy-MM-dd\")).file.tasks, (t) => !t.completed))` tasks to do. `= choice(date(today).weekday > 5, \"Take it easy!\", \"Time to get work done!\")`","title":"Inline DQL"},{"location":"queries/dql-js-inline/#dataview-js","text":"The dataview JavaScript API gives you the full power of JavaScript and provides a DSL for pulling Dataview data and executing queries, allowing you to create arbitrarily complex queries and views. Similar to the query language, you create Dataview JS blocks via a dataviewjs -annotated codeblock: ``` dataviewjs let pages = dv . pages ( \"#books and -#books/finished\" ). where ( b => b . rating >= 7 ); for ( let group of pages . groupBy ( b => b . genre )) { dv . header ( 3 , group . key ); dv . list ( group . rows . file . name ); } ``` Inside of a JS dataview block, you have access to the full dataview API via the dv variable. For an explanation of what you can do with it, see the API documentation , or the API examples . Advanced usage Writing Javascript queries is a advanced technique that requires understanding in programming and JS. Please be aware that JS Queries have access to your file system and be cautious when using other peopless' JS Queries, especially when they are not publicy shared through the Obsidian Community.","title":"Dataview JS"},{"location":"queries/dql-js-inline/#inline-dataview-js","text":"Similar to the query language, you can write JS inline queries, which let you embed a computed JS value directly. You create JS inline queries via inline code blocks: `$= dv.current().file.mtime` In inline DataviewJS, you have access to the dv variable, as in dataviewjs codeblocks, and can make all of the same calls. The result should be something which evaluates to a JavaScript value, which Dataview will automatically render appropriately. Unline Inline DQL queries, Inline JS queries do have access to everything a Dataview JS Query has available and can hence query and output multiple pages. Change of Inline JS prefix You can change the $= to another token (like dvjs: or $~ ) in Dataviews' settings under \"Codeblock Settings\" > \"Javascript Inline Query Prefix\"","title":"Inline Dataview JS"},{"location":"queries/query-types/","text":"Query Types The Query Type determines how the output of your dataview query looks like. It is the first and only mandatory specification you give to a dataview query. There are four available: LIST , TABLE , TASK and CALENDAR . The Query Type also determine on which information level a query is executed. LIST , TABLE and CALENDAR operate on page level , whereas TASK queries operate on file.tasks level. More on that on the TASK Query Type. You can combine every Query Type with all available Data Commands to refine your result set. Read more about the interconnection between Query Types and Data Commands on How to Use Dataview and the structure page . Query Type The Query Type determines the output format of a query. It's the only mandatory information for a query. LIST LIST queries output a bullet point list consisting out of your file links or the group name, if you decided to group . You can specify up to one additional information to output alongside with your file or group information. Query Type LIST LIST outputs a bullet point list of page links or Group keys. You can specify one additional information to show for each result. The most minimal LIST query outputs a bullet point list of all files in your vault: ```dataview LIST ``` Output Classic Cheesecake Git Basics How to fix Git Cheatsheet League of Legends Pillars of Eternity 2 Stardew Valley Dashboard but you can, of course, use data commands to restrict which pages you want to have listed: ```dataview LIST FROM #games/mobas OR #games/crpg ``` Output League of Legends Pillars of Eternity 2 Output an additional information To add a additional information to your query, specify it right after the LIST command and before possibly available data commands: ```dataview LIST file.folder ``` Output Classic Cheesecake : Baking/Recipes Git Basics : Coding How to fix Git Cheatsheet : Coding/Cheatsheets League of Legends : Games Pillars of Eternity 2 : Games Stardew Valley : Games/finished Dashboard : You can only add one additional information, not multiple. But you can specify a computed value instead of a plain meta data field, which can contain information of multiple fields: ```dataview LIST \"File Path: \" + file.folder + \" _(created: \" + file.cday + \")_\" FROM \"Games\" ``` Output League of Legends : File Path: Games (created: May 13, 2021) Pillars of Eternity 2 : File Path: Games (created: Februrary 02, 2022) Stardew Valley : File Path: Games/finished (created: April 04, 2021) Grouping A grouped list shows their group keys, and only the group keys, by default: ```dataview LIST GROUP BY type ``` Output game knowledge moc recipe summary A common use-case on grouped LIST queries is to add the file links to the output by specifying them as the additional information: ```dataview LIST rows.file.link GROUP BY type ``` game: Stardew Valley League of Legends Pillars of Eternity 2 knowledge: Git Basics moc: Dashboard recipe: Classic Cheesecake summary: How to fix Git Cheatsheet LIST WITHOUT ID If you don't want the file name or group key included in the list view, you can use LIST WITHOUT ID . LIST WITHOUT ID works the same as LIST , but it does not output the file link or group name if you add an additional information. ```dataview LIST WITHOUT ID ``` Output Classic Cheesecake Git Basics How to fix Git Cheatsheet League of Legends Pillars of Eternity 2 Stardew Valley Dashboard It's the same as LIST , because it does not contain an additional information! ```dataview LIST WITHOUT ID type ``` Output moc recipe summary knowledge game game game LIST WITHOUT ID can be handy if you want to output computed values, for example. ```dataview LIST WITHOUT ID length(rows) + \" pages of type \" + key GROUP BY type ``` Output 3 pages of type game 1 pages of type knowledge 1 pages of type moc 1 pages of type recipe 1 pages of type summary TABLE The TABLE query types outputs page data as a tabular view. You can add zero to multiple meta data fields to your TABLE query by adding them as a comma separated list . You can not only use plain meta data fields as columns, but specify calculations as well. Optionally, you can specify a table header via the AS <header> syntax. Like all other query types, you can refine your result set for your query with data commands . TABLE Query Type TABLE queries render a tabular view of any number of meta data values or calculations. It is possible to specify column headers via AS <header> . ```dataview TABLE ``` Output File (7) Classic Cheesecake Git Basics How to fix Git Cheatsheet League of Legends Pillars of Eternity 2 Stardew Valley Dashboard Changing the first column header name You can change the name of the first column header (by default \"File\" or \"Group\") via the Dataview Settings under Table Settings -> Primary Column Name / Group Column Name. If you want to change the name only for one specific TABLE query, have a look at TABLE WITHOUT ID . Disabling Result count The first column always shows the result count. If you do not want to get it displayed, you can use a CSS Snippet to hide it. Head over to the FAQ for more info. Of course, a TABLE is made for specifying one to multiple additional informations: ```dataview TABLE started, file.folder, file.etags FROM #games ``` Output File (3) started file.folder file.etags League of Legends May 16, 2021 Games - #games/moba Pillars of Eternity 2 April 21, 2022 Games - #games/crpg Stardew Valley April 04, 2021 Games/finished - #games/simulation Implicit fields Curious about file.folder and file.etags ? Learn more about implicit fields on pages . Custom Column Headers You can specify custom headings for your columns by using the AS syntax: ```dataview TABLE started, file.folder AS Path, file.etags AS \"File Tags\" FROM #games ``` Output File (3) started Path File Tags League of Legends May 16, 2021 Games - #games/moba Pillars of Eternity 2 April 21, 2022 Games - #games/crpg Stardew Valley April 04, 2021 Games/finished - #games/simulation Custom headers with spaces If you want to use a custom header with spaces, like File Tags , you need to wrap it into double quotes: \"File Tags\" . This is especially useful when you want to use calculations or expressions as column values : ```dataview TABLE default(finished, date(today)) - started AS \"Played for\", file.folder AS Path, file.etags AS \"File Tags\" FROM #games ``` Output File (3) Played for Path File Tags League of Legends 1 years, 6 months, 1 weeks Games - #games/moba Pillars of Eternity 2 7 months, 2 days Games - #games/crpg Stardew Valley 4 months, 3 weeks, 3 days Games/finished - #games/simulation Calculations and expressions Learn more about the capability of computing expressions and calculations under expressions and functions . TABLE WITHOUT ID If you don't want the first column (\"File\" or \"Group\" by default), you can use TABLE WITHOUT ID . TABLE WITHOUT ID works the same as TABLE , but it does not output the file link or group name as a first column if you add additional information. You can use this if you, for example, output another identifying value: ```dataview TABLE WITHOUT ID steamid, file.etags AS \"File Tags\" FROM #games ``` Output steamid (3) File Tags 560130 - #games/crog - - #games/moba 413150 - #games/simulation Also, you can use TABLE WITHOUT ID if you want to rename the first column for one specific query . ```dataview TABLE WITHOUT ID file.link AS \"Game\", file.etags AS \"File Tags\" FROM #games ``` Output Game (3) File Tags League of Legends - #games/moba Pillars of Eternity 2 - #games/crpg Stardew Valley - #games/simulation Renaming the first column in general If you want to rename the first column in all cases, change the name in Dataviews settings under Table Settings. TASK The TASK Query outputs a interactive list of all tasks in your vault that match the given data commands (if any). TASK Queries are special compared to the other Query Types because they do give back Tasks as results and not pages . This implies that all data commands operate on Task level and makes it possible to fine granularly filter your tasks for i.e. their status or a meta data specified on the task itself. Also, TASK Queries are the only possibility to manipulate your files through DQL . Normally, Dataview does not touch the content of your files; however, if you check a task through a dataview query, it'll get checked in its original file, too . In the Dataview Settings under \"Task Settings\", you can opt-in to automatically set a completion meta data field when checking a task in dataview. Mind though that this only works if you check the task inside a dataview block. TASK Query Type TASK queries render an interactive list of all tasks in your vault. TASK Queries are executed on task level , not page level, allowing for task-specific filtering. This is the only command in dataview that modifies your original files if interacted with. ```dataview TASK ``` Output Buy new shoes #shopping Mail Paul about training schedule Finish the math assignment Finish Paper 1 [due:: 2022-08-13] Read again through chapter 3 [due:: 2022-09-01] Write a cheatsheet [due:: 2022-08-02] Write a summary of chapter 1-4 [due:: 2022-09-12] Hand in physics Get new pillows for mom #shopping Buy some working pencils #shopping You can use data commands like for all other Query Types. Data Commands are executed on task level, making implicit fields on tasks directly available. ```dataview TASK WHERE !completed AND contains(tags, \"#shopping\") ``` Output Buy new shoes #shopping Get new pillows for mom #shopping A common use case for tasks is to group tasks by their originating file : ```dataview TASK WHERE !completed GROUP BY file.link ``` Output 2022-07-30 (1) Finish the math assignment Read again through chapter 3 [due:: 2022-09-01] Write a summary of chapter 1-4 [due:: 2022-09-12] 2022-09-21 (2) Buy new shoes #shopping Mail Paul about training schedule 2022-09-27 (1) Get new pillows for mom #shopping Counting tasks with subtask Noticing the (1) on the header of 2022-07-30 ? Child tasks belong to their parent task and are not counted separately. Also, they do behave differently on filtering. Child Tasks A task is considered child task if it is intended by a tab and below a not indented task list item. clean up the house kitchen living room Bedroom [urgent:: true] Childs of a bullet point item While intended tasks under a bullet point item are strictly speaking also children task, dataview will handle them like normal tasks in most cases. Child Tasks belong to their parent . This means if you're querying for tasks, you'll get child tasks as part of their parent back. ```dataview TASK ``` Output clean up the house kitchen living room Bedroom [urgent:: true] Call the insurance about the car Find out the transaction number This especially means that child task will be part of your result set as long as the parent matches the query - even if the child task itself doesn't. ```dataview TASK WHERE !completed ``` Output clean up the house kitchen living room Bedroom [urgent:: true] Call the insurance about the car Mind that you'll get individual children tasks back, if the child matches your predicate but the parent doesn't: ```dataview TASK WHERE urgent ``` Output Bedroom [urgent:: true] CALENDAR The CALENDAR Query outputs a monthly based calendar where every result is depicted as a dot on it reffering date. The CALENDAR is the only Query Type that requires an additional information. This additional information needs to be a date (or unset) on all queried pages. CALENDAR Query Type The CALENDAR Query Types renders a calendar view where every result is represented by a dot on the given meta data field date. ```dataview CALENDAR file.ctime ``` Output While it is possible to use SORT and GROUP BY in combination with CALENDAR , it has no effect . Additionally, the calendar query does not render if the given meta data field contains something else than a valid date (but the field can be empty). To make sure you're only taking valid pages into account, you can filter for valid meta data values: ```dataview CALENDAR due WHERE typeof(due) = \"date\" ```","title":"Query Types"},{"location":"queries/query-types/#query-types","text":"The Query Type determines how the output of your dataview query looks like. It is the first and only mandatory specification you give to a dataview query. There are four available: LIST , TABLE , TASK and CALENDAR . The Query Type also determine on which information level a query is executed. LIST , TABLE and CALENDAR operate on page level , whereas TASK queries operate on file.tasks level. More on that on the TASK Query Type. You can combine every Query Type with all available Data Commands to refine your result set. Read more about the interconnection between Query Types and Data Commands on How to Use Dataview and the structure page . Query Type The Query Type determines the output format of a query. It's the only mandatory information for a query.","title":"Query Types"},{"location":"queries/query-types/#list","text":"LIST queries output a bullet point list consisting out of your file links or the group name, if you decided to group . You can specify up to one additional information to output alongside with your file or group information. Query Type LIST LIST outputs a bullet point list of page links or Group keys. You can specify one additional information to show for each result. The most minimal LIST query outputs a bullet point list of all files in your vault: ```dataview LIST ``` Output Classic Cheesecake Git Basics How to fix Git Cheatsheet League of Legends Pillars of Eternity 2 Stardew Valley Dashboard but you can, of course, use data commands to restrict which pages you want to have listed: ```dataview LIST FROM #games/mobas OR #games/crpg ``` Output League of Legends Pillars of Eternity 2","title":"LIST"},{"location":"queries/query-types/#output-an-additional-information","text":"To add a additional information to your query, specify it right after the LIST command and before possibly available data commands: ```dataview LIST file.folder ``` Output Classic Cheesecake : Baking/Recipes Git Basics : Coding How to fix Git Cheatsheet : Coding/Cheatsheets League of Legends : Games Pillars of Eternity 2 : Games Stardew Valley : Games/finished Dashboard : You can only add one additional information, not multiple. But you can specify a computed value instead of a plain meta data field, which can contain information of multiple fields: ```dataview LIST \"File Path: \" + file.folder + \" _(created: \" + file.cday + \")_\" FROM \"Games\" ``` Output League of Legends : File Path: Games (created: May 13, 2021) Pillars of Eternity 2 : File Path: Games (created: Februrary 02, 2022) Stardew Valley : File Path: Games/finished (created: April 04, 2021)","title":"Output an additional information"},{"location":"queries/query-types/#grouping","text":"A grouped list shows their group keys, and only the group keys, by default: ```dataview LIST GROUP BY type ``` Output game knowledge moc recipe summary A common use-case on grouped LIST queries is to add the file links to the output by specifying them as the additional information: ```dataview LIST rows.file.link GROUP BY type ``` game: Stardew Valley League of Legends Pillars of Eternity 2 knowledge: Git Basics moc: Dashboard recipe: Classic Cheesecake summary: How to fix Git Cheatsheet","title":"Grouping"},{"location":"queries/query-types/#list-without-id","text":"If you don't want the file name or group key included in the list view, you can use LIST WITHOUT ID . LIST WITHOUT ID works the same as LIST , but it does not output the file link or group name if you add an additional information. ```dataview LIST WITHOUT ID ``` Output Classic Cheesecake Git Basics How to fix Git Cheatsheet League of Legends Pillars of Eternity 2 Stardew Valley Dashboard It's the same as LIST , because it does not contain an additional information! ```dataview LIST WITHOUT ID type ``` Output moc recipe summary knowledge game game game LIST WITHOUT ID can be handy if you want to output computed values, for example. ```dataview LIST WITHOUT ID length(rows) + \" pages of type \" + key GROUP BY type ``` Output 3 pages of type game 1 pages of type knowledge 1 pages of type moc 1 pages of type recipe 1 pages of type summary","title":"LIST WITHOUT ID"},{"location":"queries/query-types/#table","text":"The TABLE query types outputs page data as a tabular view. You can add zero to multiple meta data fields to your TABLE query by adding them as a comma separated list . You can not only use plain meta data fields as columns, but specify calculations as well. Optionally, you can specify a table header via the AS <header> syntax. Like all other query types, you can refine your result set for your query with data commands . TABLE Query Type TABLE queries render a tabular view of any number of meta data values or calculations. It is possible to specify column headers via AS <header> . ```dataview TABLE ``` Output File (7) Classic Cheesecake Git Basics How to fix Git Cheatsheet League of Legends Pillars of Eternity 2 Stardew Valley Dashboard Changing the first column header name You can change the name of the first column header (by default \"File\" or \"Group\") via the Dataview Settings under Table Settings -> Primary Column Name / Group Column Name. If you want to change the name only for one specific TABLE query, have a look at TABLE WITHOUT ID . Disabling Result count The first column always shows the result count. If you do not want to get it displayed, you can use a CSS Snippet to hide it. Head over to the FAQ for more info. Of course, a TABLE is made for specifying one to multiple additional informations: ```dataview TABLE started, file.folder, file.etags FROM #games ``` Output File (3) started file.folder file.etags League of Legends May 16, 2021 Games - #games/moba Pillars of Eternity 2 April 21, 2022 Games - #games/crpg Stardew Valley April 04, 2021 Games/finished - #games/simulation Implicit fields Curious about file.folder and file.etags ? Learn more about implicit fields on pages .","title":"TABLE"},{"location":"queries/query-types/#custom-column-headers","text":"You can specify custom headings for your columns by using the AS syntax: ```dataview TABLE started, file.folder AS Path, file.etags AS \"File Tags\" FROM #games ``` Output File (3) started Path File Tags League of Legends May 16, 2021 Games - #games/moba Pillars of Eternity 2 April 21, 2022 Games - #games/crpg Stardew Valley April 04, 2021 Games/finished - #games/simulation Custom headers with spaces If you want to use a custom header with spaces, like File Tags , you need to wrap it into double quotes: \"File Tags\" . This is especially useful when you want to use calculations or expressions as column values : ```dataview TABLE default(finished, date(today)) - started AS \"Played for\", file.folder AS Path, file.etags AS \"File Tags\" FROM #games ``` Output File (3) Played for Path File Tags League of Legends 1 years, 6 months, 1 weeks Games - #games/moba Pillars of Eternity 2 7 months, 2 days Games - #games/crpg Stardew Valley 4 months, 3 weeks, 3 days Games/finished - #games/simulation Calculations and expressions Learn more about the capability of computing expressions and calculations under expressions and functions .","title":"Custom Column Headers"},{"location":"queries/query-types/#table-without-id","text":"If you don't want the first column (\"File\" or \"Group\" by default), you can use TABLE WITHOUT ID . TABLE WITHOUT ID works the same as TABLE , but it does not output the file link or group name as a first column if you add additional information. You can use this if you, for example, output another identifying value: ```dataview TABLE WITHOUT ID steamid, file.etags AS \"File Tags\" FROM #games ``` Output steamid (3) File Tags 560130 - #games/crog - - #games/moba 413150 - #games/simulation Also, you can use TABLE WITHOUT ID if you want to rename the first column for one specific query . ```dataview TABLE WITHOUT ID file.link AS \"Game\", file.etags AS \"File Tags\" FROM #games ``` Output Game (3) File Tags League of Legends - #games/moba Pillars of Eternity 2 - #games/crpg Stardew Valley - #games/simulation Renaming the first column in general If you want to rename the first column in all cases, change the name in Dataviews settings under Table Settings.","title":"TABLE WITHOUT ID"},{"location":"queries/query-types/#task","text":"The TASK Query outputs a interactive list of all tasks in your vault that match the given data commands (if any). TASK Queries are special compared to the other Query Types because they do give back Tasks as results and not pages . This implies that all data commands operate on Task level and makes it possible to fine granularly filter your tasks for i.e. their status or a meta data specified on the task itself. Also, TASK Queries are the only possibility to manipulate your files through DQL . Normally, Dataview does not touch the content of your files; however, if you check a task through a dataview query, it'll get checked in its original file, too . In the Dataview Settings under \"Task Settings\", you can opt-in to automatically set a completion meta data field when checking a task in dataview. Mind though that this only works if you check the task inside a dataview block. TASK Query Type TASK queries render an interactive list of all tasks in your vault. TASK Queries are executed on task level , not page level, allowing for task-specific filtering. This is the only command in dataview that modifies your original files if interacted with. ```dataview TASK ``` Output Buy new shoes #shopping Mail Paul about training schedule Finish the math assignment Finish Paper 1 [due:: 2022-08-13] Read again through chapter 3 [due:: 2022-09-01] Write a cheatsheet [due:: 2022-08-02] Write a summary of chapter 1-4 [due:: 2022-09-12] Hand in physics Get new pillows for mom #shopping Buy some working pencils #shopping You can use data commands like for all other Query Types. Data Commands are executed on task level, making implicit fields on tasks directly available. ```dataview TASK WHERE !completed AND contains(tags, \"#shopping\") ``` Output Buy new shoes #shopping Get new pillows for mom #shopping A common use case for tasks is to group tasks by their originating file : ```dataview TASK WHERE !completed GROUP BY file.link ``` Output 2022-07-30 (1) Finish the math assignment Read again through chapter 3 [due:: 2022-09-01] Write a summary of chapter 1-4 [due:: 2022-09-12] 2022-09-21 (2) Buy new shoes #shopping Mail Paul about training schedule 2022-09-27 (1) Get new pillows for mom #shopping Counting tasks with subtask Noticing the (1) on the header of 2022-07-30 ? Child tasks belong to their parent task and are not counted separately. Also, they do behave differently on filtering.","title":"TASK"},{"location":"queries/query-types/#child-tasks","text":"A task is considered child task if it is intended by a tab and below a not indented task list item. clean up the house kitchen living room Bedroom [urgent:: true] Childs of a bullet point item While intended tasks under a bullet point item are strictly speaking also children task, dataview will handle them like normal tasks in most cases. Child Tasks belong to their parent . This means if you're querying for tasks, you'll get child tasks as part of their parent back. ```dataview TASK ``` Output clean up the house kitchen living room Bedroom [urgent:: true] Call the insurance about the car Find out the transaction number This especially means that child task will be part of your result set as long as the parent matches the query - even if the child task itself doesn't. ```dataview TASK WHERE !completed ``` Output clean up the house kitchen living room Bedroom [urgent:: true] Call the insurance about the car Mind that you'll get individual children tasks back, if the child matches your predicate but the parent doesn't: ```dataview TASK WHERE urgent ``` Output Bedroom [urgent:: true]","title":"Child Tasks"},{"location":"queries/query-types/#calendar","text":"The CALENDAR Query outputs a monthly based calendar where every result is depicted as a dot on it reffering date. The CALENDAR is the only Query Type that requires an additional information. This additional information needs to be a date (or unset) on all queried pages. CALENDAR Query Type The CALENDAR Query Types renders a calendar view where every result is represented by a dot on the given meta data field date. ```dataview CALENDAR file.ctime ``` Output While it is possible to use SORT and GROUP BY in combination with CALENDAR , it has no effect . Additionally, the calendar query does not render if the given meta data field contains something else than a valid date (but the field can be empty). To make sure you're only taking valid pages into account, you can filter for valid meta data values: ```dataview CALENDAR due WHERE typeof(due) = \"date\" ```","title":"CALENDAR"},{"location":"queries/structure/","text":"Structure of a Query Dataview offers multiple ways to write queries and the syntax differs for each. This page provides information on how to write a Dataview Query Language ( DQL ) query. If you're interested in how to write Inline Queries, refer to the inline section on DQL, JS and Inlines . You'll find more information about Javascript Queries on the Javascript Reference . DQL is a SQL like query language for creating different views or calculations on your data. It supports: Choosing an output format of your output (the Query Type ) Fetch pages from a certain source , i.e. a tag, folder or link Filtering pages/data by simple operations on fields, like comparison, existence checks, and so on Transforming fields for displaying, i.e. with calculations or splitting up multi-value fields Sorting results based on fields Grouping results based on fields Limiting your result count Let's have a look at how we can put DQL to use. General Format of a DQL Query Every query follows the same structure and consists of exactly one Query Type with zero, one or many fields , depending on query type zero or one FROM data commands with one to many sources zero to many other data commands with one to many expressions and/or other infos depending on the data command At a high level, a query conforms to the following pattern: ```dataview <QUERY-TYPE> <fields> FROM <source> <DATA-COMMAND> <expression> <DATA-COMMAND> <expression> ... ``` Only the Query Type is mandatory. The following sections will explain the theory in further detail. Choose a Output Format The output format of a query is determined by its Query Type . There are four available: TABLE : A table of results with one row per result and one or many columns of field data. LIST : A bullet point list of pages which match the query. You can output one field for each page alongside their file links. TASK : An interactive task list of tasks that match the given query. CALENDAR : A calendar view displaying each hit via a dot on its referred date. The Query Type is the only mandatory command in a query . Everything else is optional. Possibly memory intense examples Depending on the size of your vault, executing the following examples can take long and even freeze Obsidian in extreme cases. It's recommended that you specify a FROM to restrict the query execution to a specific subset of your vaults' files. See next section. Lists all pages in your vault as a bullet point list ```dataview LIST ``` Lists all tasks (completed or not) in your vault ```dataview TASK ``` Renders a Calendar view where each page is represented as a dot on its creation date. ```dataview CALENDAR file.cday ``` Shows a table with all pages of your vault, their field value of due, the files' tags and an average of the values of multi-value field working-hours ```dataview TABLE due, file.tags AS \"tags\", average(working-hours) ``` Read more about the available Query Types and how to use them here . Choose your source Additionally to the Query Types, you have several Data Commands available that help you restrict, refine, sort or group your query. One of these query commands is the FROM statement. FROM takes a source or a combination of sources as an argument and restricts the query to a set of pages that match your source. It behaves differently from the other Data Commands: You can add zero or one FROM data command to your query, right after your Query Type. You cannot add multiple FROM statements and you cannot add it after other Data Commands. Lists all pages inside the folder Books and its sub folders ```dataview LIST FROM \"Books\" ``` Lists all pages that include the tag #status/open or #status/wip ```dataview LIST FROM #status/open OR #status/wip ``` Lists all pages that have either the tag #assignment and are inside folder \"30 School\" (or its sub folders), or are inside folder \"30 School/32 Homeworks\" and are linked on the page School Dashboard Current To Dos ```dataview LIST FROM (#assignment AND \"30 School\") OR (\"30 School/32 Homeworks\" AND outgoing([[School Dashboard Current To Dos]])) ``` Read more about FROM here . Filter, sort, group or limit results In addition to the Query Types and the Data command FROM that's explained above, you have several other Data Commands available that help you restrict, refine, sort or group your query results. All data commands except the FROM command can be used multiple times in any order (as long as they come after the Query Type and FROM , if FROM is used at all). They'll be excuted in the order they are written. Available are: FROM like explained above . WHERE : Filter notes based on information inside notes, the meta data fields. SORT : Sorts your results depending on a field and a direction. GROUP BY : Bundles up several results into one result row per group. LIMIT : Limits the result count of your query to the given number. FLATTEN : Splits up one result into multiple results based on a field or calculation. Lists all pages that have a metadata field `due` and where `due` is before today ```dataview LIST WHERE due AND due < date(today) ``` Lists the 10 most recently created pages in your vault that have the tag #status/open ```dataview LIST FROM #status/open SORT file.ctime DESC LIMIT 10 ``` Lists the 10 oldest and incompleted tasks of your vault as an interactive task list, grouped by their containing file and sorted from oldest to newest file. ```dataview TASK WHERE !completed SORT created ASC LIMIT 10 GROUP BY file.link SORT rows.file.ctime ASC ``` Find out more about available data commands . Examples Following are some example queries. Find more examples here . ```dataview TASK ``` ```dataview TABLE recipe-type AS \"type\", portions, length FROM #recipes ``` ```dataview LIST FROM #assignments WHERE status = \"open\" ``` ```dataview TABLE file.ctime, appointment.type, appointment.time, follow-ups FROM \"30 Protocols/32 Management\" WHERE follow-ups SORT appointment.time ``` ```dataview TABLE L.text AS \"My lists\" FROM \"dailys\" FLATTEN file.lists AS L WHERE contains(L.author, \"Surname\") ``` ```dataview LIST rows.c WHERE typeof(contacts) = \"array\" AND contains(contacts, [[Mr. L]]) SORT length(contacts) FLATTEN contacts as c SORT link(c).age ASC ```","title":"Structure of a Query"},{"location":"queries/structure/#structure-of-a-query","text":"Dataview offers multiple ways to write queries and the syntax differs for each. This page provides information on how to write a Dataview Query Language ( DQL ) query. If you're interested in how to write Inline Queries, refer to the inline section on DQL, JS and Inlines . You'll find more information about Javascript Queries on the Javascript Reference . DQL is a SQL like query language for creating different views or calculations on your data. It supports: Choosing an output format of your output (the Query Type ) Fetch pages from a certain source , i.e. a tag, folder or link Filtering pages/data by simple operations on fields, like comparison, existence checks, and so on Transforming fields for displaying, i.e. with calculations or splitting up multi-value fields Sorting results based on fields Grouping results based on fields Limiting your result count Let's have a look at how we can put DQL to use.","title":"Structure of a Query"},{"location":"queries/structure/#general-format-of-a-dql-query","text":"Every query follows the same structure and consists of exactly one Query Type with zero, one or many fields , depending on query type zero or one FROM data commands with one to many sources zero to many other data commands with one to many expressions and/or other infos depending on the data command At a high level, a query conforms to the following pattern: ```dataview <QUERY-TYPE> <fields> FROM <source> <DATA-COMMAND> <expression> <DATA-COMMAND> <expression> ... ``` Only the Query Type is mandatory. The following sections will explain the theory in further detail.","title":"General Format of a DQL Query"},{"location":"queries/structure/#choose-a-output-format","text":"The output format of a query is determined by its Query Type . There are four available: TABLE : A table of results with one row per result and one or many columns of field data. LIST : A bullet point list of pages which match the query. You can output one field for each page alongside their file links. TASK : An interactive task list of tasks that match the given query. CALENDAR : A calendar view displaying each hit via a dot on its referred date. The Query Type is the only mandatory command in a query . Everything else is optional. Possibly memory intense examples Depending on the size of your vault, executing the following examples can take long and even freeze Obsidian in extreme cases. It's recommended that you specify a FROM to restrict the query execution to a specific subset of your vaults' files. See next section. Lists all pages in your vault as a bullet point list ```dataview LIST ``` Lists all tasks (completed or not) in your vault ```dataview TASK ``` Renders a Calendar view where each page is represented as a dot on its creation date. ```dataview CALENDAR file.cday ``` Shows a table with all pages of your vault, their field value of due, the files' tags and an average of the values of multi-value field working-hours ```dataview TABLE due, file.tags AS \"tags\", average(working-hours) ``` Read more about the available Query Types and how to use them here .","title":"Choose a Output Format"},{"location":"queries/structure/#choose-your-source","text":"Additionally to the Query Types, you have several Data Commands available that help you restrict, refine, sort or group your query. One of these query commands is the FROM statement. FROM takes a source or a combination of sources as an argument and restricts the query to a set of pages that match your source. It behaves differently from the other Data Commands: You can add zero or one FROM data command to your query, right after your Query Type. You cannot add multiple FROM statements and you cannot add it after other Data Commands. Lists all pages inside the folder Books and its sub folders ```dataview LIST FROM \"Books\" ``` Lists all pages that include the tag #status/open or #status/wip ```dataview LIST FROM #status/open OR #status/wip ``` Lists all pages that have either the tag #assignment and are inside folder \"30 School\" (or its sub folders), or are inside folder \"30 School/32 Homeworks\" and are linked on the page School Dashboard Current To Dos ```dataview LIST FROM (#assignment AND \"30 School\") OR (\"30 School/32 Homeworks\" AND outgoing([[School Dashboard Current To Dos]])) ``` Read more about FROM here .","title":"Choose your source"},{"location":"queries/structure/#filter-sort-group-or-limit-results","text":"In addition to the Query Types and the Data command FROM that's explained above, you have several other Data Commands available that help you restrict, refine, sort or group your query results. All data commands except the FROM command can be used multiple times in any order (as long as they come after the Query Type and FROM , if FROM is used at all). They'll be excuted in the order they are written. Available are: FROM like explained above . WHERE : Filter notes based on information inside notes, the meta data fields. SORT : Sorts your results depending on a field and a direction. GROUP BY : Bundles up several results into one result row per group. LIMIT : Limits the result count of your query to the given number. FLATTEN : Splits up one result into multiple results based on a field or calculation. Lists all pages that have a metadata field `due` and where `due` is before today ```dataview LIST WHERE due AND due < date(today) ``` Lists the 10 most recently created pages in your vault that have the tag #status/open ```dataview LIST FROM #status/open SORT file.ctime DESC LIMIT 10 ``` Lists the 10 oldest and incompleted tasks of your vault as an interactive task list, grouped by their containing file and sorted from oldest to newest file. ```dataview TASK WHERE !completed SORT created ASC LIMIT 10 GROUP BY file.link SORT rows.file.ctime ASC ``` Find out more about available data commands .","title":"Filter, sort, group or limit results"},{"location":"queries/structure/#examples","text":"Following are some example queries. Find more examples here . ```dataview TASK ``` ```dataview TABLE recipe-type AS \"type\", portions, length FROM #recipes ``` ```dataview LIST FROM #assignments WHERE status = \"open\" ``` ```dataview TABLE file.ctime, appointment.type, appointment.time, follow-ups FROM \"30 Protocols/32 Management\" WHERE follow-ups SORT appointment.time ``` ```dataview TABLE L.text AS \"My lists\" FROM \"dailys\" FLATTEN file.lists AS L WHERE contains(L.author, \"Surname\") ``` ```dataview LIST rows.c WHERE typeof(contacts) = \"array\" AND contains(contacts, [[Mr. L]]) SORT length(contacts) FLATTEN contacts as c SORT link(c).age ASC ```","title":"Examples"},{"location":"reference/expressions/","text":"Expressions Dataview query language expressions are anything that yields a value - all fields are expressions, as are literal values (like 6 ), as are computed values (like field - 9 ). For a very high level summary: # Literals 1 (number) true/false (boolean) \"text\" (text) date(2021-04-18) (date) dur(1 day) (duration) [[Link]] (link) [1, 2, 3] (list) { a: 1, b: 2 } (object) # Lambdas (x1, x2) => ... (lambda) # References field (directly refer to a field) simple-field (refer to fields with spaces/punctuation in them like \"Simple Field!\") a.b (if a is an object, retrieve field named 'b') a[expr] (if a is an object or array, retrieve field with name specified by expression 'expr') f(a, b, ...) (call a function called `f` on arguments a, b, ...) # Arithmetic a + b (addition) a - b (subtraction) a * b (multiplication) a / b (division) a % b (modulo / remainder of division) # Comparison a > b (check if a is greater than b) a < b (check if a is less than b) a = b (check if a equals b) a != b (check if a does not equal b) a <= b (check if a is less than or equal to b) a >= b (check if a is greater than or equal to b) # Special Operations [[Link]].value (fetch `value` from page `Link`) More detailed explanations of each follow. Expression Types Fields as Expressions The simplest expression is one that just directly refers to a field. If you have a field called \"field\", then you can refer to it directly by name - field . If the field name has spaces, punctuation, or other non-letter/number characters, then you can refer to it using Dataview's simplified name, which is all lower case with spaces replaced with \"-\". For example, this is a field becomes this-is-a-field ; Hello! becomes hello , and so on. Literals Constant values - things like 1 or \"hello\" or date(som) (\"start of month\"). There are literals for each data type that dataview supports; you can see the reference above for examples of what each literal type looks like. Arithmetic You can use standard arithmetic operators to combine fields: addition ( + ), subtraction ( - ), multiplication ( * ), and division ( / ). For example field1 + field2 is an expression which computes the sum of the two fields. Comparisons You can compare most values using the various comparison operators: < , > , <= , >= , = , != . This yields a boolean true or false value which can be used in WHERE blocks in queries. Array/Object Indexing You can retrieve data from arrays via the index operator array[<index>] , where <index> is any computed expression. Arrays are 0-indexed, so the first element is index 0, the second element is index 1, and so on. For example list(1, 2, 3)[0] = 1 . A similar notation style works for objects. You can use field[\"nestedfield\"] to reference fields inside an object or otherwise similarly nested. For example, in the YAML defined below, we can reference previous via episode_metadata[\"previous\"] . --- current_episode : \"S01E03\" episode_metadata : previous : \"S01E02\" next : \"S01E04\" --- You can also retrieve data from objects (which map text to data values) also using the index operator, where indexes are now strings/text instead of numbers. You can also use the shorthand object.<name> , where <name> is the name of the value to retrieve. For the previous frontmatter example, we could also use episode_metadata.previous to obtain the same value. Index expressions also work on objects which have fields that are not directly supported by the query language. A good example is where , since it is a keyword. If your frontmatter/metadata contains a field where , you can reference it via the row syntax: row[\"where\"] . See the note in the FAQ and the corresponding issue for further information. Function Calls Dataview supports various functions for manipulating data, which are described in full in the functions documentation . They have the general syntax function(arg1, arg2, ...) - i.e., lower(\"yes\") or regexmatch(\"text\", \".+\") . Lambdas Lambdas are advanced literals which let you define a function that takes some number of inputs, and produces an output. They have the general form: (arg1, arg2, arg3, ...) => <expression using args> Lambdas are used in several advanced operators like reduce and map to allow for complex transformations of data. A few examples: (x, y) => x + y (sum x and y) (x) => 2 * x (double x) (value) => length(value) = 4 (return true if value is length 4) Type-specific Interactions & Values Most dataview types have special interactions with operators, or have additional fields that can be retrieved using the index operator. Dates You can retrieve various components of a date via indexing: date.year , date.month , date.day , date.hour , date.minute , date.second , date.week , date.weekyear . You can also add durations to dates to get new dates. Durations Durations can be added to each other or to dates. You can retrieve various components of a duration via indexing: duration.years , duration.months , duration.days , duration.hours , duration.minutes , duration.seconds . Links You can \"index through\" a link to get values on the corresponding page. For example [[Link]].value would get the value value from page Link . Link Indexing in Expressions If your link is a field that you defined in an inline field or in front-matter, like Key:: [[Link]] , then you should index into it by just writing Key.value ; Using [[Key]].value would look up the page literally called Key , which is probably not what you want!","title":"Expressions"},{"location":"reference/expressions/#expressions","text":"Dataview query language expressions are anything that yields a value - all fields are expressions, as are literal values (like 6 ), as are computed values (like field - 9 ). For a very high level summary: # Literals 1 (number) true/false (boolean) \"text\" (text) date(2021-04-18) (date) dur(1 day) (duration) [[Link]] (link) [1, 2, 3] (list) { a: 1, b: 2 } (object) # Lambdas (x1, x2) => ... (lambda) # References field (directly refer to a field) simple-field (refer to fields with spaces/punctuation in them like \"Simple Field!\") a.b (if a is an object, retrieve field named 'b') a[expr] (if a is an object or array, retrieve field with name specified by expression 'expr') f(a, b, ...) (call a function called `f` on arguments a, b, ...) # Arithmetic a + b (addition) a - b (subtraction) a * b (multiplication) a / b (division) a % b (modulo / remainder of division) # Comparison a > b (check if a is greater than b) a < b (check if a is less than b) a = b (check if a equals b) a != b (check if a does not equal b) a <= b (check if a is less than or equal to b) a >= b (check if a is greater than or equal to b) # Special Operations [[Link]].value (fetch `value` from page `Link`) More detailed explanations of each follow.","title":"Expressions"},{"location":"reference/expressions/#expression-types","text":"","title":"Expression Types"},{"location":"reference/expressions/#fields-as-expressions","text":"The simplest expression is one that just directly refers to a field. If you have a field called \"field\", then you can refer to it directly by name - field . If the field name has spaces, punctuation, or other non-letter/number characters, then you can refer to it using Dataview's simplified name, which is all lower case with spaces replaced with \"-\". For example, this is a field becomes this-is-a-field ; Hello! becomes hello , and so on.","title":"Fields as Expressions"},{"location":"reference/expressions/#literals","text":"Constant values - things like 1 or \"hello\" or date(som) (\"start of month\"). There are literals for each data type that dataview supports; you can see the reference above for examples of what each literal type looks like.","title":"Literals"},{"location":"reference/expressions/#arithmetic","text":"You can use standard arithmetic operators to combine fields: addition ( + ), subtraction ( - ), multiplication ( * ), and division ( / ). For example field1 + field2 is an expression which computes the sum of the two fields.","title":"Arithmetic"},{"location":"reference/expressions/#comparisons","text":"You can compare most values using the various comparison operators: < , > , <= , >= , = , != . This yields a boolean true or false value which can be used in WHERE blocks in queries.","title":"Comparisons"},{"location":"reference/expressions/#arrayobject-indexing","text":"You can retrieve data from arrays via the index operator array[<index>] , where <index> is any computed expression. Arrays are 0-indexed, so the first element is index 0, the second element is index 1, and so on. For example list(1, 2, 3)[0] = 1 . A similar notation style works for objects. You can use field[\"nestedfield\"] to reference fields inside an object or otherwise similarly nested. For example, in the YAML defined below, we can reference previous via episode_metadata[\"previous\"] . --- current_episode : \"S01E03\" episode_metadata : previous : \"S01E02\" next : \"S01E04\" --- You can also retrieve data from objects (which map text to data values) also using the index operator, where indexes are now strings/text instead of numbers. You can also use the shorthand object.<name> , where <name> is the name of the value to retrieve. For the previous frontmatter example, we could also use episode_metadata.previous to obtain the same value. Index expressions also work on objects which have fields that are not directly supported by the query language. A good example is where , since it is a keyword. If your frontmatter/metadata contains a field where , you can reference it via the row syntax: row[\"where\"] . See the note in the FAQ and the corresponding issue for further information.","title":"Array/Object Indexing"},{"location":"reference/expressions/#function-calls","text":"Dataview supports various functions for manipulating data, which are described in full in the functions documentation . They have the general syntax function(arg1, arg2, ...) - i.e., lower(\"yes\") or regexmatch(\"text\", \".+\") .","title":"Function Calls"},{"location":"reference/expressions/#lambdas","text":"Lambdas are advanced literals which let you define a function that takes some number of inputs, and produces an output. They have the general form: (arg1, arg2, arg3, ...) => <expression using args> Lambdas are used in several advanced operators like reduce and map to allow for complex transformations of data. A few examples: (x, y) => x + y (sum x and y) (x) => 2 * x (double x) (value) => length(value) = 4 (return true if value is length 4)","title":"Lambdas"},{"location":"reference/expressions/#type-specific-interactions-values","text":"Most dataview types have special interactions with operators, or have additional fields that can be retrieved using the index operator.","title":"Type-specific Interactions &amp; Values"},{"location":"reference/expressions/#dates","text":"You can retrieve various components of a date via indexing: date.year , date.month , date.day , date.hour , date.minute , date.second , date.week , date.weekyear . You can also add durations to dates to get new dates.","title":"Dates"},{"location":"reference/expressions/#durations","text":"Durations can be added to each other or to dates. You can retrieve various components of a duration via indexing: duration.years , duration.months , duration.days , duration.hours , duration.minutes , duration.seconds .","title":"Durations"},{"location":"reference/expressions/#links","text":"You can \"index through\" a link to get values on the corresponding page. For example [[Link]].value would get the value value from page Link . Link Indexing in Expressions If your link is a field that you defined in an inline field or in front-matter, like Key:: [[Link]] , then you should index into it by just writing Key.value ; Using [[Key]].value would look up the page literally called Key , which is probably not what you want!","title":"Links"},{"location":"reference/functions/","text":"Functions Dataview functions provide more advanced ways to manipulate data. Function Vectorization Most functions can be applied either to single values (like number , string , date , etc.) OR to lists of those values. If a function is applied to a list, it also returns a list after the function is applied to each element in the list. For example: lower(\"YES\") = \"yes\" lower([\"YES\", \"NO\"]) = [\"yes\", \"no\"] replace(\"yes\", \"e\", \"a\") = \"yas\" replace([\"yes\", \"ree\"], \"e\", \"a\") = [\"yas\", \"raa\"] Constructors Constructors which create values. object(key1, value1, ...) Creates a new object with the given keys and values. Keys and values should alternate in the call, and keys should always be strings/text. object() => empty object object(\"a\", 6) => object which maps \"a\" to 6 object(\"a\", 4, \"c\", \"yes\") => object which maps a to 4, and c to \"yes\" list(value1, value2, ...) Creates a new list with the given values in it. list() => empty list list(1, 2, 3) => list with 1, 2, and 3 list(\"a\", \"b\", \"c\") => list with \"a\", \"b\", and \"c\" date(any) Parses a date from the provided string, date, or link object, if possible, returning null otherwise. date(\"2020-04-18\") = <date object representing April 18th, 2020> date([[2021-04-16]]) = <date object for the given page, refering to file.day> dur(any) Parses a duration from the provided string or duration, returning null on failure. dur(8 minutes) = <8 minutes> dur(\"8 minutes, 4 seconds\") = <8 minutes, 4 seconds> dur(dur(8 minutes)) = dur(8 minutes) = <8 minutes> number(string) Pulls the first number out of the given string, returning it if possible. Returns null if there are no numbers in the string. number(\"18 years\") = 18 number(34) = 34 number(\"hmm\") = null string(any) Converts any value into a \"reasonable\" string representation. This sometimes produces less pretty results than just directly using the value in a query - it is mostly useful for coercing dates, durations, numbers, and so on into strings for manipulation. string(18) = \"18\" string(dur(8 hours)) = \"8 hours\" string(date(2021-08-15)) = \"August 15th, 2021\" link(path, [display]) Construct a link object from the given file path or name. If provided with two arguments, the second argument is the display name for the link. link(\"Hello\") => link to page named 'Hello' link(\"Hello\", \"Goodbye\") => link to page named 'Hello', displays as 'Goodbye' embed(link, [embed?]) Convert a link object into an embedded link; support for embedded links is somewhat spotty in Dataview views, though embedding of images should work. embed(link(\"Hello.png\")) => embedded link to the \"Hello.png\" image, which will render as an actual image. elink(url, [display]) Construct a link to an external url (like www.google.com ). If provided with two arguments, the second argument is the display name for the link. elink(\"www.google.com\") => link element to google.com elink(\"www.google.com\", \"Google\") => link element to google.com, displays as \"Google\" typeof(any) Get the type of any object for inspection. Can be used in conjunction with other operators to change behavior based on type. typeof(8) => \"number\" typeof(\"text\") => \"string\" typeof([1, 2, 3]) => \"array\" typeof({ a: 1, b: 2 }) => \"object\" typeof(date(2020-01-01)) => \"date\" typeof(dur(8 minutes)) => \"duration\" Numeric Operations round(number, [digits]) Round a number to a given number of digits. If the second argument is not specified, rounds to the nearest whole number; otherwise, rounds to the given number of digits. round(16.555555) = 7 round(16.555555, 2) = 16.56 min(a, b, ..) Compute the minimum value of a list of arguments, or an array. min(1, 2, 3) = 1 min([1, 2, 3]) = 1 min(\"a\", \"ab\", \"abc\") = \"a\" max(a, b, ...) Compute the maximum value of a list of arguments, or an array. max(1, 2, 3) = 3 max([1, 2, 3]) = 3 max(\"a\", \"ab\", \"abc\") = \"abc\" sum(array) Sums all numeric values in the array. If you have null values in your average, you can eliminate them via the nonnull function. sum([1, 2, 3]) = 6 sum([]) = null sum(nonnull([null, 1, 8])) = 9 product(array) Calculates the product of a list of numbers. If you have null values in your average, you can eliminate them via the nonnull function. product([1,2,3]) = 6 product([]) = null product(nonnull([null, 1, 2, 4])) = 8 average(array) Computes the numeric average of numeric values. If you have null values in your average, you can eliminate them via the nonnull function. average([1, 2, 3]) = 2 average([]) = null average(nonnull([null, 1, 2])) = 1.5 minby(array, function) Compute the minimum value of an array, using the provided function. minby([1, 2, 3], (k) => k) = 1 minby([1, 2, 3], (k) => 0 - k) => 3 minby(this.file.tasks, (k) => k.due) => (earliest due) maxby(array, function) Compute the maximum value of an array, using the provided function. maxby([1, 2, 3], (k) => k) = 3 maxby([1, 2, 3], (k) => 0 - k) => 1 maxby(this.file.tasks, (k) => k.due) => (latest due) -- Objects, Arrays, and String Operations Operations that manipulate values inside of container objects. contains() and friends For a quick summary, here are some examples: contains(\"Hello\", \"Lo\") = false contains(\"Hello\", \"lo\") = true icontains(\"Hello\", \"Lo\") = true icontains(\"Hello\", \"lo\") = true econtains(\"Hello\", \"Lo\") = false econtains(\"Hello\", \"lo\") = true econtains([\"this\",\"is\",\"example\"], \"ex\") = false econtains([\"this\",\"is\",\"example\"], \"is\") = true contains(object|list|string, value) Checks if the given container type has the given value in it. This function behave slightly differently based on whether the first argument is an object, a list, or a string. This function is case-sensitive. For objects, checks if the object has a key with the given name. For example, contains(file, \"ctime\") = true contains(file, \"day\") = true (if file has a date in its title, false otherwise) For lists, checks if any of the array elements equals the given value. For example, contains(list(1, 2, 3), 3) = true contains(list(), 1) = false For strings, checks if the given value is a substring (i.e., inside) the string. contains(\"hello\", \"lo\") = true contains(\"yes\", \"no\") = false icontains(object|list|string, value) Case insensitive version of contains() . econtains(object|list|string, value) \"Exact contains\" checks if the exact match is found in the string/list. This function is case sensitive. For strings, it behaves exactly like contains() . econtains(\"Hello\", \"Lo\") = false econtains(\"Hello\", \"lo\") = true For lists, it checks if the exact word is in the list. econtains([\"These\", \"are\", \"words\"], \"word\") = false econtains([\"These\", \"are\", \"words\"], \"words\") = true For objects, it checks if the exact key name is present in the object. It does not do recursive checks. econtains({key:\"value\", pairs:\"here\"}, \"here\") = false econtains({key:\"value\", pairs:\"here\"}, \"key\") = true econtains({key:\"value\", recur:{recurkey: \"val\"}}, \"value\") = false econtains({key:\"value\", recur:{recurkey: \"val\"}}, \"Recur\") = false econtains({key:\"value\", recur:{recurkey: \"val\"}}, \"recurkey\") = false containsword(list|string, value) Checks if value has an exact word match in string or list . This is case insensitive. The outputs are different for different types of input, see examples. For strings, it checks if the word is present in the given string. containsword(\"word\", \"word\") = true containsword(\"word\", \"Word\") = true containsword(\"words\", \"Word\") = false containsword(\"Hello there!, \"hello\") = true containsword(\"Hello there!, \"HeLLo\") = true containsword(\"Hello there chaps!, \"chap\") = false containsword(\"Hello there chaps!, \"chaps\") = true For lists, it returns a list of booleans indicating if the word's exact case insensitive match was found. containsword([\"I have no words.\", \"words\"], \"Word\") = [false, false] containsword([\"word\", \"Words\"], \"Word\") = [true, false] containsword([\"Word\", \"Words in word\"], \"WORD\") = [true, true] extract(object, key1, key2, ...) Pulls multiple fields out of an object, creating a new object with just those fields. extract(file, \"ctime\", \"mtime\") = object(\"ctime\", file.ctime, \"mtime\", file.mtime) extract(object(\"test\", 1)) = object() sort(list) Sorts a list, returning a new list in sorted order. sort(list(3, 2, 1)) = list(1, 2, 3) sort(list(\"a\", \"b\", \"aa\")) = list(\"a\", \"aa\", \"b\") reverse(list) Reverses a list, returning a new list in reversed order. reverse(list(1, 2, 3)) = list(3, 2, 1) reverse(list(\"a\", \"b\", \"c\")) = list(\"c\", \"b\", \"a\") length(object|array) Returns the number of fields in an object, or the number of entries in an array. length([]) = 0 length([1, 2, 3]) = 3 length(object(\"hello\", 1, \"goodbye\", 2)) = 2 nonnull(array) Return a new array with all null values removed. nonnull([]) = [] nonnull([null, false]) = [false] nonnull([1, 2, 3]) = [1, 2, 3] all(array) Returns true only if ALL values in the array are truthy. You can also pass multiple arguments to this function, in which case it returns true only if all arguments are truthy. all([1, 2, 3]) = true all([true, false]) = false all(true, false) = false all(true, true, true) = true You can pass a function as second argument to return only true if all elements in the array matches the predicate. all([1, 2, 3], (x) => x > 0) = true all([1, 2, 3], (x) => x > 1) = false all([\"apple\", \"pie\", 3], (x) => typeof(x) = \"string\") = false any(array) Returns true if ANY of the values in the array are truthy. You can also pass multiple arguments to this function, in which case it returns true if any of the arguments are truthy. any(list(1, 2, 3)) = true any(list(true, false)) = true any(list(false, false, false)) = false any(true, false) = true any(false, false) = false You can pass a function as second argument to return only true if any element in the array matches the predicate. any(list(1, 2, 3), (x) => x > 2) = true any(list(1, 2, 3), (x) => x = 0) = false none(array) Returns true if NONE of the values in the array are truthy. none([]) = true none([false, false]) = true none([false, true]) = false none([1, 2, 3]) = false You can pass a function as second argument to return only true if none of the elements in the array matches the predicate. none([1, 2, 3], (x) => x = 0) = true none([true, true], (x) => x = false) = true none([\"Apple\", \"Pi\", \"Banana\"], (x) => startswith(x, \"A\")) = false join(array, [delimiter]) Joins elements in an array into a single string (i.e., rendering them all on the same line). If provided with a second argument, then each element will be separated by the given separator. join(list(1, 2, 3)) = \"1, 2, 3\" join(list(1, 2, 3), \" \") = \"1 2 3\" join(6) = \"6\" join(list()) = \"\" filter(array, predicate) Filters elements in an array according to the predicate, returning a new list of the elements which matched. filter([1, 2, 3], (x) => x >= 2) = [2, 3] filter([\"yes\", \"no\", \"yas\"], (x) => startswith(x, \"y\")) = [\"yes\", \"yas\"] map(array, func) Applies the function to each element in the array, returning a list of the mapped results. map([1, 2, 3], (x) => x + 2) = [3, 4, 5] map([\"yes\", \"no\"], (x) => x + \"?\") = [\"yes?\", \"no?\"] String Operations regexmatch(pattern, string) Checks if the given string matches the given pattern (using the JavaScript regex engine). regexmatch(\"\\w+\", \"hello\") = true regexmatch(\".\", \"a\") = true regexmatch(\"yes|no\", \"maybe\") = false regexreplace(string, pattern, replacement) Replaces all instances where the regex pattern matches in string , with replacement . This uses the JavaScript replace method under the hood, so you can use special characters like $1 to refer to the first capture group, and so on. regexreplace(\"yes\", \"[ys]\", \"a\") = \"aea\" regexreplace(\"Suite 1000\", \"\\d+\", \"-\") = \"Suite -\" replace(string, pattern, replacement) Replace all instances of pattern in string with replacement . replace(\"what\", \"wh\", \"h\") = \"hat\" replace(\"The big dog chased the big cat.\", \"big\", \"small\") = \"The small dog chased the small cat.\" replace(\"test\", \"test\", \"no\") = \"no\" lower(string) Convert a string to all lower case. lower(\"Test\") = \"test\" lower(\"TEST\") = \"test\" upper(string) Convert a string to all upper case. upper(\"Test\") = \"TEST\" upper(\"test\") = \"TEST\" split(string, delimiter, [limit]) Split a string on the given delimiter string. If a third argument is provided, it limits the number of splits that occur. The delimiter string is interpreted as a regular expression. If there are capture groups in the delimiter, matches are spliced into the result array, and non-matching captures are empty strings. split(\"hello world\", \" \") = list(\"hello\", \"world\") split(\"hello world\", \"\\s\") = list(\"hello\", \"world\") split(\"hello there world\", \" \", 2) = list(\"hello\", \"there\") split(\"hello there world\", \"(t?here)\") = list(\"hello \", \"there\", \" world\") split(\"hello there world\", \"( )(x)?\") = list(\"hello\", \" \", \"\", \"there\", \" \", \"\", \"world\") startswith(string, prefix) Checks if a string starts with the given prefix. startswith(\"yes\", \"ye\") = true startswith(\"path/to/something\", \"path/\") = true startswith(\"yes\", \"no\") = false endswith(string, suffix) Checks if a string ends with the given suffix. endswith(\"yes\", \"es\") = true endswith(\"path/to/something\", \"something\") = true endswith(\"yes\", \"ye\") = false padleft(string, length, [padding]) Pads a string up to the desired length by adding padding on the left side. If you omit the padding character, spaces will be used by default. padleft(\"hello\", 7) = \" hello\" padleft(\"yes\", 5, \"!\") = \"!!yes\" padright(string, length, [padding]) Equivalent to padleft , but pads to the right instead. padright(\"hello\", 7) = \"hello \" padright(\"yes\", 5, \"!\") = \"yes!!\" substring(string, start, [end]) Take a slice of a string, starting at start and ending at end (or the end of the string if unspecified). substring(\"hello\", 0, 2) = \"he\" substring(\"hello\", 2, 4) = \"ll\" substring(\"hello\", 2) = \"llo\" substring(\"hello\", 0) = \"hello\" truncate(string, length, [suffix]) Truncate a string to be at most the given length, including the suffix (which defaults to ... ). Generally useful to cut off long text in tables. truncate(\"Hello there!\", 8) = \"Hello...\" truncate(\"Hello there!\", 8, \"/\") = \"Hello t/\" truncate(\"Hello there!\", 10) = \"Hello t...\" truncate(\"Hello there!\", 10, \"!\") = \"Hello the!\" truncate(\"Hello there!\", 20) = \"Hello there!\" Utility Functions default(field, value) If field is null, return value ; otherwise return field . Useful for replacing null values with defaults. For example, to show projects which haven't been completed yet, use \"incomplete\" as their default value: default(dateCompleted, \"incomplete\") Default is vectorized in both arguments; if you need to use default explicitly on a list argument, use ldefault , which is the same as default but is not vectorized. default(list(1, 2, null), 3) = list(1, 2, 3) ldefault(list(1, 2, null), 3) = list(1, 2, null) choice(bool, left, right) A primitive if statement - if the first argument is truthy, returns left; otherwise, returns right. choice(true, \"yes\", \"no\") = \"yes\" choice(false, \"yes\", \"no\") = \"no\" choice(x > 4, y, z) = y if x > 4, else z striptime(date) Strip the time component of a date, leaving only the year, month, and day. Good for date comparisons if you don't care about the time. striptime(file.ctime) = file.cday striptime(file.mtime) = file.mday dateformat(date|datetime, string) Format a Dataview date using a formatting string. Uses Luxon tokens . dateformat(file.ctime,\"yyyy-MM-dd\") = \"2022-01-05\" dateformat(file.ctime,\"HH:mm:ss\") = \"12:18:04\" dateformat(date(now),\"x\") = \"1407287224054\" dateformat(file.mtime,\"ffff\") = \"Wednesday, August 6, 2014, 1:07 PM Eastern Daylight Time\" localtime(date) Converts a date in a fixed timezone to a date in the current timezone. meta(link) Get an object containing metadata of a link. When you access a property on a link what you get back is the property value from the linked file. The meta function makes it possible to access properties of the link itself. There are several properties on the object returned by meta : meta(link).display Get the display text of a link, or null if the link does not have defined display text. meta([[2021-11-01|Displayed link text]]).display = \"Displayed link text\" meta([[2021-11-01]]).display = null meta(link).embed True or false depending on whether the link is an embed. Those are links that begin with an exclamation mark, like ![[Some Link]] . meta(link).path Get the path portion of a link. meta([[My Project]]).path = \"My Project\" meta([[My Project#Next Actions]]).path = \"My Project\" meta([[My Project#^9bcbe8]]).path = \"My Project\" meta(link).subpath Get the subpath of a link. For links to a heading within a file the subpath will be the text of the heading. For links to a block the subpath will be the block ID. If neither of those cases applies then the subpath will be null. meta([[My Project#Next Actions]]).subpath = \"Next Actions\" meta([[My Project#^9bcbe8]]).subpath = \"9bcbe8\" meta([[My Project]]).subpath = null This can be used to select tasks under specific headings. ```dataview task where meta(section).subpath = \"Next Actions\" ``` meta(link).type Has the value \"file\", \"header\", or \"block\" depending on whether the link links to an entire file, a heading within a file, or to a block within a file. meta([[My Project]]).type = \"file\" meta([[My Project#Next Actions]]).type = \"header\" meta([[My Project#^9bcbe8]]).type = \"block\"","title":"Functions"},{"location":"reference/functions/#functions","text":"Dataview functions provide more advanced ways to manipulate data.","title":"Functions"},{"location":"reference/functions/#function-vectorization","text":"Most functions can be applied either to single values (like number , string , date , etc.) OR to lists of those values. If a function is applied to a list, it also returns a list after the function is applied to each element in the list. For example: lower(\"YES\") = \"yes\" lower([\"YES\", \"NO\"]) = [\"yes\", \"no\"] replace(\"yes\", \"e\", \"a\") = \"yas\" replace([\"yes\", \"ree\"], \"e\", \"a\") = [\"yas\", \"raa\"]","title":"Function Vectorization"},{"location":"reference/functions/#constructors","text":"Constructors which create values.","title":"Constructors"},{"location":"reference/functions/#objectkey1-value1","text":"Creates a new object with the given keys and values. Keys and values should alternate in the call, and keys should always be strings/text. object() => empty object object(\"a\", 6) => object which maps \"a\" to 6 object(\"a\", 4, \"c\", \"yes\") => object which maps a to 4, and c to \"yes\"","title":"object(key1, value1, ...)"},{"location":"reference/functions/#listvalue1-value2","text":"Creates a new list with the given values in it. list() => empty list list(1, 2, 3) => list with 1, 2, and 3 list(\"a\", \"b\", \"c\") => list with \"a\", \"b\", and \"c\"","title":"list(value1, value2, ...)"},{"location":"reference/functions/#dateany","text":"Parses a date from the provided string, date, or link object, if possible, returning null otherwise. date(\"2020-04-18\") = <date object representing April 18th, 2020> date([[2021-04-16]]) = <date object for the given page, refering to file.day>","title":"date(any)"},{"location":"reference/functions/#durany","text":"Parses a duration from the provided string or duration, returning null on failure. dur(8 minutes) = <8 minutes> dur(\"8 minutes, 4 seconds\") = <8 minutes, 4 seconds> dur(dur(8 minutes)) = dur(8 minutes) = <8 minutes>","title":"dur(any)"},{"location":"reference/functions/#numberstring","text":"Pulls the first number out of the given string, returning it if possible. Returns null if there are no numbers in the string. number(\"18 years\") = 18 number(34) = 34 number(\"hmm\") = null","title":"number(string)"},{"location":"reference/functions/#stringany","text":"Converts any value into a \"reasonable\" string representation. This sometimes produces less pretty results than just directly using the value in a query - it is mostly useful for coercing dates, durations, numbers, and so on into strings for manipulation. string(18) = \"18\" string(dur(8 hours)) = \"8 hours\" string(date(2021-08-15)) = \"August 15th, 2021\"","title":"string(any)"},{"location":"reference/functions/#linkpath-display","text":"Construct a link object from the given file path or name. If provided with two arguments, the second argument is the display name for the link. link(\"Hello\") => link to page named 'Hello' link(\"Hello\", \"Goodbye\") => link to page named 'Hello', displays as 'Goodbye'","title":"link(path, [display])"},{"location":"reference/functions/#embedlink-embed","text":"Convert a link object into an embedded link; support for embedded links is somewhat spotty in Dataview views, though embedding of images should work. embed(link(\"Hello.png\")) => embedded link to the \"Hello.png\" image, which will render as an actual image.","title":"embed(link, [embed?])"},{"location":"reference/functions/#elinkurl-display","text":"Construct a link to an external url (like www.google.com ). If provided with two arguments, the second argument is the display name for the link. elink(\"www.google.com\") => link element to google.com elink(\"www.google.com\", \"Google\") => link element to google.com, displays as \"Google\"","title":"elink(url, [display])"},{"location":"reference/functions/#typeofany","text":"Get the type of any object for inspection. Can be used in conjunction with other operators to change behavior based on type. typeof(8) => \"number\" typeof(\"text\") => \"string\" typeof([1, 2, 3]) => \"array\" typeof({ a: 1, b: 2 }) => \"object\" typeof(date(2020-01-01)) => \"date\" typeof(dur(8 minutes)) => \"duration\"","title":"typeof(any)"},{"location":"reference/functions/#numeric-operations","text":"","title":"Numeric Operations"},{"location":"reference/functions/#roundnumber-digits","text":"Round a number to a given number of digits. If the second argument is not specified, rounds to the nearest whole number; otherwise, rounds to the given number of digits. round(16.555555) = 7 round(16.555555, 2) = 16.56","title":"round(number, [digits])"},{"location":"reference/functions/#mina-b","text":"Compute the minimum value of a list of arguments, or an array. min(1, 2, 3) = 1 min([1, 2, 3]) = 1 min(\"a\", \"ab\", \"abc\") = \"a\"","title":"min(a, b, ..)"},{"location":"reference/functions/#maxa-b","text":"Compute the maximum value of a list of arguments, or an array. max(1, 2, 3) = 3 max([1, 2, 3]) = 3 max(\"a\", \"ab\", \"abc\") = \"abc\"","title":"max(a, b, ...)"},{"location":"reference/functions/#sumarray","text":"Sums all numeric values in the array. If you have null values in your average, you can eliminate them via the nonnull function. sum([1, 2, 3]) = 6 sum([]) = null sum(nonnull([null, 1, 8])) = 9","title":"sum(array)"},{"location":"reference/functions/#productarray","text":"Calculates the product of a list of numbers. If you have null values in your average, you can eliminate them via the nonnull function. product([1,2,3]) = 6 product([]) = null product(nonnull([null, 1, 2, 4])) = 8","title":"product(array)"},{"location":"reference/functions/#averagearray","text":"Computes the numeric average of numeric values. If you have null values in your average, you can eliminate them via the nonnull function. average([1, 2, 3]) = 2 average([]) = null average(nonnull([null, 1, 2])) = 1.5","title":"average(array)"},{"location":"reference/functions/#minbyarray-function","text":"Compute the minimum value of an array, using the provided function. minby([1, 2, 3], (k) => k) = 1 minby([1, 2, 3], (k) => 0 - k) => 3 minby(this.file.tasks, (k) => k.due) => (earliest due)","title":"minby(array, function)"},{"location":"reference/functions/#maxbyarray-function","text":"Compute the maximum value of an array, using the provided function. maxby([1, 2, 3], (k) => k) = 3 maxby([1, 2, 3], (k) => 0 - k) => 1 maxby(this.file.tasks, (k) => k.due) => (latest due) --","title":"maxby(array, function)"},{"location":"reference/functions/#objects-arrays-and-string-operations","text":"Operations that manipulate values inside of container objects.","title":"Objects, Arrays, and String Operations"},{"location":"reference/functions/#contains-and-friends","text":"For a quick summary, here are some examples: contains(\"Hello\", \"Lo\") = false contains(\"Hello\", \"lo\") = true icontains(\"Hello\", \"Lo\") = true icontains(\"Hello\", \"lo\") = true econtains(\"Hello\", \"Lo\") = false econtains(\"Hello\", \"lo\") = true econtains([\"this\",\"is\",\"example\"], \"ex\") = false econtains([\"this\",\"is\",\"example\"], \"is\") = true","title":"contains() and friends"},{"location":"reference/functions/#containsobjectliststring-value","text":"Checks if the given container type has the given value in it. This function behave slightly differently based on whether the first argument is an object, a list, or a string. This function is case-sensitive. For objects, checks if the object has a key with the given name. For example, contains(file, \"ctime\") = true contains(file, \"day\") = true (if file has a date in its title, false otherwise) For lists, checks if any of the array elements equals the given value. For example, contains(list(1, 2, 3), 3) = true contains(list(), 1) = false For strings, checks if the given value is a substring (i.e., inside) the string. contains(\"hello\", \"lo\") = true contains(\"yes\", \"no\") = false","title":"contains(object|list|string, value)"},{"location":"reference/functions/#icontainsobjectliststring-value","text":"Case insensitive version of contains() .","title":"icontains(object|list|string, value)"},{"location":"reference/functions/#econtainsobjectliststring-value","text":"\"Exact contains\" checks if the exact match is found in the string/list. This function is case sensitive. For strings, it behaves exactly like contains() . econtains(\"Hello\", \"Lo\") = false econtains(\"Hello\", \"lo\") = true For lists, it checks if the exact word is in the list. econtains([\"These\", \"are\", \"words\"], \"word\") = false econtains([\"These\", \"are\", \"words\"], \"words\") = true For objects, it checks if the exact key name is present in the object. It does not do recursive checks. econtains({key:\"value\", pairs:\"here\"}, \"here\") = false econtains({key:\"value\", pairs:\"here\"}, \"key\") = true econtains({key:\"value\", recur:{recurkey: \"val\"}}, \"value\") = false econtains({key:\"value\", recur:{recurkey: \"val\"}}, \"Recur\") = false econtains({key:\"value\", recur:{recurkey: \"val\"}}, \"recurkey\") = false","title":"econtains(object|list|string, value)"},{"location":"reference/functions/#containswordliststring-value","text":"Checks if value has an exact word match in string or list . This is case insensitive. The outputs are different for different types of input, see examples. For strings, it checks if the word is present in the given string. containsword(\"word\", \"word\") = true containsword(\"word\", \"Word\") = true containsword(\"words\", \"Word\") = false containsword(\"Hello there!, \"hello\") = true containsword(\"Hello there!, \"HeLLo\") = true containsword(\"Hello there chaps!, \"chap\") = false containsword(\"Hello there chaps!, \"chaps\") = true For lists, it returns a list of booleans indicating if the word's exact case insensitive match was found. containsword([\"I have no words.\", \"words\"], \"Word\") = [false, false] containsword([\"word\", \"Words\"], \"Word\") = [true, false] containsword([\"Word\", \"Words in word\"], \"WORD\") = [true, true]","title":"containsword(list|string, value)"},{"location":"reference/functions/#extractobject-key1-key2","text":"Pulls multiple fields out of an object, creating a new object with just those fields. extract(file, \"ctime\", \"mtime\") = object(\"ctime\", file.ctime, \"mtime\", file.mtime) extract(object(\"test\", 1)) = object()","title":"extract(object, key1, key2, ...)"},{"location":"reference/functions/#sortlist","text":"Sorts a list, returning a new list in sorted order. sort(list(3, 2, 1)) = list(1, 2, 3) sort(list(\"a\", \"b\", \"aa\")) = list(\"a\", \"aa\", \"b\")","title":"sort(list)"},{"location":"reference/functions/#reverselist","text":"Reverses a list, returning a new list in reversed order. reverse(list(1, 2, 3)) = list(3, 2, 1) reverse(list(\"a\", \"b\", \"c\")) = list(\"c\", \"b\", \"a\")","title":"reverse(list)"},{"location":"reference/functions/#lengthobjectarray","text":"Returns the number of fields in an object, or the number of entries in an array. length([]) = 0 length([1, 2, 3]) = 3 length(object(\"hello\", 1, \"goodbye\", 2)) = 2","title":"length(object|array)"},{"location":"reference/functions/#nonnullarray","text":"Return a new array with all null values removed. nonnull([]) = [] nonnull([null, false]) = [false] nonnull([1, 2, 3]) = [1, 2, 3]","title":"nonnull(array)"},{"location":"reference/functions/#allarray","text":"Returns true only if ALL values in the array are truthy. You can also pass multiple arguments to this function, in which case it returns true only if all arguments are truthy. all([1, 2, 3]) = true all([true, false]) = false all(true, false) = false all(true, true, true) = true You can pass a function as second argument to return only true if all elements in the array matches the predicate. all([1, 2, 3], (x) => x > 0) = true all([1, 2, 3], (x) => x > 1) = false all([\"apple\", \"pie\", 3], (x) => typeof(x) = \"string\") = false","title":"all(array)"},{"location":"reference/functions/#anyarray","text":"Returns true if ANY of the values in the array are truthy. You can also pass multiple arguments to this function, in which case it returns true if any of the arguments are truthy. any(list(1, 2, 3)) = true any(list(true, false)) = true any(list(false, false, false)) = false any(true, false) = true any(false, false) = false You can pass a function as second argument to return only true if any element in the array matches the predicate. any(list(1, 2, 3), (x) => x > 2) = true any(list(1, 2, 3), (x) => x = 0) = false","title":"any(array)"},{"location":"reference/functions/#nonearray","text":"Returns true if NONE of the values in the array are truthy. none([]) = true none([false, false]) = true none([false, true]) = false none([1, 2, 3]) = false You can pass a function as second argument to return only true if none of the elements in the array matches the predicate. none([1, 2, 3], (x) => x = 0) = true none([true, true], (x) => x = false) = true none([\"Apple\", \"Pi\", \"Banana\"], (x) => startswith(x, \"A\")) = false","title":"none(array)"},{"location":"reference/functions/#joinarray-delimiter","text":"Joins elements in an array into a single string (i.e., rendering them all on the same line). If provided with a second argument, then each element will be separated by the given separator. join(list(1, 2, 3)) = \"1, 2, 3\" join(list(1, 2, 3), \" \") = \"1 2 3\" join(6) = \"6\" join(list()) = \"\"","title":"join(array, [delimiter])"},{"location":"reference/functions/#filterarray-predicate","text":"Filters elements in an array according to the predicate, returning a new list of the elements which matched. filter([1, 2, 3], (x) => x >= 2) = [2, 3] filter([\"yes\", \"no\", \"yas\"], (x) => startswith(x, \"y\")) = [\"yes\", \"yas\"]","title":"filter(array, predicate)"},{"location":"reference/functions/#maparray-func","text":"Applies the function to each element in the array, returning a list of the mapped results. map([1, 2, 3], (x) => x + 2) = [3, 4, 5] map([\"yes\", \"no\"], (x) => x + \"?\") = [\"yes?\", \"no?\"]","title":"map(array, func)"},{"location":"reference/functions/#string-operations","text":"","title":"String Operations"},{"location":"reference/functions/#regexmatchpattern-string","text":"Checks if the given string matches the given pattern (using the JavaScript regex engine). regexmatch(\"\\w+\", \"hello\") = true regexmatch(\".\", \"a\") = true regexmatch(\"yes|no\", \"maybe\") = false","title":"regexmatch(pattern, string)"},{"location":"reference/functions/#regexreplacestring-pattern-replacement","text":"Replaces all instances where the regex pattern matches in string , with replacement . This uses the JavaScript replace method under the hood, so you can use special characters like $1 to refer to the first capture group, and so on. regexreplace(\"yes\", \"[ys]\", \"a\") = \"aea\" regexreplace(\"Suite 1000\", \"\\d+\", \"-\") = \"Suite -\"","title":"regexreplace(string, pattern, replacement)"},{"location":"reference/functions/#replacestring-pattern-replacement","text":"Replace all instances of pattern in string with replacement . replace(\"what\", \"wh\", \"h\") = \"hat\" replace(\"The big dog chased the big cat.\", \"big\", \"small\") = \"The small dog chased the small cat.\" replace(\"test\", \"test\", \"no\") = \"no\"","title":"replace(string, pattern, replacement)"},{"location":"reference/functions/#lowerstring","text":"Convert a string to all lower case. lower(\"Test\") = \"test\" lower(\"TEST\") = \"test\"","title":"lower(string)"},{"location":"reference/functions/#upperstring","text":"Convert a string to all upper case. upper(\"Test\") = \"TEST\" upper(\"test\") = \"TEST\"","title":"upper(string)"},{"location":"reference/functions/#splitstring-delimiter-limit","text":"Split a string on the given delimiter string. If a third argument is provided, it limits the number of splits that occur. The delimiter string is interpreted as a regular expression. If there are capture groups in the delimiter, matches are spliced into the result array, and non-matching captures are empty strings. split(\"hello world\", \" \") = list(\"hello\", \"world\") split(\"hello world\", \"\\s\") = list(\"hello\", \"world\") split(\"hello there world\", \" \", 2) = list(\"hello\", \"there\") split(\"hello there world\", \"(t?here)\") = list(\"hello \", \"there\", \" world\") split(\"hello there world\", \"( )(x)?\") = list(\"hello\", \" \", \"\", \"there\", \" \", \"\", \"world\")","title":"split(string, delimiter, [limit])"},{"location":"reference/functions/#startswithstring-prefix","text":"Checks if a string starts with the given prefix. startswith(\"yes\", \"ye\") = true startswith(\"path/to/something\", \"path/\") = true startswith(\"yes\", \"no\") = false","title":"startswith(string, prefix)"},{"location":"reference/functions/#endswithstring-suffix","text":"Checks if a string ends with the given suffix. endswith(\"yes\", \"es\") = true endswith(\"path/to/something\", \"something\") = true endswith(\"yes\", \"ye\") = false","title":"endswith(string, suffix)"},{"location":"reference/functions/#padleftstring-length-padding","text":"Pads a string up to the desired length by adding padding on the left side. If you omit the padding character, spaces will be used by default. padleft(\"hello\", 7) = \" hello\" padleft(\"yes\", 5, \"!\") = \"!!yes\"","title":"padleft(string, length, [padding])"},{"location":"reference/functions/#padrightstring-length-padding","text":"Equivalent to padleft , but pads to the right instead. padright(\"hello\", 7) = \"hello \" padright(\"yes\", 5, \"!\") = \"yes!!\"","title":"padright(string, length, [padding])"},{"location":"reference/functions/#substringstring-start-end","text":"Take a slice of a string, starting at start and ending at end (or the end of the string if unspecified). substring(\"hello\", 0, 2) = \"he\" substring(\"hello\", 2, 4) = \"ll\" substring(\"hello\", 2) = \"llo\" substring(\"hello\", 0) = \"hello\"","title":"substring(string, start, [end])"},{"location":"reference/functions/#truncatestring-length-suffix","text":"Truncate a string to be at most the given length, including the suffix (which defaults to ... ). Generally useful to cut off long text in tables. truncate(\"Hello there!\", 8) = \"Hello...\" truncate(\"Hello there!\", 8, \"/\") = \"Hello t/\" truncate(\"Hello there!\", 10) = \"Hello t...\" truncate(\"Hello there!\", 10, \"!\") = \"Hello the!\" truncate(\"Hello there!\", 20) = \"Hello there!\"","title":"truncate(string, length, [suffix])"},{"location":"reference/functions/#utility-functions","text":"","title":"Utility Functions"},{"location":"reference/functions/#defaultfield-value","text":"If field is null, return value ; otherwise return field . Useful for replacing null values with defaults. For example, to show projects which haven't been completed yet, use \"incomplete\" as their default value: default(dateCompleted, \"incomplete\") Default is vectorized in both arguments; if you need to use default explicitly on a list argument, use ldefault , which is the same as default but is not vectorized. default(list(1, 2, null), 3) = list(1, 2, 3) ldefault(list(1, 2, null), 3) = list(1, 2, null)","title":"default(field, value)"},{"location":"reference/functions/#choicebool-left-right","text":"A primitive if statement - if the first argument is truthy, returns left; otherwise, returns right. choice(true, \"yes\", \"no\") = \"yes\" choice(false, \"yes\", \"no\") = \"no\" choice(x > 4, y, z) = y if x > 4, else z","title":"choice(bool, left, right)"},{"location":"reference/functions/#striptimedate","text":"Strip the time component of a date, leaving only the year, month, and day. Good for date comparisons if you don't care about the time. striptime(file.ctime) = file.cday striptime(file.mtime) = file.mday","title":"striptime(date)"},{"location":"reference/functions/#dateformatdatedatetime-string","text":"Format a Dataview date using a formatting string. Uses Luxon tokens . dateformat(file.ctime,\"yyyy-MM-dd\") = \"2022-01-05\" dateformat(file.ctime,\"HH:mm:ss\") = \"12:18:04\" dateformat(date(now),\"x\") = \"1407287224054\" dateformat(file.mtime,\"ffff\") = \"Wednesday, August 6, 2014, 1:07 PM Eastern Daylight Time\"","title":"dateformat(date|datetime, string)"},{"location":"reference/functions/#localtimedate","text":"Converts a date in a fixed timezone to a date in the current timezone.","title":"localtime(date)"},{"location":"reference/functions/#metalink","text":"Get an object containing metadata of a link. When you access a property on a link what you get back is the property value from the linked file. The meta function makes it possible to access properties of the link itself. There are several properties on the object returned by meta :","title":"meta(link)"},{"location":"reference/functions/#metalinkdisplay","text":"Get the display text of a link, or null if the link does not have defined display text. meta([[2021-11-01|Displayed link text]]).display = \"Displayed link text\" meta([[2021-11-01]]).display = null","title":"meta(link).display"},{"location":"reference/functions/#metalinkembed","text":"True or false depending on whether the link is an embed. Those are links that begin with an exclamation mark, like ![[Some Link]] .","title":"meta(link).embed"},{"location":"reference/functions/#metalinkpath","text":"Get the path portion of a link. meta([[My Project]]).path = \"My Project\" meta([[My Project#Next Actions]]).path = \"My Project\" meta([[My Project#^9bcbe8]]).path = \"My Project\"","title":"meta(link).path"},{"location":"reference/functions/#metalinksubpath","text":"Get the subpath of a link. For links to a heading within a file the subpath will be the text of the heading. For links to a block the subpath will be the block ID. If neither of those cases applies then the subpath will be null. meta([[My Project#Next Actions]]).subpath = \"Next Actions\" meta([[My Project#^9bcbe8]]).subpath = \"9bcbe8\" meta([[My Project]]).subpath = null This can be used to select tasks under specific headings. ```dataview task where meta(section).subpath = \"Next Actions\" ```","title":"meta(link).subpath"},{"location":"reference/functions/#metalinktype","text":"Has the value \"file\", \"header\", or \"block\" depending on whether the link links to an entire file, a heading within a file, or to a block within a file. meta([[My Project]]).type = \"file\" meta([[My Project#Next Actions]]).type = \"header\" meta([[My Project#^9bcbe8]]).type = \"block\"","title":"meta(link).type"},{"location":"reference/literals/","text":"Literals Dataview query language literals are expressions which represent constant values like \"hello\" or 1337 . The following is an extensive, but non-exhaustive list of possible literals in DQL. General Literal Description 0 The number zero 1337 A positive number -1337 A negative number \"The quick brown fox jumps over the lazy dog\" Some text, commonly referred to by programmers as a string [[Link]] A link to the file named \"Link\" [[]] A link to the current file [1, 2, 3] A list of numbers 1, 2, and 3 [[1, 2],[3, 4]] A list of lists { a: 1, b: 2 } An object Dates Note that date() is also a function , which can be called on text to extract dates. Literal Description date(2021-11-11) A date, November 11th, 2021 date(today) A date representing the current date date(now) A date representing the current date and time date(tomorrow) A date representing tomorrow's date date(yesterday) A date representing yesterday's date date(sow) A date representing the start of the current week date(eow) A date representing the end of the current week date(som) A date representing the start of the current month date(eom) A date representing the end of the current month date(soy) A date representing the start of the current year date(eoy) A date representing the end of the current year Durations Seconds Literal Description dur(1 s) one second dur(3 s) three seconds dur(1 sec) one second dur(3 secs) three seconds dur(1 second) one second dur(3 seconds) three seconds Minutes Literal Description dur(1 m) one minute dur(3 m) three minutes dur(1 min) one minute dur(3 mins) three minutes dur(1 minute) one minute dur(3 minutes) three minutes Hours Literal Description dur(1 h) one hour dur(3 h) three hours dur(1 hr) one hour dur(3 hrs) three hours dur(1 hour) one hour dur(3 hours) three hours Days Literal Description dur(1 d) one day dur(3 d) three days dur(1 day) one day dur(3 days) three days Weeks Literal Description dur(1 w) one week dur(3 w) three weeks dur(1 wk) one week dur(3 wks) three weeks dur(1 week) one week dur(3 weeks) three weeks Months Literal Description dur(1 mo) one month dur(3 mo) three month dur(1 month) one month dur(3 months) three months Years Literal Description dur(1 yr) one year dur(3 yrs) three years dur(1 year) one year dur(3 years) three years Combinations Literal Description dur(1 s, 2 m, 3 h) three hours, two minutes, and one second dur(1 s 2 m 3 h) three hours, two minutes, and one second dur(1s 2m 3h) three hours, two minutes, and one second dur(1second 2min 3h) three hours, two minutes, and one second","title":"Literals"},{"location":"reference/literals/#literals","text":"Dataview query language literals are expressions which represent constant values like \"hello\" or 1337 . The following is an extensive, but non-exhaustive list of possible literals in DQL.","title":"Literals"},{"location":"reference/literals/#general","text":"Literal Description 0 The number zero 1337 A positive number -1337 A negative number \"The quick brown fox jumps over the lazy dog\" Some text, commonly referred to by programmers as a string [[Link]] A link to the file named \"Link\" [[]] A link to the current file [1, 2, 3] A list of numbers 1, 2, and 3 [[1, 2],[3, 4]] A list of lists { a: 1, b: 2 } An object","title":"General"},{"location":"reference/literals/#dates","text":"Note that date() is also a function , which can be called on text to extract dates. Literal Description date(2021-11-11) A date, November 11th, 2021 date(today) A date representing the current date date(now) A date representing the current date and time date(tomorrow) A date representing tomorrow's date date(yesterday) A date representing yesterday's date date(sow) A date representing the start of the current week date(eow) A date representing the end of the current week date(som) A date representing the start of the current month date(eom) A date representing the end of the current month date(soy) A date representing the start of the current year date(eoy) A date representing the end of the current year","title":"Dates"},{"location":"reference/literals/#durations","text":"","title":"Durations"},{"location":"reference/literals/#seconds","text":"Literal Description dur(1 s) one second dur(3 s) three seconds dur(1 sec) one second dur(3 secs) three seconds dur(1 second) one second dur(3 seconds) three seconds","title":"Seconds"},{"location":"reference/literals/#minutes","text":"Literal Description dur(1 m) one minute dur(3 m) three minutes dur(1 min) one minute dur(3 mins) three minutes dur(1 minute) one minute dur(3 minutes) three minutes","title":"Minutes"},{"location":"reference/literals/#hours","text":"Literal Description dur(1 h) one hour dur(3 h) three hours dur(1 hr) one hour dur(3 hrs) three hours dur(1 hour) one hour dur(3 hours) three hours","title":"Hours"},{"location":"reference/literals/#days","text":"Literal Description dur(1 d) one day dur(3 d) three days dur(1 day) one day dur(3 days) three days","title":"Days"},{"location":"reference/literals/#weeks","text":"Literal Description dur(1 w) one week dur(3 w) three weeks dur(1 wk) one week dur(3 wks) three weeks dur(1 week) one week dur(3 weeks) three weeks","title":"Weeks"},{"location":"reference/literals/#months","text":"Literal Description dur(1 mo) one month dur(3 mo) three month dur(1 month) one month dur(3 months) three months","title":"Months"},{"location":"reference/literals/#years","text":"Literal Description dur(1 yr) one year dur(3 yrs) three years dur(1 year) one year dur(3 years) three years","title":"Years"},{"location":"reference/literals/#combinations","text":"Literal Description dur(1 s, 2 m, 3 h) three hours, two minutes, and one second dur(1 s 2 m 3 h) three hours, two minutes, and one second dur(1s 2m 3h) three hours, two minutes, and one second dur(1second 2min 3h) three hours, two minutes, and one second","title":"Combinations"},{"location":"reference/sources/","text":"Sources A dataview \"source\" is something that identifies a set of files, tasks, or other data object. Sources are indexed internally by Dataview, so they are fast to query. Dataview currently supports four source types: Tags : Sources of the form #tag . These match all files / sections / tasks with the given tag. Folders : Sources of the form \"folder\" . These match all files / sections / tasks contained in the given folder. The full vault path is expected instead of just the folder name. Note that trailing slashes are not supported, i.e. \"Path/To/Folder/\" will not work but \"Path/To/Folder\" will. Specific Files : You can select from a specific file by specifying it's full path: \"folder/File\" . If you have both a file and a folder with the exact same path, Dataview will prefer the folder. You can force it to read from the file by specifying an extension: folder/File.md . Links : You can either select links to a file, or all links from a file. To obtain all pages which link to [[note]] , use [[note]] . To obtain all pages which link from [[note]] (i.e., all the links in that file), use outgoing([[note]]) . You can implicitly reference the current file via [[#]] or [[]] , i.e. [[]] lets you query from all files linking to the current file. You can compose these filters in order to get more advanced sources using and and or . For example, #tag and \"folder\" will return all pages in folder and with #tag . Querying from #food and !#fastfood will only return pages that contain #food but does not contain #fastfood . [[Food]] or [[Exercise]] will give any pages which link to [[Food]] OR [[Exercise]] . If you have complex queries where grouping or precedence matters, you can use parenthesis to logically group them: #tag and (\"folder\" or #other-tag) (#tag1 or #tag2) and (#tag3 or #tag4) Sources are used in both the FROM query statement , as well as various JavaScript API query calls.","title":"Sources"},{"location":"reference/sources/#sources","text":"A dataview \"source\" is something that identifies a set of files, tasks, or other data object. Sources are indexed internally by Dataview, so they are fast to query. Dataview currently supports four source types: Tags : Sources of the form #tag . These match all files / sections / tasks with the given tag. Folders : Sources of the form \"folder\" . These match all files / sections / tasks contained in the given folder. The full vault path is expected instead of just the folder name. Note that trailing slashes are not supported, i.e. \"Path/To/Folder/\" will not work but \"Path/To/Folder\" will. Specific Files : You can select from a specific file by specifying it's full path: \"folder/File\" . If you have both a file and a folder with the exact same path, Dataview will prefer the folder. You can force it to read from the file by specifying an extension: folder/File.md . Links : You can either select links to a file, or all links from a file. To obtain all pages which link to [[note]] , use [[note]] . To obtain all pages which link from [[note]] (i.e., all the links in that file), use outgoing([[note]]) . You can implicitly reference the current file via [[#]] or [[]] , i.e. [[]] lets you query from all files linking to the current file. You can compose these filters in order to get more advanced sources using and and or . For example, #tag and \"folder\" will return all pages in folder and with #tag . Querying from #food and !#fastfood will only return pages that contain #food but does not contain #fastfood . [[Food]] or [[Exercise]] will give any pages which link to [[Food]] OR [[Exercise]] . If you have complex queries where grouping or precedence matters, you can use parenthesis to logically group them: #tag and (\"folder\" or #other-tag) (#tag1 or #tag2) and (#tag3 or #tag4) Sources are used in both the FROM query statement , as well as various JavaScript API query calls.","title":"Sources"},{"location":"resources/develop-against-dataview/","text":"Developing Against Dataview Dataview includes a high-level plugin-facing API as well as TypeScript definitions and a utility library; to install it, simply use: npm install -D obsidian-dataview Accessing the Dataview API You can use the getAPI() function to obtain the Dataview Plugin API; this returns a DataviewApi object which provides various utilities, including rendering dataviews, checking dataview's version, hooking into the dataview event life cycle, and querying dataview metadata. import { getAPI } from \"obsidian-dataview\" ; const api = getAPI (); For full API definitions available, check index.ts or the plugin API definition plugin-api.ts . Binding to Dataview Events You can bind to dataview metadata events, which fire on all file updates and changes, via: plugin . registerEvent ( plugin . app . metadataCache . on ( \"dataview:index-ready\" , () => { ... }); plugin . registerEvent ( plugin . app . metadataCache . on ( \"dataview:metadata-change\" , ( type , file , oldPath ? ) => { ... })); For all events hooked on MetadataCache, check index.ts . Value Utilities You can access various type utilities which let you check the types of objects and compare them via Values : import { getAPI , Values } from \"obsidian-dataview\" ; const field = getAPI ( plugin . app ) ? . page ( 'sample.md' ). field ; if ( ! field ) return ; if ( Values . isHtml ( field )) // do something else if ( Values . isLink ( field )) // do something // ...","title":"Developing Against Dataview"},{"location":"resources/develop-against-dataview/#developing-against-dataview","text":"Dataview includes a high-level plugin-facing API as well as TypeScript definitions and a utility library; to install it, simply use: npm install -D obsidian-dataview","title":"Developing Against Dataview"},{"location":"resources/develop-against-dataview/#accessing-the-dataview-api","text":"You can use the getAPI() function to obtain the Dataview Plugin API; this returns a DataviewApi object which provides various utilities, including rendering dataviews, checking dataview's version, hooking into the dataview event life cycle, and querying dataview metadata. import { getAPI } from \"obsidian-dataview\" ; const api = getAPI (); For full API definitions available, check index.ts or the plugin API definition plugin-api.ts .","title":"Accessing the Dataview API"},{"location":"resources/develop-against-dataview/#binding-to-dataview-events","text":"You can bind to dataview metadata events, which fire on all file updates and changes, via: plugin . registerEvent ( plugin . app . metadataCache . on ( \"dataview:index-ready\" , () => { ... }); plugin . registerEvent ( plugin . app . metadataCache . on ( \"dataview:metadata-change\" , ( type , file , oldPath ? ) => { ... })); For all events hooked on MetadataCache, check index.ts .","title":"Binding to Dataview Events"},{"location":"resources/develop-against-dataview/#value-utilities","text":"You can access various type utilities which let you check the types of objects and compare them via Values : import { getAPI , Values } from \"obsidian-dataview\" ; const field = getAPI ( plugin . app ) ? . page ( 'sample.md' ). field ; if ( ! field ) return ; if ( Values . isHtml ( field )) // do something else if ( Values . isLink ( field )) // do something // ...","title":"Value Utilities"},{"location":"resources/examples/","text":"Examples A small collection of simple usages of the dataview query language. Show all games in the games folder, sorted by rating, with some metadata: Query TABLE time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM \"games\" SORT rating DESC Output File Time Played Length Rating Outer Wilds November 19th - 21st, 2020 15h 9.5 Minecraft All the time. 2000h 9.5 Pillars of Eternity 2 August - October 2019 100h 9 List games which are MOBAs or CRPGs. Query LIST FROM # games / mobas OR # games / crpg Output League of Legends Pillars of Eternity 2 List all tasks in un-completed projects: Query TASK FROM \"dataview\" Output dataview/Project A I am a task. I am another task. dataview/Project A I could be a task, though who knows. Determine if this is a task. I'm a finished task. List all of the files in the books folder, sorted by the last time you modified the file: Query TABLE file . mtime AS \"Last Modified\" FROM \"books\" SORT file . mtime DESC Output File Last Modified Atomic Habits 11:06 PM - August 07, 2021 Can't Hurt Me 10:58 PM - August 07, 2021 Deep Work 10:52 PM - August 07, 2021 List all files which have a date in their title (of the form yyyy-mm-dd ), and list them by date order. Query LIST file . day WHERE file . day SORT file . day DESC Output 2021-08-07 : August 07, 2021 2020-08-10 : August 10, 2020","title":"Examples"},{"location":"resources/examples/#examples","text":"A small collection of simple usages of the dataview query language. Show all games in the games folder, sorted by rating, with some metadata: Query TABLE time - played AS \"Time Played\" , length AS \"Length\" , rating AS \"Rating\" FROM \"games\" SORT rating DESC Output File Time Played Length Rating Outer Wilds November 19th - 21st, 2020 15h 9.5 Minecraft All the time. 2000h 9.5 Pillars of Eternity 2 August - October 2019 100h 9 List games which are MOBAs or CRPGs. Query LIST FROM # games / mobas OR # games / crpg Output League of Legends Pillars of Eternity 2 List all tasks in un-completed projects: Query TASK FROM \"dataview\" Output dataview/Project A I am a task. I am another task. dataview/Project A I could be a task, though who knows. Determine if this is a task. I'm a finished task. List all of the files in the books folder, sorted by the last time you modified the file: Query TABLE file . mtime AS \"Last Modified\" FROM \"books\" SORT file . mtime DESC Output File Last Modified Atomic Habits 11:06 PM - August 07, 2021 Can't Hurt Me 10:58 PM - August 07, 2021 Deep Work 10:52 PM - August 07, 2021 List all files which have a date in their title (of the form yyyy-mm-dd ), and list them by date order. Query LIST file . day WHERE file . day SORT file . day DESC Output 2021-08-07 : August 07, 2021 2020-08-10 : August 10, 2020","title":"Examples"},{"location":"resources/faq/","text":"Frequently Asked Questions A collection of frequently asked questions for Dataview queries and the expression language. How do I use fields with the same name as keywords (like \"from\", \"where\")? Dataview provides a special \"fake\" field called row which can be indexed into to obtain fields which conflict with Dataview keywords: row . from /* Same as \"from\" */ row . where /* Same as \"where\" */ How do I access fields with spaces in the name? There are two ways: Use the normalized Dataview name for such a field - just convert the name to lowercase and replace whitespace with dashes (\"-\"). Something like Field With Space In It becomes field-with-space-in-it . Use the implicit row field: row [ \"Field With Space In It\" ] Do you have a list of resources to learn from? Yes! Please see the Resources page. Can I save the result of a query for reusability? You can write reusable Javascript Queries with the dv.view function. In DQL, beside the possibility of writing your Query inside a Template and using this template (either with the Core Plugin Templates or the popular Community Plugin Templater ), you can save calculations in metadata fields via Inline DQL , for example: start:: 07h00m end:: 18h00m pause:: 01h30m duration:: `= this.end - this.start - this.pause` You can list the value (9h 30m in our example) then i.e. in a TABLE without needing to repeat the calculation: ```dataview TABLE start, end, duration WHERE duration ``` Gives you File (1) start end duration Example 7 hours 18 hours 9 hours, 30 minutes But storing a Inline DQL in a field comes with a limitation : While the value that gets displayed in the result is the calculated one, the saved value inside your metadata field is still your Inline DQL calculation . The value is literally = this.end - this.start - this.pause . This means you cannot filter for the Inlines' result like: ```dataview TABLE start, end, duration WHERE duration > dur(\"10h\") ``` This will give you back the example page, even though the result doesn't fulfill the WHERE clause, because the value you are comparing against is = this.end - this.start - this.pause and is not a duration. How can I hide the result count on TABLE Queries? There is no built-in Dataview Setting to do so, but you can use a CSS Snippet for that: . dataview th : first-of-type . small-text { visibility : hidden ; } Create a .css file (i.e. hide-dataview-count.css ) inside the folder .obsidian/snippets in your vault, copy & paste the above code and and activate the snippet in the appareance settings. To read more about CSS Snippets and how to apply them refer to the official Obsidian documentation .","title":"Frequently Asked Questions"},{"location":"resources/faq/#frequently-asked-questions","text":"A collection of frequently asked questions for Dataview queries and the expression language.","title":"Frequently Asked Questions"},{"location":"resources/faq/#how-do-i-use-fields-with-the-same-name-as-keywords-like-from-where","text":"Dataview provides a special \"fake\" field called row which can be indexed into to obtain fields which conflict with Dataview keywords: row . from /* Same as \"from\" */ row . where /* Same as \"where\" */","title":"How do I use fields with the same name as keywords (like \"from\", \"where\")?"},{"location":"resources/faq/#how-do-i-access-fields-with-spaces-in-the-name","text":"There are two ways: Use the normalized Dataview name for such a field - just convert the name to lowercase and replace whitespace with dashes (\"-\"). Something like Field With Space In It becomes field-with-space-in-it . Use the implicit row field: row [ \"Field With Space In It\" ]","title":"How do I access fields with spaces in the name?"},{"location":"resources/faq/#do-you-have-a-list-of-resources-to-learn-from","text":"Yes! Please see the Resources page.","title":"Do you have a list of resources to learn from?"},{"location":"resources/faq/#can-i-save-the-result-of-a-query-for-reusability","text":"You can write reusable Javascript Queries with the dv.view function. In DQL, beside the possibility of writing your Query inside a Template and using this template (either with the Core Plugin Templates or the popular Community Plugin Templater ), you can save calculations in metadata fields via Inline DQL , for example: start:: 07h00m end:: 18h00m pause:: 01h30m duration:: `= this.end - this.start - this.pause` You can list the value (9h 30m in our example) then i.e. in a TABLE without needing to repeat the calculation: ```dataview TABLE start, end, duration WHERE duration ``` Gives you File (1) start end duration Example 7 hours 18 hours 9 hours, 30 minutes But storing a Inline DQL in a field comes with a limitation : While the value that gets displayed in the result is the calculated one, the saved value inside your metadata field is still your Inline DQL calculation . The value is literally = this.end - this.start - this.pause . This means you cannot filter for the Inlines' result like: ```dataview TABLE start, end, duration WHERE duration > dur(\"10h\") ``` This will give you back the example page, even though the result doesn't fulfill the WHERE clause, because the value you are comparing against is = this.end - this.start - this.pause and is not a duration.","title":"Can I save the result of a query for reusability?"},{"location":"resources/faq/#how-can-i-hide-the-result-count-on-table-queries","text":"There is no built-in Dataview Setting to do so, but you can use a CSS Snippet for that: . dataview th : first-of-type . small-text { visibility : hidden ; } Create a .css file (i.e. hide-dataview-count.css ) inside the folder .obsidian/snippets in your vault, copy & paste the above code and and activate the snippet in the appareance settings. To read more about CSS Snippets and how to apply them refer to the official Obsidian documentation .","title":"How can I hide the result count on TABLE Queries?"},{"location":"resources/resources-and-support/","text":"Other Resources There is a bit of a learning curve to getting started with Dataview. This page is a collection of resources that will help you get started. Dataview gets new features and fixes fairly frequently so please account for these resources being slightly out of date. Feel free to contribute directly to this list, documentation, or even reach out to the authors of the original sources for updates. Resources The Obsidian Hub SkepticMystic's Introduction to Dataview supplemented by a textual guide YouTube videos SkepticMystic's aforementioned community talk Dataview Plugin: How To Use This Powerful Obsidian Plugin (With Examples) by Filipe Donadio Automate Your Vault With Dataview - How To Use Dataview in Obsidian by FromSergio How to use the Obsidian Dataview plugin by Nicole van der Hoeven Intro to Dataview Plugin - Obsidian Community Talk Example Vault @s-blu has very kindly put together a vault of example queries that you can use as a playground of sorts. Blog Posts Obsidian Dataview For Beginners: A checklist to help fix your dataview queries GitHub Discussion The GitHub repository has a fairly active Discussions Page with dozens of answered questions. Obsidian Forums The Obsidian Forums have a wealth of questions and answers and other interesting tidbits as well. Try searching the forums for an answer, especially if it seems like a beginner question. Discord The Obsidian Members Group Discord server has a #dataview channel. Once again, more likely than not, your question has been asked before so try searching the thread though it is known that Discord's search can be spotty. In case you don't find anything satisfactory, This is the closest you'll get to real-time support but there are no guarantees of instant replies. There are many helpful people though so don't be afraid to ask. Support Where do you go when you have questions? Here's what we recommend you try. Search GitHub Discussions and the Obsidian Forums for your question. Search through Discord for possible solutions. Depending on the complexity of the your question: If you need close to synchronous communication, use Discord. Note that we are a community of volunteers and there may be delays in responding. If you expect your problem needs time over multiple days and asynchronous communication, open a GitHub discussion. If you found a bug, please report it in the repo's issues .","title":"Resources and Support"},{"location":"resources/resources-and-support/#other-resources","text":"There is a bit of a learning curve to getting started with Dataview. This page is a collection of resources that will help you get started. Dataview gets new features and fixes fairly frequently so please account for these resources being slightly out of date. Feel free to contribute directly to this list, documentation, or even reach out to the authors of the original sources for updates.","title":"Other Resources"},{"location":"resources/resources-and-support/#resources","text":"","title":"Resources"},{"location":"resources/resources-and-support/#the-obsidian-hub","text":"SkepticMystic's Introduction to Dataview supplemented by a textual guide","title":"The Obsidian Hub"},{"location":"resources/resources-and-support/#youtube-videos","text":"SkepticMystic's aforementioned community talk Dataview Plugin: How To Use This Powerful Obsidian Plugin (With Examples) by Filipe Donadio Automate Your Vault With Dataview - How To Use Dataview in Obsidian by FromSergio How to use the Obsidian Dataview plugin by Nicole van der Hoeven Intro to Dataview Plugin - Obsidian Community Talk","title":"YouTube videos"},{"location":"resources/resources-and-support/#example-vault","text":"@s-blu has very kindly put together a vault of example queries that you can use as a playground of sorts.","title":"Example Vault"},{"location":"resources/resources-and-support/#blog-posts","text":"Obsidian Dataview For Beginners: A checklist to help fix your dataview queries","title":"Blog Posts"},{"location":"resources/resources-and-support/#github-discussion","text":"The GitHub repository has a fairly active Discussions Page with dozens of answered questions.","title":"GitHub Discussion"},{"location":"resources/resources-and-support/#obsidian-forums","text":"The Obsidian Forums have a wealth of questions and answers and other interesting tidbits as well. Try searching the forums for an answer, especially if it seems like a beginner question.","title":"Obsidian Forums"},{"location":"resources/resources-and-support/#discord","text":"The Obsidian Members Group Discord server has a #dataview channel. Once again, more likely than not, your question has been asked before so try searching the thread though it is known that Discord's search can be spotty. In case you don't find anything satisfactory, This is the closest you'll get to real-time support but there are no guarantees of instant replies. There are many helpful people though so don't be afraid to ask.","title":"Discord"},{"location":"resources/resources-and-support/#support","text":"Where do you go when you have questions? Here's what we recommend you try. Search GitHub Discussions and the Obsidian Forums for your question. Search through Discord for possible solutions. Depending on the complexity of the your question: If you need close to synchronous communication, use Discord. Note that we are a community of volunteers and there may be delays in responding. If you expect your problem needs time over multiple days and asynchronous communication, open a GitHub discussion. If you found a bug, please report it in the repo's issues .","title":"Support"}]}